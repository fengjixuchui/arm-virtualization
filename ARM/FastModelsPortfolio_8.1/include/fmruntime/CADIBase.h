/* -*- c++ -*- */
/* vim: syntax=cpp
 */
/*!
 *  \file   CADIBase.h
 *  \brief  CADI Interface Base Class
 *  \date   Copyright ARM Limited 2002-2010 All Rights Reserved.
 *          Copyright ARM Limited 2011-2013 All Rights Reserved.
 * 
 */

#ifndef __SG_CADIBase_h__
#define __SG_CADIBase_h__

#include <vector>
#include <map>
#include <set>
#include "eslapi/CADI.h"
#include "eslapi/CADIProfiling.h"
#include "eslapi/CADITypes.h"
#include "sg/Attributes.h"
#include "sg/FastDelegate.h"
#include "sg/SGPort.h"
#include "SGComponentWithPorts.h"
#include "CADIExecutionControlProtocol.h"
#include "SimExecutionControlProtocol.h"
#include "CADIProtocol.h"
#include "UserCADIImplementationProtocol.h"
#include "sg/SGComponentTrace.h"

#include "TxLib/TxLib.h"
#include "ResourceAccessFuncTypes.h"


/// forward declarations
class TxMutex;

namespace sg
{
    
class SCADI;
    

/* Macro for declaring methods which arrange for simthread_ versions
 * of themselves to be called in the simulation thread.
 * The implementations of these methods should then be defined using
 * the DEFINE_SIMTHREAD_METHOD_n() macros. (Those macros are in the
 * CADIBaseMacros.h header file which is autogenerated by the scons script.)
 * Note that this macro assumes you are using it in 'public' scope!
 * The simthread_ method is virtual so it can be overridden by CoreMxDI.
 */
#define DECLARE_SIMTHREAD_METHOD(METHOD, ARGLIST) \
  virtual eslapi::CADIReturn_t METHOD ARGLIST ;       \
  public:                           \
  virtual eslapi::CADIReturn_t simthread_ ## METHOD ARGLIST ; \
  public:                           \
  friend class METHOD ## Runnable
// note no trailing ';' so we can swallow the one the user provides


#define DECLARE_COND_SIMTHREAD_METHOD(METHOD, ARGLIST) \
  private: \
  bool doProxy ## METHOD ARGLIST ; \
  public: \
  DECLARE_SIMTHREAD_METHOD(METHOD, ARGLIST)
    
class CADIBase : 
    public eslapi::CADI, 
    public eslapi::CADIProfiling, 
    public sg::ComponentTrace
{
public:

    // reg+mem+param access functions
    // Please note that all of these are exposed in LISA and these prototypes cannot be changed
    // (hence the nasty collection of backward compatibility prototypes here)
    typedef fastdelegate::FastDelegate3<void *, uint8_t*, bool, eslapi::CADIReturn_t> RegReadFunctionOldStyle_t;                      // obsolete, do not use in new code
    typedef fastdelegate::FastDelegate3<uint32_t, uint64_t*, bool, sg::accessfunc::AccessFuncResult> RegReadFunction_t;
    typedef fastdelegate::FastDelegate3<uint32_t, std::string &, bool, sg::accessfunc::AccessFuncResult> RegReadStringFunction_t;
    typedef fastdelegate::FastDelegate3<void *, const uint8_t*, bool, eslapi::CADIReturn_t> RegWriteFunctionOldStyle_t;               // obsolete, do not use in new code
    typedef fastdelegate::FastDelegate3<uint32_t, const uint64_t*, bool, sg::accessfunc::AccessFuncResult> RegWriteFunction_t;
    typedef fastdelegate::FastDelegate3<uint32_t, const std::string &, bool, sg::accessfunc::AccessFuncResult> RegWriteStringFunction_t;
    typedef fastdelegate::FastDelegate5<uint64_t, uint32_t, uint64_t*, bool, sg::MemoryAccessContext*, sg::accessfunc::AccessFuncResult> VAtoPAFunction_t;

    typedef fastdelegate::FastDelegate6<void*, uint32_t, eslapi::CADIAddrSimple_t, const uint8_t*, uint32_t, bool, eslapi::CADIReturn_t> MemoryWriteFunctionOldStyle_t; // obsolete, do not use in new code
    typedef fastdelegate::FastDelegate6<void*, uint32_t, eslapi::CADIAddrSimple_t, uint8_t*, uint32_t, bool, eslapi::CADIReturn_t> MemoryReadFunctionOldStyle_t;        // obsolete, do not use in new code
    typedef fastdelegate::FastDelegate7<uint32_t, uint32_t, uint64_t, uint32_t, const uint64_t*, bool, sg::MemoryAccessContext*, sg::accessfunc::AccessFuncResult> MemoryWriteFunction_t;
    typedef fastdelegate::FastDelegate7<uint32_t, uint32_t, uint64_t, uint32_t, uint64_t*, bool, sg::MemoryAccessContext*, sg::accessfunc::AccessFuncResult> MemoryReadFunction_t;

    typedef fastdelegate::FastDelegate2<uint32_t, int64_t*,             sg::accessfunc::AccessFuncResult> ParamReadFunction_t;
    typedef fastdelegate::FastDelegate2<uint32_t, std::string&,         sg::accessfunc::AccessFuncResult> ParamReadStringFunction_t;
    typedef fastdelegate::FastDelegate2<uint32_t, const int64_t*,       sg::accessfunc::AccessFuncResult> ParamWriteFunction_t;
    typedef fastdelegate::FastDelegate2<uint32_t, const std::string&,   sg::accessfunc::AccessFuncResult> ParamWriteStringFunction_t;

    // static register initialisation data (not instance specific)
    struct RegInfo
    {
        const char*                            name;            // name of register as shown in register view
        const char*                         groups;         // names of groups this register belongs to, separated by commas
        uint32_t                            registerId;        // an id to identify your register. Not used if access_data is specified
        uint32_t                            bitWidth;        // size of the register/compound in bits
        eslapi::CADIRegDisplay_t             displayFormat;    // how to display the data (hex, dec, etc.)
        const char*                         description;    // description of the register shown in tooltip
        
        eslapi::CADIRegAccessAttribute_t    attribute;      // access rights (read/write/read & write etc.)

        RegReadFunctionOldStyle_t           access_read_func_old_style;     // function used to read from register (old style)
        RegWriteFunctionOldStyle_t          access_write_func_old_style;    // function used to write to register (old style)
        
        void *                              access_data;    // data used as first argument of register access method. If 0 registerId is used instead

        bool                                hasSideEffects; // register access has side effect
        uint32_t                            lsbOffset;        // offset to least significant bit of subfield/compound
        bool                                isPipeStageField; // MxDI 6.0: is pipe stage field, also true for pc and contentInfoRegisterId in eslapi::CADIPipeStage_t
        
        const char*                            fpFormat;        // floating point format 
        uint32_t                            numSymbols;     // number of symbols in symbol list
        char**                                 symbolList;
        bool                                  isPseudoReg;
        bool                                hasInstanceSpecificPointers; // if true access_data is dependent of the 'core' pointer or other pointers
        uint32_t                            compRegisterId;

        RegReadFunction_t                   access_read_func;           // function used to read values (non string) from register 
        RegReadStringFunction_t             access_read_string_func;    // function used to read strings from register 
        RegWriteFunction_t                  access_write_func;          // function used to write values (non string) to register 
        RegWriteStringFunction_t            access_write_string_func;   // function used to write strings to register 

        uint32_t                            dwarfRegisterId;
        uint32_t                            pipeStageId;
        uint32_t                            pipeStageOffset;
        bool                                isContentInfoReg;
        bool                                supportsNotifyRead;
        bool                                supportsNotifyWrite;
    };

    // instance specific register initialization data
    struct RegInfoInstanceSpecific
    {
        void*                       access_data;
        RegReadFunctionOldStyle_t   access_read_func_old_style;     // function used to read from register (old style)
        RegWriteFunctionOldStyle_t  access_write_func_old_style;    // function used to write to register (old style)
        RegReadFunction_t           access_read_func;               // function used to read values (non string) from register 
        RegReadStringFunction_t     access_read_string_func;        // function used to read strings from register 
        RegWriteFunction_t          access_write_func;              // function used to write values (non string) to register 
        RegWriteStringFunction_t    access_write_string_func;       // function used to write strings to register 
    };

    // internal data for registers
    struct RegInfoInternal
    {
        std::string data;  // buffer to collect data for string registers which must be written at once when all data is collected
    };

    // internal data for parameters
    struct ParamInfo
    {
        uint32_t                    id;
        ParamReadFunction_t         access_read_func;
        ParamReadStringFunction_t   access_read_string_func;
        ParamWriteFunction_t        access_write_func;
        ParamWriteStringFunction_t  access_write_string_func;
    };

    // proxy interface for debugger callbacks
    class CallbackObj : public eslapi::CADICallbackObj
    {
        /// Return the CAInterface name for this interface.
        static eslapi::if_name_t IFNAME() { return "eslapi.CADICallbackObj2"; }

        /// Specify the current minor revision for this interface.
        static eslapi::if_rev_t IFREVISION() { return 0; }

        virtual eslapi::CAInterface * ObtainInterface(eslapi::if_name_t    ifName,
                                                      eslapi::if_rev_t     minRev,
                                                      eslapi::if_rev_t *   actualRev);

        /// private callback object list element type
        struct callback_t
        {
            /// enable flags for callback object
            char enable[eslapi::CADI_CB_Count];
        };

        /// mutex for controlling filling/erasing callback list 
        TxMutex  *callbacksMutex;

        /// callback list
        std::map<eslapi::CADICallbackObj*,callback_t> callback;
        
        /// pointer to parent CADIBase object
        CADIBase *owner;        

    public:
        /// constructor / desctructor
        CallbackObj(); 
        virtual ~CallbackObj(); 

        virtual uint32_t  appliOpen(const char *sFileName, const char *mode);
        //virtual void appliInput(uint32_t streamId, uint32_t maxNumOfWords, uint32_t *actualNumOfWords, uint32_t *buffer);
        //virtual void appliOutput(uint32_t streamId, uint32_t count, uint32_t *actualCount, uint32_t *buffer);
        //MxDI 6.0: changed buffers to const char*, since no target uses I/O on words 
        virtual void appliInput(uint32_t streamId, uint32_t count, uint32_t *actualCount, char *buffer);
        virtual void appliOutput(uint32_t streamId, uint32_t count, uint32_t *actualCount, const char *buffer);
        virtual uint32_t  appliClose(uint32_t streamID);
        virtual void doString(const char *stringArg);
        virtual void modeChange(uint32_t newMode, eslapi::CADIBptNumber_t bptNumber);
        virtual void reset(uint32_t resetLevel);
        virtual void cycleTick(void);
        virtual void killInterface(void);
        virtual uint32_t bypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
        virtual uint32_t lookupSymbol(uint32_t symbolLength, const char *symbol, uint32_t maxResponseLength, char *response);
        virtual void refresh(uint32_t refreshReason);


        eslapi::CADIReturn_t addCallback(eslapi::CADICallbackObj *callbackObj, char enable[eslapi::CADI_CB_Count]);
        eslapi::CADIReturn_t removeCallback(eslapi::CADICallbackObj *callbackObj);
        
        uint32_t GetNumberOfAddedCallbacks() const { return (uint32_t)callback.size();}
        bool HasDoString() const;
        void SetOwner(CADIBase *owner_) { owner = owner_; }
    };

    // constructor/destructor
    CADIBase(const std::string &componentName, sg::ComponentBase* simulationEngine);
    CADIBase();
    virtual ~CADIBase();

    /// Return the CAInterface name for this interface.
    static eslapi::if_name_t IFNAME() { return "eslapi.CADI2"; }
    
    /// Specify the current minor revision for this interface.
    static eslapi::if_rev_t IFREVISION() { return 0; }

    virtual eslapi::CAInterface * ObtainInterface(eslapi::if_name_t    ifName,
                                                  eslapi::if_rev_t     minRev,
                                                  eslapi::if_rev_t *   actualRev);

    // for late binding to simulation engine
    void setSimulationEngine(sg::ComponentBase* simulationEngine);
    // forward certain CADI calls
    Port &GetCADIPort() { return cadiPort; }
    Port &GetUserCADIPort() { return userCadiPort; }

    void construct(const RegInfo* regInfoTable, uint32_t regInfoTableSize,
                   const RegInfoInstanceSpecific* regInfoInstanceSpecificTable, uint32_t regInfoInstanceSpecificTableSize,
                   const ParamInfo* paramInfoTable, uint32_t paramInfoTableSize);
    void construct(const RegInfo* /* regInfoTable*/, uint32_t /*regInfoTableSize*/) { } // Does not do anything. For backeard compatibility only.  
    void construct() { construct(NULL, 0, NULL, 0, NULL, 0); }
    void ProcessRegisterGroups(uint32_t registerIdx);
    eslapi::CADIReturn_t AccessFuncResultToCADIReturn_t(sg::accessfunc::AccessFuncResult result);
private:
    void constructor(sg::ComponentBase* simulationEngine);

protected:
    virtual void cadiExecPort_callbackModeChangeRun();
    virtual void cadiExecPort_callbackModeChangeStop();
    virtual void cadiExecPort_callbackKillInterface();
    virtual void cadiExecPort_callbackMessage(const std::string &msg);
    virtual void cadiExecPort_callbackReset(uint32_t resetLevel);
    virtual void modeChangeCallback(int newMode, eslapi::CADIBptNumber_t bptNumber);
    virtual void cadiPort_simShutdown();
    virtual void cadiPort_cadiRefresh(uint32_t refreshReason);
public:
    void ImportCADI(eslapi::CADI* cadi, const std::string &componentName);  
    const std::map <std::string, eslapi::CADI*> &GetImportedCADIMap() const { return importedCADI; }
    void EnableSubComponentCADIImport(); 
    void ImportSubcomponentCADI();

    // these two functions may (and must) be called from the simulation thread
    virtual void SignalBreakpoint(uint32_t bptNum);
    virtual void StopSimulation();

    void ResetInternal(uint32_t level);

    virtual eslapi::CADIReturn_t CADIXfaceGetFeatures (eslapi::CADITargetFeatures_t *features);
    virtual eslapi::CADIReturn_t CADIXfaceGetError (uint32_t maxMessageLength, uint32_t *actualMessageLength, char *errorMessage);
    virtual eslapi::CADIReturn_t CADIXfaceAddCallback (eslapi::CADICallbackObj *callbackObj, char enable[eslapi::CADI_CB_Count]);
    virtual eslapi::CADIReturn_t CADIXfaceRemoveCallback (eslapi::CADICallbackObj *callbackObj);
    DECLARE_COND_SIMTHREAD_METHOD(CADIXfaceBypass, (uint32_t commandLength, const char * command, uint32_t maxResponseLength, char * response));

    virtual eslapi::CADIReturn_t CADIRegGetGroups    (uint32_t groupIndex, uint32_t desiredNumOfRegGroups, uint32_t* actualNumOfRegGroups, eslapi::CADIRegGroup_t* reg);
    virtual eslapi::CADIReturn_t CADIRegGetMap        (uint32_t groupID, uint32_t regIndex, uint32_t registerSlots, uint32_t* registerCount, eslapi::CADIRegInfo_t* reg);        
    virtual eslapi::CADIReturn_t CADIRegGetCompound    (uint32_t reg, uint32_t componentIndex, uint32_t desiredNumOfComponents, uint32_t *actualNumOfcomponents, uint32_t *components);
    virtual eslapi::CADIReturn_t CADIRegWrite        (uint32_t regCount, eslapi::CADIReg_t* reg, uint32_t* numRegsWritten, uint8_t doSideEffects);
    virtual eslapi::CADIReturn_t CADIRegRead        (uint32_t regCount, eslapi::CADIReg_t* reg, uint32_t* numRegsRead, uint8_t doSideEffects);

    virtual eslapi::CADIReturn_t CADIMemGetSpaces (uint32_t startMemSpaceIndex, uint32_t desiredNumOfMemSpaces, uint32_t *actualNumOfMemSpaces, eslapi::CADIMemSpaceInfo_t *memSpaces);
    virtual eslapi::CADIReturn_t CADIMemGetBlocks (uint32_t memorySpace, uint32_t memBlockIndex, uint32_t desiredNumOfMemBlocks, uint32_t *actualNumOfMemBlocks, 
                                           eslapi::CADIMemBlockInfo_t *memBlocks);

    DECLARE_SIMTHREAD_METHOD(CADIMemWrite, (eslapi::CADIAddrComplete_t startAddress, uint32_t unitsToWrite, uint32_t unitSizeInBytes, const uint8_t* data, uint32_t* actualNumOfUnitsWritten, uint8_t doSideEffectsIn));
    DECLARE_SIMTHREAD_METHOD(CADIMemRead, (eslapi::CADIAddrComplete_t startAddress, uint32_t unitsToRead, uint32_t unitSizeInBytes, uint8_t *data, uint32_t *actualNumOfUnitsRead, uint8_t doSideEffects));

    virtual eslapi::CADIReturn_t CADIExecSingleStep (uint32_t instructionCount, int8_t stepCycle, int8_t stepOver);
    virtual eslapi::CADIReturn_t CADIExecReset (uint32_t resetLevel);
    virtual eslapi::CADIReturn_t CADIExecContinue ();
    virtual eslapi::CADIReturn_t CADIExecStop ();
    virtual eslapi::CADIReturn_t CADIExecLoadApplication (const char *filename, bool loadData, bool verbose, const char *parameters); 
    virtual eslapi::CADIReturn_t CADIExecGetLoadedApplications (uint32_t startIndex, uint32_t desiredNumberOfApplications, 
                                                                uint32_t *actualNumberOfApplicatiosReturnedOut, 
                                                                char *filenamesOut, uint32_t filenameLength, char *parametersOut, 
                                                                uint32_t parametersLength);

    virtual eslapi::CADIReturn_t CADIBptGetList (uint32_t startIndex, uint32_t desiredNumOfBpts, uint32_t *actualNumOfBpts, eslapi::CADIBptDescription_t *breakpoints);
    virtual eslapi::CADIReturn_t CADIBptRead (eslapi::CADIBptNumber_t breakpointId, eslapi::CADIBptRequest_t *requestOut);
    virtual eslapi::CADIReturn_t CADIBptSet (eslapi::CADIBptRequest_t *request, eslapi::CADIBptNumber_t *breakpoint);
    virtual eslapi::CADIReturn_t CADIBptClear (eslapi::CADIBptNumber_t breakpointId);
    virtual eslapi::CADIReturn_t CADIBptConfigure (eslapi::CADIBptNumber_t breakpointId, eslapi::CADIBptConfigure_t configuration);

    virtual eslapi::CADIReturn_t CADIExecGetModes (uint32_t startModeIndex, uint32_t desiredNumOfModes, uint32_t *actualNumOfModes, eslapi::CADIExecMode_t *execModes);
    virtual eslapi::CADIReturn_t CADIExecGetResetLevels (uint32_t startResetLevelIndex, uint32_t desiredNumOfResetLevels, uint32_t * actualNumOfResetLevels, eslapi::CADIResetLevel_t * resetLevels);
    virtual eslapi::CADIReturn_t CADIExecSetMode (uint32_t /*execMode*/);
    virtual eslapi::CADIReturn_t CADIExecGetMode (uint32_t * execMode);
    virtual eslapi::CADIReturn_t CADIExecGetExceptions (uint32_t /*startExceptionIndex*/, uint32_t /*desiredNumOfExceptions*/, uint32_t * /*actualNumOfExceptions*/, eslapi::CADIException_t * /*exceptions*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    virtual eslapi::CADIReturn_t CADIExecAssertException (uint32_t /*exception*/, eslapi::CADIExceptionAction_t /*action*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    virtual eslapi::CADIReturn_t CADIExecGetPipeStages (uint32_t /*startPipeStageIndex*/, uint32_t /*desiredNumOfPipeStages*/, uint32_t * /*actualNumOfPipeStages*/, eslapi::CADIPipeStage_t * /*pipeStages*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
 
    virtual eslapi::CADIReturn_t CADIMemGetOverlays (
        uint32_t /*activeOverlayIndex*/,
        uint32_t /*desiredNumOfActiveOverlays*/, 
        uint32_t * /*actualNumOfActiveOverlays*/, 
        eslapi::CADIOverlayId_t * /*overlays*/) { return eslapi::CADI_STATUS_CmdNotSupported; }

    virtual eslapi::CADIReturn_t CADIGetCacheInfo(    uint32_t /*memSpaceID*/, 
                                            eslapi::CADICacheInfo_t* /*cacheInfo*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    virtual eslapi::CADIReturn_t CADICacheRead(    eslapi::CADIAddr_t /*addr*/,     // address including memspace-id
                                        uint32_t /*linesToRead*/, 
                                        uint8_t* /*data*/,            // lines * lineSize bytes
                                        uint8_t* /*tags*/,            // lines * tagbits/8 bytes
                                        bool* /*is_dirty*/,        // one per line
                                        bool* /*is_valid*/,        // one per line
                                        uint32_t* /*numLinesRead*/,
                                        bool /*doSideEffects*/) { return eslapi::CADI_STATUS_CmdNotSupported; }// read from underlying memory ?
    virtual eslapi::CADIReturn_t CADICacheWrite(eslapi::CADIAddr_t /*addr*/,         // address including memspace-id
                                        uint32_t /*linesToWrite*/, 
                                        const uint8_t* /*data*/,        // lines * lineSize bytes
                                        const uint8_t* /*tags*/,        // lines * tagbits/8 bytes
                                        const bool* /*is_dirty*/,    // one per line
                                        const bool* /*is_valid*/,    // one per line
                                        uint32_t* /*numLinesWritten*/,
                                        bool /*doSideEffects*/) { return eslapi::CADI_STATUS_CmdNotSupported; }    // write through ?
    
 
    virtual eslapi::CADIDisassembler* CADIGetDisassembler();
    virtual eslapi::CADIReturn_t CADIGetTargetInfo (eslapi::CADITargetInfo_t *targetInfo);
    virtual eslapi::CADIReturn_t CADIGetParameters(uint32_t, uint32_t, uint32_t*, eslapi::CADIParameterInfo_t*);
    virtual eslapi::CADIReturn_t CADIGetParameterInfo (const char *parameterName, eslapi::CADIParameterInfo_t *param); 
    virtual eslapi::CADIReturn_t CADIGetParameterValues (uint32_t parameterCount, uint32_t *actualNumOfParamsRead, 
                                                         eslapi::CADIParameterValue_t *paramValuesOut);

    virtual eslapi::CADIReturn_t CADISetParametersNoRefresh(uint32_t, eslapi::CADIParameterValue_t*, eslapi::CADIFactoryErrorMessage_t*);
    virtual eslapi::CADIReturn_t CADISetParameters(uint32_t, eslapi::CADIParameterValue_t*, eslapi::CADIFactoryErrorMessage_t*);
    virtual eslapi::CADIReturn_t CADIExecGetPipeStageFields(uint32_t, uint32_t, uint32_t*, eslapi::CADIPipeStageField_t*) { return eslapi::CADI_STATUS_CmdNotSupported; }
    
    virtual eslapi::CADIReturn_t CADIGetInstructionCount(uint64_t&);
    virtual eslapi::CADIReturn_t CADIGetCycleCount(uint64_t&, bool);
    virtual uint64_t CADIGetPC() { return 0; }
    virtual uint64_t CADIGetPC(bool*) { return 0; }
    virtual eslapi::CADIAddrComplete_t VirtualToPhysical(eslapi::CADIAddrComplete_t);
    virtual eslapi::CADIAddrComplete_t PhysicalToVirtual(eslapi::CADIAddrComplete_t) { eslapi::CADIAddrComplete_t r(0, eslapi::CADIAddr_t(eslapi::CADI_MEM_SPACE_NOTSUPPORTED, 0)); return r; }


    // profliing support
    virtual eslapi::CADIReturn_t CADIProfileSetup (eslapi::CADIProfileType_t /*type*/,
                                                   uint32_t /*regionCount*/,
                                                   eslapi::CADIProfileRegion_t * /*region*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    virtual eslapi::CADIReturn_t CADIProfileControl (eslapi::CADIProfileControl_t /*control*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    virtual eslapi::CADIReturn_t CADIProfileTraceControl (eslapi::CADITraceBufferControl_t /*bufferArg*/,
                                                          eslapi::CADITraceControl_t /*control*/,
                                                          eslapi::CADITraceOverlayControl_t /*overlay*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    virtual eslapi::CADIReturn_t CADIProfileGetExecution (eslapi::CADIProfileResultType_t * /*type*/,
                                                          uint32_t /*regIndex*/,
                                                          uint32_t /*regionSlots*/,
                                                          uint32_t * /*regionCount*/,
                                                          eslapi::CADIProfileResults_t * /*region*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    virtual eslapi::CADIReturn_t CADIProfileGetMemory (eslapi::CADIProfileResultType_t * /*type*/,
                                                       uint32_t /*regIndex*/,
                                                       uint32_t /*regionSlots*/,
                                                       uint32_t * /*regionCount*/,
        eslapi::CADIProfileResults_t * /*region*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    virtual eslapi::CADIReturn_t CADIProfileGetTrace (uint32_t /*blockIndex*/,
                                                      uint32_t /*blockSlots*/,
                                                      uint32_t * /*blockCount*/,
        eslapi::CADITraceBlock_t * /*block*/) { return eslapi::CADI_STATUS_CmdNotSupported; }

    //MxDI Profiling functions 

    /** READS number of read/write accesses for 'numberOfRegs'
        registers, starting with register index 'startReg'. After the
        call 'reg' will contain the results, 'actualNumberOfRegs'
        contains the number of registers the profiling data was
        actually read for. Note that 'reg' must point to an array of
        objects of type CADIResourceProfileResults_t with size
        'numberOfRegs' */
    virtual eslapi::CADIReturn_t CADIProfileGetRegAccesses(uint32_t startRegID, 
                                                           uint32_t numberOfRegs, 
                                                           eslapi::CADIRegProfileResults_t *reg_pres, 
                                                           uint32_t &actualNumberOfRegs);
      
    /** WRITES number of read/write accesses for 'numberOfRegs'
        registers according to values saved in 'reg', starting with
        register index 'startReg'. After the call 'actualNumberOfRegs'
        contains the number of updated registers. Note that 'reg' must
        point to an array of objects of type
        CADIResourceProfileResults_t with size 'numberOfRegs' */
    virtual eslapi::CADIReturn_t CADIProfileSetRegAccesses(uint32_t startRegID, 
                                                           uint32_t numberOfRegs, 
                                                           eslapi::CADIRegProfileResults_t *reg_pres, 
                                                           uint32_t &actualNumberOfRegs);

    /** READS number of read/write accesses for 'numberOfUnits' memory
        units, starting with memory unit at address
        'startAddress'. After the call 'mem' will contain the results,
        'actualNumberOfUnits' contains the number of memory units the
        profiling data was actually read for. Note that 'mem' must
        point to an array of objects of type
        CADIResourceProfileResults_t with size 'numberOfUnits'. */
    virtual eslapi::CADIReturn_t CADIProfileGetMemAccesses(    eslapi::CADIAddrComplete_t /*startAddress*/, 
                                                            uint32_t /*numberOfUnits*/, 
                                                            eslapi::CADIMemProfileResults_t * /*mem*/, 
                                                            uint32_t &/*actualNumberOfUnits*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    
    /** WRITES number of read/write accesses for 'numberOfUnits'
        memory units according to values saved in 'mem', starting with
        memory unit at address 'startAddress'. After the call
        'actualNumberOfUnits' contains the number of memory updated
        units. Note that 'mem' must point to an array of objects of
        type CADIResourceProfileResults_t with size
        'numberOfUnits'. */
    virtual eslapi::CADIReturn_t CADIProfileSetMemAccesses(    eslapi::CADIAddrComplete_t /*startAddress*/, 
                                                            uint32_t /*numberOfUnits*/, 
                                                            eslapi::CADIMemProfileResults_t * /*mem*/, 
                                                            uint32_t &/*actualNumberOfUnits*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
      
      
    /** READS the execution frequency for 'numberOfAddr' disassembly
        addresses, starting with address 'startAddr'. After the call
        'freq' contains the results, 'actualNumberOfAddr' contains the
        number of addresses the frequency was read for. Note that
        'freq' must point to an array of uint32_t with size
        'numberOfAddr'. */
    virtual eslapi::CADIReturn_t CADIProfileGetAddrExecutionFrequency( uint64_t /*startAddr*/, 
                                                                       uint32_t /*numberOfAddr*/, 
                                                                       uint64_t * /*freq*/, 
                                                                       uint32_t &/*actualNumberOfAddr*/) { return eslapi::CADI_STATUS_CmdNotSupported; }    
    
    
    /** WRITES the execution frequency for 'numberOfAddr' disassembly
        addresses according to values saved in 'freq', starting with
        address 'startAddr'. After the call 'actualNumberOfAddr'
        contains the number of updated addresses. Note that 'freq'
        must point to an array of uint32_t with size 'numberOfAddr'. */
    virtual eslapi::CADIReturn_t CADIProfileSetAddrExecutionFrequency( uint64_t /*startAddr*/, 
                                                                       uint32_t /*numberOfAddr*/, 
                                                                       uint64_t * /*freq*/, 
                                                                       uint32_t &/*actualNumberOfAddr*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    
    /// Returns number of instructions of the target.
    virtual eslapi::CADIReturn_t CADIGetNumberOfInstructions(uint32_t * /*num_instructions*/) { return eslapi::CADI_STATUS_CmdNotSupported; }


    /** This method prepares given array 'instructions' by setting
        'FID', 'name' and 'pathToInstructionInLISASource'. While
        'numberOfInstructions' defines the desired number of array
        entries to be prepared, 'actualNumberOfInstructions' contains
        the number of array entries actually prepared which might
        differ from 'numberOfInstructions'. */
    virtual eslapi::CADIReturn_t CADIProfileInitInstructionResultArray( uint32_t /*numberOfInstructions*/, 
                                                                        eslapi::CADIInstructionProfileResults_t * /*instructions*/,
                                                                        uint32_t &/*actualNumberOfInstructions*/) 
    { return eslapi::CADI_STATUS_CmdNotSupported; }
    
    
    /** READS the execution counts for 'numberOfInstructions'
        instructions by setting the appropriate 'executionCount' entry
        in array 'instructions'. After the call
        'actualNumberOfInstructions' contains the number of
        instructions the counts were read for. */
    virtual eslapi::CADIReturn_t CADIProfileGetInstructionExecutionFrequency( uint32_t    /*numberOfInstructions*/,
                                                                              eslapi::CADIInstructionProfileResults_t * /*instructions*/,
                                                                              uint32_t    &/*actualNumberOfInstructions*/) 
    { return eslapi::CADI_STATUS_CmdNotSupported; }
    
    
    /** WRITES the execution counts for 'numberOfInstructions'
        instructions according to values in 'instructions'. After the
        call 'actualNumberOfInstructions' contains the number of
        instructions the counts were read for. */
    virtual eslapi::CADIReturn_t CADIProfileSetInstructionExecutionFrequency( uint32_t    /*numberOfInstructions*/,
                                                                              eslapi::CADIInstructionProfileResults_t * /*instructions*/,
                                                                              uint32_t    &/*actualNumberOfInstructions*/) 
    { return eslapi::CADI_STATUS_CmdNotSupported; } 


    // Registers given resource access callback called if resource 'name' is accessed as specified by 'accessType'.  */
    virtual eslapi::CADIReturn_t CADIRegisterProfileResourceAccess(const char * name,
                                                                   eslapi::CADIProfileResourceAccessType_t accessType);

    
    // Unregisters the profile hazard callback.
    virtual eslapi::CADIReturn_t CADIUnregisterProfileResourceAccess(const char * name);
    
    
    // Registers the profile hazard callbacks.
    virtual eslapi::CADIReturn_t CADIProfileRegisterCallBack(eslapi::CADIProfilingCallbacks *callbackObject);

    
    // Unregisters given hazard callback.
    virtual eslapi::CADIReturn_t CADIProfileUnregisterCallBack(eslapi::CADIProfilingCallbacks *callbackObject);

    
    ///////////////////////////////
    // CADI 2.0 specific methods //
    ///////////////////////////////

    //Execution API
    
    eslapi::CADIReturn_t CADIExecUnloadApplication (const char * /*filename*/) { return eslapi::CADI_STATUS_CmdNotSupported; }
    eslapi::CADIReturn_t CADIGetCommitedPCs (int /*startIndex*/, int /*desiredCount*/, int * /*actualCount*/, uint64_t * /*pcs*/) 
    { return eslapi::CADI_STATUS_CmdNotSupported; }


    /// memory block type
    class MemoryBlock
    {
    public:
        MemoryBlock(const std::string &name,
                    const std::string &description,
                    uint16_t parentID,
                    eslapi::CADIAddrSimple_t startAddr,
                    eslapi::CADIAddrSimple_t length,
                    uint32_t cyclesToAccess,
                    eslapi::CADIMemReadWrite_t readWrite,
                    void *access_data,
                    MemoryWriteFunction_t access_write_func,
                    MemoryWriteFunctionOldStyle_t access_write_func_old_style,
                    MemoryReadFunction_t access_read_func,
                    MemoryReadFunctionOldStyle_t access_read_func_old_style,
                    uint32_t supportedMultiplesOfMAU[eslapi::CADI_MAU_MULTIPLES_LIST_SIZE],
                    uint8_t endianess,
                    uint8_t invariance);

        std::string name;
        std::string description;
//    uint16_t         id; // <-- implicit: blockIndex == blockID
        uint16_t         parentID; // why only 16 bit for ids anyway ?!?
        eslapi::CADIAddrSimple_t   startAddr;
        eslapi::CADIAddrSimple_t   length;
        uint32_t         cyclesToAccess;
        eslapi::CADIMemReadWrite_t readWrite;

        // additional info
        void             *access_data;
        MemoryWriteFunction_t access_write_func;
        MemoryWriteFunctionOldStyle_t access_write_func_old_style;
        MemoryReadFunction_t access_read_func;
        MemoryReadFunctionOldStyle_t access_read_func_old_style;
        VAtoPAFunction_t translate_va_to_pa_func;
// MxDI 6.0---------
        uint32_t supportedMultiplesOfMAU[eslapi::CADI_MAU_MULTIPLES_LIST_SIZE];
        uint8_t endianess;
        uint8_t invariance;
    };

    MemoryBlock* AddMemoryBlock(uint32_t memorySpaceId,
                        const std::string &name,
                        const std::string &description,
                        uint16_t parentID,
                        eslapi::CADIAddrSimple_t startAddr,
                        eslapi::CADIAddrSimple_t length,
                        uint32_t cyclesToAccess,
                        eslapi::CADIMemReadWrite_t readWrite,
                        uint32_t supportedMultiplesOfMAU[eslapi::CADI_MAU_MULTIPLES_LIST_SIZE],
                        void *access_data,
                        uint8_t endianess = 0,
                        uint8_t invariance = 0);

    /// memory space type
    class MemorySpace
    {
    public:
        MemorySpace(const std::string &name,
                    const std::string &description,
                    uint32_t id,
                    uint32_t bitsPerMau,
                    eslapi::CADIAddrSimple_t maxAddress,
                    char isProgramMemory,
                    uint8_t endianess,
                    uint8_t invariance,
                    int32_t isVirtualMemory,
                    uint32_t isCache);

        std::string name;
        std::string description;
        uint32_t   id; // <-- implicit: memoryIndex == id
        uint32_t   bitsPerMau;
        eslapi::CADIAddrSimple_t maxAddress;
        char     isProgramMemory;

        std::vector<MemoryBlock> memory_blocks;

        bool supportsNotifyRead;
        bool supportsNotifyWrite;
        uint8_t endianess;
        uint8_t invariance;
        int32_t isVirtualMemory;
        uint32_t isCache;
    };

    void AddMemorySpace(const std::string &name,
                        const std::string &description,
                        uint32_t id,
                        uint32_t bitsPerMau,
                        eslapi::CADIAddrSimple_t maxAddress,
                        char isProgramMemory,
                        uint8_t endianess,
                        uint8_t invariance,
                        int32_t isVirtualMemory = 0,
                        uint32_t isCache = 0);

    /// register
    void AddRegister(
        const char* name,                         // name of register as shown in register view
        const char* groups,                       // names of groups this register belongs to, separated by commas
        uint32_t registerId,                    // an id to identify your register
        uint32_t bitWidth,                        // size of the register/compound in bits
        eslapi::CADIRegDisplay_t displayFormat,        // how to display the data (hex, dec, etc.)
        const char* description,                  // description of the register shown in tooltip
        
        eslapi::CADIRegAccessAttribute_t attribute, // access rights (read/write/read & write etc.)
        RegReadFunctionOldStyle_t access_read_func_old_style = 0, // function used to read from register
        RegWriteFunctionOldStyle_t access_write_func_old_style = 0, // function used to write to register
        void * access_data = 0,             // data used to access as first argument of register read method. If 0 registerId is used instead
        
        bool hasSideEffects = false,        // register access has side effect
        bool isPipeStageField = false,      // MxDI 6.0: is pipe stage field, also true for pc and contentInfoRegisterId in eslapi::CADIPipeStage_t
        
        const char* fpFormat = 0,                 // floating point format 
        uint32_t numSymbols = 0,               // number of symbols in symbol list
        char** symbolList = 0,

        bool isPseudoReg = false,
        bool hasInstanceSpecificPointers = false,
        RegReadFunction_t access_read_func = 0,
        RegReadStringFunction_t access_read_string_func = 0,
        RegWriteFunction_t  access_write_func = 0,
        RegWriteStringFunction_t access_write_string_func = 0,
        uint32_t dwarfRegisterId = 0xFFFFFFFF,
        uint32_t pipeStageId = 0,
        uint32_t pipeStageOffset = 0,
        bool isContentInfoReg = false,
        bool supportsNotifyRead = false,
        bool supportsNotifyWrite = false
        );

    bool AddRegister(const RegInfo &regInfo, const RegInfoInstanceSpecific &regInfoInstSpec);

    // add a component register. returns true on success, else false
    bool AddRegisterField(
        const char* name,                         // name of register as shown in register view
        uint32_t registerId,                    // an id to identify your register
        uint32_t bitWidth,                        // size of the register/compound in bits
        eslapi::CADIRegDisplay_t displayFormat,        // how to display the data (hex, dec, etc.)
        const char* description,                  // description of the register shown in tooltip
        uint32_t lsbOffset,                    // offset to least significant bit of subfield/compound
        bool hasSideEffects = false,        // register access has side effect
        const char* fpFormat = 0,                 // floating point format 
        uint32_t numSymbols = 0,               // number of symbols in symbol list
        char** symbolList = 0
        );


protected:
    // This should be called by all CADI functions if a status
    // different from eslapi::CADI_STATUS_OK is returned. The message provided
    // can then be queried by the CADIXfaceGetError() method.
    void Error(const char *, ...) SG_FORMATSTR(printf, 2, 3);

    // helper function for CADIXfaceBypass(): check for a specific bypass command
    // returns true if command matches specificCommand
    // if param is != 0 then command is expected to be followed by a parameter string, *param is set to the beginning of this string
    bool IsBypassCommand(uint32_t commandLength, const char *command, const char *specificCommand, const char **param = 0);

public:
    // Print a warning, if possible using the doString callback
    void Warning(const char *, ...) SG_FORMATSTR(printf, 2, 3);

protected:
    eslapi::CADITargetFeatures_t features;

    /// memory space meta data
    std::vector<MemorySpace> memory_space_data;

    /// register access function to be overloaded 

    /// register read function for non string values
    virtual sg::accessfunc::AccessFuncResult RegisterRead(uint32_t id, uint64_t* data, bool hasSideEffects);

    /// register read function for string register
    virtual sg::accessfunc::AccessFuncResult RegisterReadString(uint32_t id, std::string &data, bool hasSideEffects);

    /// register write function for non string values
    virtual sg::accessfunc::AccessFuncResult RegisterWrite(uint32_t id, const uint64_t* data, bool hasSideEffects);

    /// register write function for string register
    virtual sg::accessfunc::AccessFuncResult RegisterWriteString(uint32_t id, const std::string &data, bool hasSideEffects);

private:    
    // member variables
    std::string componentName;

    std::map <std::string, eslapi::CADI*> importedCADI; 
    std::vector<RegInfo>         regMetaInfos;
    std::vector<RegInfoInternal> regMetaInfosInternal; // contains internal data not specified by the user

    std::vector <eslapi::CADIRegInfo_t> cadiRegInfos;

    std::map <std::string, eslapi::CADIRegGroup_t>  regGroups;
    std::vector <std::vector <uint32_t> >      groupID2registers;

    std::vector<std::string> resetLevelNames;
    std::vector<std::string> execModeNames;

    std::vector<ParamInfo>         paramMetaInfos;

    // group id info
    class IdInfo
    {
    public:
        IdInfo(const std::string &prefix_, uint32_t regId_, eslapi::CADI* cadi_, uint32_t numberOfRemainingElements_ = 0) : 
            prefix(prefix_), regId(regId_), cadi(cadi_), numberOfRemainingElements(numberOfRemainingElements_) {}
        std::string prefix;
        uint32_t regId;
        eslapi::CADI* cadi;
        uint32_t numberOfRemainingElements; // number of elements following and including this element
    };

    // Register group ID mapping
    std::vector<IdInfo> regGroupIdMapping;

    // register start index for given register group id 
    std::vector<uint32_t> regGroupId2startRegId;

    // Register ID mapping
    std::vector<IdInfo> regIdMapping;

    // Memory Space mapping
    std::map <uint32_t, IdInfo> memSpaceMap;
    
    /// If this is not -1 it contains the register number of the MxDI register containing the memory space the PC is in
    int PC_MEMSPACE_RegIndex;

    ///Current internal instruction step breakpoint ID, internally used for executing a single instruction step. Is set to -1 if there is no current inst step bpt, or to 0 to indicate instruction stepping with instruction counter.
    eslapi::CADIBptNumber_t currentInternalInstStepBptID;

    ///Last instruction count used for instruction stepping with instruction counter
    uint64_t instStepLastInstCount;
    
    /// last cycle where a breakpoint was hit ('avoid cycle stepping due to breakpoint' mechanism)
    uint64_t lastBreakpointHitCycle;

    /// last PC where a PROGRAM breakpoint was hit ('avoid cycle stepping due to breakpoint' mechanism)
    uint64_t lastBreakpointHitPC;

private:    
    // this is set to true if the interface has been constructed by calling construct() 
    bool constructed; 

    // send MxDI commands from the debugger to the simulation engine (debugger thread) and receive MxDI callbacks from the simulation engine (simulation thread)
    CADIExecutionControlProtocolSystemGenerator cadiExecPort;
    // send commands from the simulator (and simulation thread) to the simulation engine    
    SimExecutionControlProtocolSystemGen simExecPort;
    // forward CADI calls directly to a generated component (or something else having a CADI protocol) (connecting this is optional)
    CADIProtocol cadiPort;

    // forward certain CADI calls to user CADI implementation if present
    UserCADIImplementationProtocol userCadiPort;

    CallbackObj callbackObj;

    /// find root block which contains address
    uint32_t findRootBlock(const eslapi::CADIAddr_t& location);
    
    // true: import status information of subcomponents 
    bool importSubcomponentCADI;
    bool subcomponentCADIImported;

    // mapping from reister id to indices
    std::map<uint32_t, std::vector<uint32_t> > registerId2registerIdx; 

    // mapping from memory space id to index
    std::map<uint32_t, uint32_t> memSpaceId2memSpaceIdx; 

    // mapping from parameter id to index
    std::map<uint32_t, uint32_t> paramId2paramIdx; 

public:
    // generic (default) register and memory access functions for CADI
 
    // write register
    eslapi::CADIReturn_t register_access_write_func_1bit(void *access_data, const uint8_t *data, bool)
    { *(reinterpret_cast<uint8_t*>(access_data)) = data[0] != 0; return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t register_access_write_func_8bit(void *access_data, const uint8_t *data, bool)
    { *(reinterpret_cast<uint8_t*>(access_data)) = data[0]; return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t register_access_write_func_16bit(void *access_data, const uint8_t *data, bool)
    { uint16_t tmp = ((uint16_t(data[1])) << 8) | (uint16_t(data[0]));
      *(reinterpret_cast<uint16_t*>(access_data)) = tmp; return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t register_access_write_func_32bit(void *access_data, const uint8_t *data, bool)
    { uint32_t tmp = ((uint32_t(data[3])) << 24) | ((uint32_t(data[2])) << 16) | ((uint32_t(data[1])) << 8) | (uint32_t(data[0]));
      *(reinterpret_cast<uint32_t*>(access_data)) = tmp; return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t register_access_write_func_64bit(void *access_data, const uint8_t *data, bool)
    { uint64_t tmp = ((uint64_t(data[7])) << 56) | ((uint64_t(data[6])) << 48) | ((uint64_t(data[5])) << 40) | ((uint64_t(data[4])) << 32)
        | ((uint64_t(data[3])) << 24) | ((uint64_t(data[2])) << 16) | ((uint64_t(data[1])) << 8) | (uint64_t(data[0]));
      *(reinterpret_cast<uint64_t*>(access_data)) = tmp; return eslapi::CADI_STATUS_OK; }

    // read register
    eslapi::CADIReturn_t register_access_read_func_1bit(void *access_data, uint8_t *data, bool)
    { data[0] = (*(reinterpret_cast<uint8_t*>(access_data))) != 0; return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t register_access_read_func_8bit(void *access_data, uint8_t *data, bool)
    { data[0] = *(reinterpret_cast<uint8_t*>(access_data)); return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t register_access_read_func_16bit(void *access_data, uint8_t *data, bool)
    {
        uint16_t w = *(reinterpret_cast<uint16_t*>(access_data));
        data[0] = w & 255;
        data[1] = (w>> 8) & 255;
        return eslapi::CADI_STATUS_OK; 
    }
    eslapi::CADIReturn_t register_access_read_func_32bit(void *access_data, uint8_t *data, bool)
    {
        uint32_t w = *(reinterpret_cast<uint32_t*>(access_data));
        data[0] = uint8_t(w);
        data[1] = uint8_t(w>> 8);
        data[2] = uint8_t(w>>16);
        data[3] = uint8_t(w>>24);
        return eslapi::CADI_STATUS_OK; 
    }
    eslapi::CADIReturn_t register_access_read_func_64bit(void *access_data, uint8_t *data, bool)
    {
        uint64_t w = *(reinterpret_cast<uint64_t*>(access_data));
        data[0] = uint8_t(w);
        data[1] = uint8_t(w >>  8);
        data[2] = uint8_t(w >> 16);
        data[3] = uint8_t(w >> 24);
        data[4] = uint8_t(w >> 32);
        data[5] = uint8_t(w >> 40);
        data[6] = uint8_t(w >> 48);
        data[7] = uint8_t(w >> 56);
        return eslapi::CADI_STATUS_OK; 
    }

    // write memory
    eslapi::CADIReturn_t memory_access_write_func_8bit(void *access_data, uint32_t offset, eslapi::CADIAddrSimple_t /* baseaddress */, const uint8_t *data, uint32_t /* mauSizeInBytes */, bool)
    { reinterpret_cast<uint8_t*>(access_data)[offset] = *data; return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t memory_access_write_func_16bit(void *access_data, uint32_t offset, eslapi::CADIAddrSimple_t /* baseaddress */, const uint8_t *data, uint32_t /* mauSizeInBytes */, bool)
    { reinterpret_cast<uint16_t*>(access_data)[offset] = *(reinterpret_cast<const uint16_t*>(data)); return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t memory_access_write_func_32bit(void *access_data, uint32_t offset, eslapi::CADIAddrSimple_t /* baseaddress */, const uint8_t *data, uint32_t /* mauSizeInBytes */, bool)
    { reinterpret_cast<uint32_t*>(access_data)[offset] = *(reinterpret_cast<const uint32_t*>(data)); return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t memory_access_write_func_64bit(void *access_data, uint32_t offset, eslapi::CADIAddrSimple_t /* baseaddress */, const uint8_t *data, uint32_t /* mauSizeInBytes */, bool)
    { reinterpret_cast<uint64_t*>(access_data)[offset] = *(reinterpret_cast<const uint64_t*>(data)); return eslapi::CADI_STATUS_OK; }

        // read memory
    eslapi::CADIReturn_t memory_access_read_func_8bit(void *access_data, uint32_t offset, eslapi::CADIAddrSimple_t /* baseaddress */, uint8_t *data, uint32_t /* mauSizeInBytes */, bool)
    { *data = reinterpret_cast<const uint8_t*>(access_data)[offset]; return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t memory_access_read_func_16bit(void *access_data, uint32_t offset, eslapi::CADIAddrSimple_t /* baseaddress */, uint8_t *data, uint32_t /* mauSizeInBytes */, bool)
    { *(reinterpret_cast<uint16_t*>(data)) = reinterpret_cast<const uint16_t*>(access_data)[offset]; return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t memory_access_read_func_32bit(void *access_data, uint32_t offset, eslapi::CADIAddrSimple_t /* baseaddress */, uint8_t *data, uint32_t /* mauSizeInBytes */, bool)
    { *(reinterpret_cast<uint32_t*>(data)) = reinterpret_cast<const uint32_t*>(access_data)[offset]; return eslapi::CADI_STATUS_OK; }
    eslapi::CADIReturn_t memory_access_read_func_64bit(void *access_data, uint32_t offset, eslapi::CADIAddrSimple_t /* baseaddress */, uint8_t *data, uint32_t /* mauSizeInBytes */, bool)
    { *(reinterpret_cast<uint64_t*>(data)) = reinterpret_cast<const uint64_t*>(access_data)[offset]; return eslapi::CADI_STATUS_OK; }

public:
    // get a callback interface that can be used to interact with debuggers
    eslapi::CADICallbackObj* getCallbackIf() { return &callbackObj; }
    uint32_t GetNumberOfAddedCallbacks() const { return callbackObj.GetNumberOfAddedCallbacks();}

public: // methods

    // return true if we should proxy CADI calls to sim thread
    bool doCADIproxy();

    CADIExecutionControlProtocolSystemGenerator* getCadiExecPort() {return &cadiExecPort;}

protected: // types
    class Breakpoint
    {
    public: // methods
        Breakpoint(const eslapi::CADIBptRequest_t &request, 
                   eslapi::CADIBptNumber_t id) :
            access_unit_size(0),
            value_bitwidth(0),
            ignored_hits(0),
            old_value(0)
        {
            desc.bptNumber = id;
            desc.bptInfo = request;
        }
    public: // data
        eslapi::CADIBptDescription_t desc;
        unsigned int access_unit_size; // in bytes, for MEM and REG BPTs
        unsigned int value_bitwidth; // in bits, for MEM and REG BPTs
        uint32_t ignored_hits;
        uint64_t old_value;

        template<typename ValueT>
        bool FormalBreakpointConditionIsMet(ValueT value)
        {
            bool cond = true;

            if (desc.bptInfo.formalCondition.conditionOperator != eslapi::CADI_BPT_COND_UNCONDITIONAL)
            {
                switch (desc.bptInfo.formalCondition.conditionOperator)
                {
                default:
                        break;

                case eslapi::CADI_BPT_COND_EQUALS:
                    if (value != desc.bptInfo.formalCondition.comparisonValue) cond = false;
                    break;

                case eslapi::CADI_BPT_COND_NOT_EQUALS:
                    if (value == desc.bptInfo.formalCondition.comparisonValue) cond = false;
                    break;

                case eslapi::CADI_BPT_COND_GREATER_THAN:
                    if (value <= desc.bptInfo.formalCondition.comparisonValue) cond = false;
                    break;

                case eslapi::CADI_BPT_COND_GREATER_THAN_OR_EQUALS:
                    if (value < desc.bptInfo.formalCondition.comparisonValue) cond = false;
                    break;

                case eslapi::CADI_BPT_COND_LESS_THAN:
                    if (value >= desc.bptInfo.formalCondition.comparisonValue) cond = false;
                    break;

                case eslapi::CADI_BPT_COND_LESS_THAN_OR_EQUALS:
                    if (value > desc.bptInfo.formalCondition.comparisonValue) cond = false;
                }
            }

            return (CheckIgnoreCount() && cond);
        }

        // Returns 'false' if there is an ignore count larger than 0. Decrease
        // it in that case. Returns 'true' if there is no ignore count and the
        // breakpoint should trigger.
        bool CheckIgnoreCount()
        {
            if (desc.bptInfo.formalCondition.ignoreCount && (ignored_hits < desc.bptInfo.formalCondition.ignoreCount))
            {
                ++ignored_hits;
                return false;
            }
            return true;
        }

        // check value
        uint64_t GetCurrentValue(CADIBase *cadi)
        {
            uint64_t cur_value = 0;
            uint32_t num_read = 0;
            uint8_t *buf;

            switch (desc.bptInfo.type)
            {
                case eslapi::CADI_BPT_REGISTER:
                    {
                        eslapi::CADIReg_t reg;
                        memset(&reg, 0, sizeof(reg));
                        reg.regNumber = desc.bptInfo.regNumber;
                        if (cadi->CADIRegRead(1, &reg, &num_read, false) != eslapi::CADI_STATUS_OK)
                        {
                            cadi->Error("Breakpoint::GetCurrentValue: Could not read register value");
                            return 0;
                        }
                        buf = reg.bytes;
                    }
                    break;

                case eslapi::CADI_BPT_MEMORY:
                    {
                        uint8_t tmp_buf[64] = { 0 };
                        if (cadi->CADIMemRead(desc.bptInfo.address, 1, access_unit_size, tmp_buf, &num_read, false) != eslapi::CADI_STATUS_OK)
                        {
                            cadi->Error("Breakpoint::GetCurrentValue: Could not read memory value");
                            return 0;
                        }
                        buf = tmp_buf;
                    }
                    break;

                default:
                    return 0;
            }

#ifdef sun
            // big endian
            cur_value = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24) | 
                (uint64_t(buf[4]) << 32) | (uint64_t(buf[5]) << 40) | (uint64_t(buf[6]) << 48) | (uint64_t(buf[7]) << 56);
#else
            // little endian
            cur_value = *reinterpret_cast<uint64_t*>(buf);
#endif
            return cur_value;
        }

        bool CheckValue64(int64_t value)
        {
            switch (desc.bptInfo.formalCondition.conditionOperator)
            {
            default:
            case eslapi::CADI_BPT_COND_UNCONDITIONAL:
                return true;
                
            case eslapi::CADI_BPT_COND_EQUALS:
                return value == desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_NOT_EQUALS:
                return value != desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_GREATER_THAN:
                return value > desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_GREATER_THAN_OR_EQUALS:
                return value >= desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_LESS_THAN:
                return value < desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_LESS_THAN_OR_EQUALS:
                return value <= desc.bptInfo.formalCondition.comparisonValue;
            }
        }
        bool CheckValue32(int32_t value)
        {
            switch (desc.bptInfo.formalCondition.conditionOperator)
            {
            default:
            case eslapi::CADI_BPT_COND_UNCONDITIONAL:
                return true;
                
            case eslapi::CADI_BPT_COND_EQUALS:
                return value == desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_NOT_EQUALS:
                return value != desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_GREATER_THAN:
                return value > desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_GREATER_THAN_OR_EQUALS:
                return value >= desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_LESS_THAN:
                return value < desc.bptInfo.formalCondition.comparisonValue;
                
            case eslapi::CADI_BPT_COND_LESS_THAN_OR_EQUALS:
                return value <= desc.bptInfo.formalCondition.comparisonValue;
            }
        }
    };

    Breakpoint *FindBreakpoint(eslapi::CADIBptNumber_t breakpoint_id);

    RegInfo *FindRegister(uint32_t regId)
    {
        std::map<uint32_t, std::vector<uint32_t> >::iterator i = registerId2registerIdx.find(regId);
        if (i == registerId2registerIdx.end())
            return 0;
        return &regMetaInfos[i->second[0]];
    }

    MemorySpace *FindMemorySpace(uint32_t memSpaceId)
    {
        std::map<uint32_t, uint32_t>::iterator i = memSpaceId2memSpaceIdx.find(memSpaceId);
        if ((i == memSpaceId2memSpaceIdx.end()) || (i->second >= memory_space_data.size()))
            return 0;
        return &memory_space_data[i->second];
    }

    const std::vector<RegInfo>& GetRegisterData() const { return regMetaInfos; }

private: // methods
    unsigned int GetNumberOfBreakpoints() const;
    void UpdateEmptyFlagsForBreakpoints();

    // Use template functions to avoid separate implementations for 32/64 bit value and address types:
     
    template<typename AddrT> // uint32_t/uint64_t
    bool CheckBptPC(AddrT pc); 

    template<typename AddrT> // uint32_t/uint64_t
    bool CheckBptPC(AddrT pc, uint32_t pc_memory_space_id);

    template<typename ValueT> // int32_t/int64_t
    bool CheckBptRegisterRead(uint32_t reg_id, ValueT value);
    template<typename ValueT> // int32_t/int64_t
    bool CheckBptRegisterWrite(uint32_t reg_id, ValueT value);

    template<typename AddrT, typename ValueT>
    bool CheckBptMemoryRead(uint32_t mem_space_id, AddrT address, ValueT value);
    template<typename AddrT, typename ValueT>
    bool CheckBptMemoryWrite(uint32_t mem_space_id, AddrT address, ValueT value);

    template<typename AddrT, typename ValueT>
    bool CheckBptMemoryRead(uint32_t mem_space_id, AddrT address, uint32_t size, ValueT value);
    template<typename AddrT, typename ValueT>
    bool CheckBptMemoryWrite(uint32_t mem_space_id, AddrT address, uint32_t size, ValueT value);

    bool CheckBptModify(std::vector<Breakpoint>&);

    void RemoveInternalInstStepBpt();

    void CheckInstStepInstCount();

    // This locks the simulation state. NOTE that this stops the simulation if running!! 
    CADIExecutionControlProtocolSystemGenerator::SimStateLock AcquireSimStateLock();

    // converts eslapi::CADIReturn_t to AccessFuncResult
    eslapi::CADIReturn_t AccessFuncResultToCadiStatus(sg::accessfunc::AccessFuncResult res);

protected: // data
    enum
    {
        CODE_BREAKPOINTS, // PROGRAM, PROGRAM_RANGE and INST breakpoints
        REG_BREAKPOINTS,
        MEM_BREAKPOINTS,
        NUM_BREAKPOINT_VECS
    };

    // separate breakpoint vectors for program, register and memory breakpoints
    std::vector<Breakpoint> breakpoints[NUM_BREAKPOINT_VECS];
    uint32_t nonempty_flags; // has bit 'n' set if breakpoint list 'n' contains enabled breakpoints
    uint32_t nonempty_modify_flags;
    eslapi::CADIBptNumber_t current_bpt_id; // the id of the last breakpoint which was added

    std::string last_error_msg;
    uint32_t currentRegisterOffset128;
    int cadiRefreshReentranceGuard; // to protect endlees loops when calling cadiRefresh() behavior, e.g. in from regRead behavior
    
    // synchronous CADI interface
    SCADI *scadi;
};


// helpers to compensate for the strange CADI memory access functions which 
// transport one byte in each 64 bit value 
// (since the MAU (minimal addressable unit) is 1 byte for ARM)
void ExpandArrayU8toU64(uint64_t *data64, int numElements);

class CompressArrayU64toU8
{
public:
    CompressArrayU64toU8(const uint64_t *data64, int numElements):
    mem8(0), buf8(0)
    {
        if (numElements > 8)
            mem8 = data8 = new uint8_t[numElements];
        else
            data8 = (uint8_t*)&buf8;
        for (int i = 0; i < numElements; i++)
            data8[i] = (uint8_t)(data64[i]);
    }
    
    const uint8_t *getData() const { return data8; }
    
    ~CompressArrayU64toU8()
    {
        delete[] mem8;
    }
private:
    uint8_t *data8;
    uint8_t *mem8;
    uint64_t buf8;
};


} // namespace sg
    
#endif   // __SG_CADIBase_h__


