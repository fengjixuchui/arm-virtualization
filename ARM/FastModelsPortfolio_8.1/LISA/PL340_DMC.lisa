/*!
 * \file  PL340_DMC.lisa
 * \brief LISA Implementation of the PL340 DMC.
 * \date Copyright 2007-2008 ARM Limited. All rights reserved.
 */

component PL340_DMC 
{
    properties {
        version = "8.1.37";
        component_type = "Peripheral";
        description = "ARM PrimeCell Dynamic Memory Controller(PL340)";
        documentation_file = "../Docs/DUI0423O_fast_model_rm.pdf";
    }

    includes 
    {

        //defines that are used to enable or disable the traces/warnings

//        #define PL340_TRACE(x) cout << "PL340_DMC : ";x // enable this for adding traces
        #define PL340_TRACE(x)                            // enable this for removing traces

        // use this for generating warnings
//        #define PL340_WARN(x) {cout << "PL340_WARN : ";x;} // use this for PL340 warnings.
        #define PL340_WARN(x)

        enum PL340_SIZES {
            PL340_DMC_APB_SPACE_SIZE = 0x1000  // The APB interface had 4kb of space
        };

        enum PL340_DMC_MEMORY_TYPES {
            PL340_DRAM  = 0x0,
            PL340_NOT_CONNECTED = 0xFFFFFFFF
        };

        enum PL340_DMC_MEMC_STATES {             //the states of the memory controller
            PL340_CONFIG   = 0,
            PL340_READY    = 1,
            PL340_PAUSED   = 2,
            PL340_LOWPOWER = 3
        };

        enum PL340_REG_OFFSET {
            PL340_MEMC_STATUS    = 0x000,              //RO -a Memory Controller Status Register 
            PL340_MEMC_CMD       = 0x004,              //WO - Memory Controller Command Register
            PL340_DIRECT_CMD     = 0x008,              //WO - Direct Command Register
            PL340_MEMORY_CFG     = 0x00C,              //RW 0x00010020 Memory Configuration Register
            PL340_REFRESH_PRD    = 0x010,              //RW 0x00000A60 Refresh Period Register on page 3-11
            PL340_CAS_LATENCY    = 0x014,              //RW 0x00000006 CAS Latency Register
            PL340_T_DQSS         = 0x018,              //RW 0x00000001 t_dqss Register
            PL340_T_MRD          = 0x01C,              //RW 0x00000002 t_mrd Register
            PL340_T_RAS          = 0x020,              //RW 0x00000007 t_ras Register
            PL340_T_RC           = 0x024,              //RW 0x0000000B t_rc Register
            PL340_T_RCD          = 0x028,              //RW 0x0000001D t_rcd Register
            PL340_T_RFC          = 0x02C,              //RW 0x00000212 t_rfc Register
            PL340_T_RP           = 0x030,              //RW 0x0000001D t_rp Register
            PL340_T_RRD          = 0x034,              //RW 0x00000002 t_rrd Register
            PL340_T_WR           = 0x038,              //RW 0x00000003 t_wr Register
            PL340_T_WTR          = 0x03C,              //RW 0x00000002 t_wtr Register
            PL340_T_XP           = 0x040,              //RW 0x00000001 t_xp Register
            PL340_T_XSR          = 0x044,              //RW 0x0000000A t_xsr Register
            PL340_T_ESR          = 0x048,              //RW 0x00000014 t_esr Register

            PL340_ID_00_CFG       = 0x100,
            PL340_ID_01_CFG       = 0x104,
            PL340_ID_02_CFG       = 0x108,
            PL340_ID_03_CFG       = 0x10C,
            PL340_ID_04_CFG       = 0x110,
            PL340_ID_05_CFG       = 0x114,
            PL340_ID_06_CFG       = 0x118,
            PL340_ID_07_CFG       = 0x11C,
            PL340_ID_08_CFG       = 0x120,
            PL340_ID_09_CFG       = 0x124,
            PL340_ID_10_CFG       = 0x128,
            PL340_ID_11_CFG       = 0x12C,
            PL340_ID_12_CFG       = 0x130,
            PL340_ID_13_CFG       = 0x134,
            PL340_ID_14_CFG       = 0x138,
            PL340_ID_15_CFG       = 0x13C,

            PL340_CHIP_0_CFG      = 0x200,              //RW 0x0000FF00 
            PL340_CHIP_1_CFG      = 0x204,              //RW 0x0000FF00 
            PL340_CHIP_2_CFG      = 0x208,              //RW 0x0000FF00 
            PL340_CHIP_3_CFG      = 0x20C,              //RW 0x0000FF00 

            PL340_USER_STATUS     = 0x300,              //RO - user_status Register
            PL340_USER_CONFIG     = 0x304,              //WO - user_config Register

            PL340_PERIPH_ID_0     = 0xFE0,
            PL340_PERIPH_ID_1     = 0xFE4,
            PL340_PERIPH_ID_2     = 0xFE8,
            PL340_PERIPH_ID_3     = 0xFEC,


            PL340_PCELL_ID_0      = 0xFF0,
            PL340_PCELL_ID_1      = 0xFF4,
            PL340_PCELL_ID_2      = 0xFF8,
            PL340_PCELL_ID_3      = 0xFFC 
        };

    }


    slave  port<PVBus> axi_if_in[4] ;             // receive the axi reads/writes here; up to four chips can be connected
    slave  port<PVBus> apb_interface;             // receive the apb config read/writes here

    master port<PVBus> axi_if_out[4];             // the output ports where the actual mem chips are connected.


    composition 
    {
        apb_slave : PVBusSlave(size = 0x1000);
    }

    connection
    {
        self.axi_if_in[0]    =>    self.axi_if_out[0];      // connect the incoming devices to the out going devices
        self.axi_if_in[1]    =>    self.axi_if_out[1];      
        self.axi_if_in[2]    =>    self.axi_if_out[2];
        self.axi_if_in[3]    =>    self.axi_if_out[3];

        self.apb_interface   =>    apb_slave.pvbus_s;     // connect the external slave interface to the PVBusSlave's slave port
        apb_slave.device     =>    self.register_model;   // connect the PVBusSlave's device port to PL340's device port, so that we can model the regs
    }

    internal slave port<PVDevice> register_model
    {
        behavior read(pv::ReadTransaction tx) : pv::Tx_Result
        {
            uint32_t data = 0x0;
            PL340_TRACE(cout << "Read called \n");
            if (tx.getAccessWidth() != pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
            do_reg_read(tx.getAddress(), tx.getAccessByteWidth(), &data);
            return tx.setReturnData32(data);
        }


        behavior write(pv::WriteTransaction tx) : pv::Tx_Result
        {
            uint32_t data = tx.getData32();
            PL340_TRACE(cout << "Write called \n");
            if (tx.getAccessWidth() != pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
            do_reg_write(tx.getAddress(), tx.getAccessByteWidth(), &data);
            return tx.writeComplete();
        }

        behavior debugRead(pv::ReadTransaction tx) : pv::Tx_Result
        {
            return register_model.read(tx);
        }

        behavior debugWrite(pv::WriteTransaction tx) : pv::Tx_Result
        {
            return register_model.write(tx);
        }        
    }

    behavior do_reg_read(pv::bus_addr_t address, int width, uint32_t *data)
    {
        uint32_t offset = address & 0xfff;

        switch(offset)
        {
            case PL340_MEMC_STATUS:
                *data = memc_status;
                break;  

            case PL340_MEMC_CMD:
                PL340_WARN( cout << "we do not expect a read on this register \n");
                break;     

            case PL340_DIRECT_CMD:
                PL340_WARN( cout << "we do not expect a read on this register \n");
                break;   
                
            case PL340_MEMORY_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = memory_cfg;
                else PL340_WARN(cout << "can read MEMORY_CFG register in config or low power state only\n");
                break;   

            case PL340_REFRESH_PRD:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = refresh_prd;
                else PL340_WARN(cout << " can read REFRESH_PRD register in config or low power state only\n");
                break;  

            case PL340_CAS_LATENCY:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = cas_latency;
                else PL340_WARN(cout << " can read CAS_LATENCY register in config or low power state only\n");
                break;  

            case PL340_T_DQSS:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_dqss;
                else PL340_WARN(cout << " can read T_DQSS register in config or low power state only\n");
                break;       

            case PL340_T_MRD:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_mrd;
                else PL340_WARN(cout << " can read T_MRD register in config or low power state only\n");
                break;        

            case PL340_T_RAS:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_ras;
                else PL340_WARN(cout << " can read T_RAS register in config or low power state only\n");
                break;        
                
            case PL340_T_RC:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_ras;
                else PL340_WARN(cout << " can read T_RAS register in config or low power state only\n");
                break;         

            case PL340_T_RCD:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_rcd;
                else PL340_WARN(cout << " can read T_RCD register in config or low power state only\n");
                break;        

            case PL340_T_RFC:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_rfc;
                else PL340_WARN(cout << " can read T_RFC register in config or low power state only\n");
                break;        

            case PL340_T_RP:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_rp;
                else PL340_WARN(cout << " can read T_RP register in config or low power state only\n");
                break;         
            
            case PL340_T_RRD:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_rrd;
                else PL340_WARN(cout << " can read T_RRD register in config or low power state only\n");
                break;        
            
            case PL340_T_WR:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_wr;
                else PL340_WARN(cout << " can read T_WR register in config or low power state only\n");
                break;         
            
            case PL340_T_WTR:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_wtr;
                else PL340_WARN(cout << " can read T_WTR register in config or low power state only\n");
                break;        
            
            case PL340_T_XP:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_xp;
                else PL340_WARN(cout << " can read T_XP register in config or low power state only\n");
                break;         
            
            case PL340_T_XSR:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_xsr;
                else PL340_WARN(cout << " can read T_XSR register in config or low power state only\n");
                break;        
            
            case PL340_T_ESR:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = t_esr;
                else PL340_WARN(cout << " can read T_ESR register in config or low power state only\n");
                break;        

            case PL340_ID_00_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_00_cfg;
                else PL340_WARN(cout << " can read ID_00_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_01_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_01_cfg;
                else PL340_WARN(cout << " can read ID_01_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_02_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_02_cfg;
                else PL340_WARN(cout << " can read ID_02_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_03_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_03_cfg;
                else PL340_WARN(cout << " can read ID_03_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_04_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_04_cfg;
                else PL340_WARN(cout << " can read ID_04_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_05_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_05_cfg;
                else PL340_WARN(cout << " can read ID_05_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_06_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_06_cfg;
                else PL340_WARN(cout << " can read ID_06_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_07_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_07_cfg;
                else PL340_WARN(cout << " can read ID_07_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_08_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_08_cfg;
                else PL340_WARN(cout << " can read ID_08_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_09_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_09_cfg;
                else PL340_WARN(cout << " can read ID_09_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_10_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_10_cfg;
                else PL340_WARN(cout << " can read ID_10_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_11_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_11_cfg;
                else PL340_WARN(cout << " can read ID_11_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_12_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_12_cfg;
                else PL340_WARN(cout << " can read ID_12_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_13_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_13_cfg;
                else PL340_WARN(cout << " can read ID_13_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_14_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_14_cfg;
                else PL340_WARN(cout << " can read ID_14_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_15_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = id_15_cfg;
                else PL340_WARN(cout << " can read ID_15_CFG register in config or low power state only\n");
                break;    

            case PL340_CHIP_0_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = chip_0_cfg;
                else PL340_WARN(cout << " can read CHIP_0_CFG register in config or low power state only\n");
                break;   
            case PL340_CHIP_1_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = chip_1_cfg;
                else PL340_WARN(cout << " can read CHIP_1_CFG register in config or low power state only\n");
                break;   
            case PL340_CHIP_2_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = chip_2_cfg;
                else PL340_WARN(cout << " can read CHIP_2_CFG register in config or low power state only\n");
                break;   
            case PL340_CHIP_3_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) *data = chip_3_cfg;
                else PL340_WARN(cout << " can read CHIP_3_CFG register in config or low power state only\n");
                break;   

            case PL340_USER_STATUS:
                *data = user_status & 0xff;
                break;  

            case PL340_USER_CONFIG:
                *data = user_config & 0xff;
                break;  

            case PL340_PERIPH_ID_0:
                *data = periph_id_0;
                break;  
                
            case PL340_PERIPH_ID_1:
                *data = periph_id_1;
                break;  
                
            case PL340_PERIPH_ID_2:
                *data = periph_id_2;
                break;  

            case PL340_PERIPH_ID_3:
                *data = periph_id_3;
                break;  


            case PL340_PCELL_ID_0:
                *data = pcell_id_0;
                break;   
                
            case PL340_PCELL_ID_1:
                *data = pcell_id_1;
                break;   
                
            case PL340_PCELL_ID_2:
                *data = pcell_id_2;
                break;   

            case PL340_PCELL_ID_3:
                *data = pcell_id_3;
                break;   
            default :
                PL340_WARN(cout << " Read of unknown register called.. \n");
                *data = 0x0;
                break;
        }
    }

    behavior do_reg_write(pv::bus_addr_t address, int width, uint32_t *data)
    {
        uint32_t offset = address & 0xfff;
        switch(offset)
        {
            case PL340_MEMC_STATUS:
                PL340_WARN(cout << "We do not expect a write on this register \n");
                break;  
                
            case PL340_MEMC_CMD:
                transition_mc_fsm(*data & 0x7);
                break;     

            case PL340_DIRECT_CMD:
                direct_cmd = *data & 0x003FFFFF;
                break;   
                
            case PL340_MEMORY_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) memory_cfg = *data & 0x003FFFFF;
                else PL340_WARN(cout << " can write to MEMORY_CFG register in config or low power state only\n");
                break;   

            case PL340_REFRESH_PRD:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) refresh_prd = *data & 0x0000FFFF;
                else PL340_WARN(cout << " can write to REFRESH_PRD register in config or low power state only\n");
                break;  

            case PL340_CAS_LATENCY:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) cas_latency = *data & 0x0000000F;
                else PL340_WARN(cout << " can write to CAS_LATENCY register in config or low power state only\n");
                break;  

            case PL340_T_DQSS:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_dqss = *data & 0x00000003;
                else PL340_WARN(cout << " can write to T_DQSS register in config or low power state only\n");
                break;       

            case PL340_T_MRD:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_mrd = *data & 0x0000007F;
                else PL340_WARN(cout << " can write to T_MRD register in config or low power state only\n");
                break;        

            case PL340_T_RAS:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_ras = *data & 0x0000000F;
                else PL340_WARN(cout << " can write to T_RAS register in config or low power state only\n");
                break;        

            case PL340_T_RC:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_rc = *data & 0x0000000F;
                else PL340_WARN(cout << " can write to T_RC register in config or low power state only\n");
                break;         

            case PL340_T_RCD:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_rcd = *data & 0x0000003F;
                else PL340_WARN(cout << " can write to T_RCD register in config or low power state only\n");
                break;        

            case PL340_T_RFC:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_rfc = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to T_RFC register in config or low power state only\n");
                break;        

            case PL340_T_RP:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_rp = *data & 0x0000003F;
                else PL340_WARN(cout << " can write to T_RP register in config or low power state only\n");
                break;         

            case PL340_T_RRD:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_rrd = *data & 0x0000000F;
                else PL340_WARN(cout << " can write to T_RRD register in config or low power state only\n");
                break;        

            case PL340_T_WR:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_wr = *data & 0x00000003;
                else PL340_WARN(cout << " can write to T_WR register in config or low power state only\n");
                break;         

            case PL340_T_WTR:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_wtr = *data & 0x00000003;
                else PL340_WARN(cout << " can write to T_WTR register in config or low power state only\n");
                break;        

            case PL340_T_XP:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_xp = *data & 0x000000FF;
                else PL340_WARN(cout << " can write to T_XP register in config or low power state only\n");
                break;         

            case PL340_T_XSR:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_xsr = *data & 0x000000FF;
                else PL340_WARN(cout << " can write to T_XSR register in config or low power state only\n");
                break;        

            case PL340_T_ESR:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) t_esr = *data & 0x000000FF;
                else PL340_WARN(cout << " can write to T_ESR register in config or low power state only\n");
                break;        

            case PL340_ID_00_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_00_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_00_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_01_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_01_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_01_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_02_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_02_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_02_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_03_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_03_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_03_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_04_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_04_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_04_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_05_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_05_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_05_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_06_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_06_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_06_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_07_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_07_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_07_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_08_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_08_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_08_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_09_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_09_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_09_CFG register in config or low power state only\n");
                break;    

            case PL340_ID_10_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_10_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_10_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_11_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_11_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_11_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_12_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_12_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_12_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_13_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_13_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_13_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_14_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_14_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_14_CFG register in config or low power state only\n");
                break;    
                
            case PL340_ID_15_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) id_15_cfg = *data & 0x000003FF;
                else PL340_WARN(cout << " can write to ID_15_CFG register in config or low power state only\n");
                break;    

            case PL340_CHIP_0_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) chip_0_cfg = *data & 0x0001FFFF;
                else PL340_WARN(cout << " can write to CHIP_0_CFG register in config or low power state only\n");
                break;   

            case PL340_CHIP_1_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) chip_1_cfg = *data & 0x0001FFFF;
                else PL340_WARN(cout << " can write to CHIP_1_CFG register in config or low power state only\n");
                break;   

            case PL340_CHIP_2_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) chip_2_cfg = *data & 0x0001FFFF;
                else PL340_WARN(cout << " can write to CHIP_2_CFG register in config or low power state only\n");
                break;   

            case PL340_CHIP_3_CFG:
                if( (memc_state == PL340_CONFIG) || (memc_state == PL340_LOWPOWER)) chip_3_cfg = *data & 0x0001FFFF;
                else PL340_WARN(cout << " can write to CHIP_3_CFG register in config or low power state only\n");
                break;   

            case PL340_USER_STATUS:
                PL340_WARN(cout << "We do not expect a write on this register \n");
                break;  

            case PL340_USER_CONFIG:
                *data = user_config;
                break;  

            case PL340_PERIPH_ID_0:
                *data = periph_id_0;
                break;  
            case PL340_PERIPH_ID_1:
                *data = periph_id_1;
                break;  
            case PL340_PERIPH_ID_2:
                *data = periph_id_2;
                break;  
            case PL340_PERIPH_ID_3:
                *data = periph_id_3;
                break;  


            case PL340_PCELL_ID_0:
                *data = pcell_id_0;
                break;   
            case PL340_PCELL_ID_1:
                *data = pcell_id_1;
                break;   
            case PL340_PCELL_ID_2:
                *data = pcell_id_2;
                break;   
            case PL340_PCELL_ID_3:
                *data = pcell_id_3;
                break;   
            default :
                PL340_WARN(cout << " Write of unknown register called.. Ignoring it\n");
                break;
        }
    }

    behavior transition_mc_fsm(uint32_t cmd)
    {
        switch(cmd)
        {
            case 0:                                     /* Go           */
                if( memc_state == PL340_CONFIG || memc_state == PL340_PAUSED) memc_state = PL340_READY;
            break;              
            
            case 1:                                     /* Sleep        */
                if( memc_state == PL340_CONFIG || memc_state == PL340_PAUSED) memc_state = PL340_LOWPOWER;
            break;
            
            case 2:                                     /* Wakeup       */
                if( memc_state == PL340_LOWPOWER ) memc_state = PL340_PAUSED;
            break;
            
            case 3:                                     /* Pause        */
                if( memc_state == PL340_READY ) memc_state = PL340_PAUSED;
            break;
            
            case 4:                                     /* Configure    */
                if( memc_state == PL340_PAUSED ) memc_state = PL340_CONFIG;
            break;

            case 7:                                     /* Active_Pause */
                if( memc_state == PL340_READY ) memc_state = PL340_PAUSED;
            break;

            default:
                PL340_WARN(cout << "unknown command encountered \n");
            break;
        }
        memc_status = (~(~memc_status | 0x3)) | memc_state;
    }

    resources
    {
        PARAMETER { description("Set this parameter to 0 if memory is connected"), type(int), default(-1) }  IF_CHIP0;   // default to -1 for not connected
        PARAMETER { description("Set this parameter to 0 if memory is connected"), type(int), default(-1) }  IF_CHIP1;
        PARAMETER { description("Set this parameter to 0 if memory is connected"), type(int), default(-1) }  IF_CHIP2;
        PARAMETER { description("Set this parameter to 0 if memory is connected"), type(int), default(-1) }  IF_CHIP3;
        PARAMETER { description("Set this parameter to 0 if memory is connected"), type(int), default(32) }  MEMORY_WIDTH;

        uint32_t  chips_connected[4];    // PL340 DMC allows a maximum of 4 chips to be connected


         PL340_DMC_MEMC_STATES memc_state;                    // use this variable to track the current state of the memory controller
                                                // one of: PL340_DMC_MEMC_STATES


        
        // some variables to maintain the current state of the memory manager
        uint32_t num_chips_connected;
        uint32_t memory_width;

        // the status of the memory controller.
        // used to transition the states of the memory controller
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x000), reset_value(UNINITIALIZED) } memc_status;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x004) } memc_cmd;   
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x008) } direct_cmd;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x00C) } memory_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x010) } refresh_prd;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x014) } cas_latency;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x018) } t_dqss;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x01C) } t_mrd;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x020) } t_ras;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x024) } t_rc;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x028) } t_rcd;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x02C) } t_rfc;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x030) } t_rp;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x034) } t_rrd;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x038) } t_wr;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x03C) } t_wtr;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x040) } t_xp;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x044) } t_xsr;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x048) } t_esr;

        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x100) } id_00_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x104) } id_01_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x108) } id_02_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x10C) } id_03_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x110) } id_04_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x114) } id_05_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x118) } id_06_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x11C) } id_07_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x120) } id_08_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x124) } id_09_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x128) } id_10_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x12C) } id_11_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x130) } id_12_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x134) } id_13_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x138) } id_14_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x13C) } id_15_cfg;

        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x200) } chip_0_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x204) } chip_1_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x208) } chip_2_cfg;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x20C) } chip_3_cfg;
                       
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x300) } user_status;
        REGISTER { read_function(debug_read), write_function(debug_write), reg_number(0x304) } user_config;

        uint32_t periph_id_0;
        uint32_t periph_id_1;
        uint32_t periph_id_2;
        uint32_t periph_id_3;

        uint32_t pcell_id_0;
        uint32_t pcell_id_1;
        uint32_t pcell_id_2;
        uint32_t pcell_id_3;
    }


    behavior init()
    {
        composition.init();

        int i = 0x0;       

        chips_connected[0] = IF_CHIP0;
        chips_connected[1] = IF_CHIP1;
        chips_connected[2] = IF_CHIP2;
        chips_connected[3] = IF_CHIP3;


        num_chips_connected = 0x0;
        for(i = 0; i < 4; i++ )
        {
            if(chips_connected[i] == PL340_NOT_CONNECTED ) continue;
            if(chips_connected[i] == PL340_DRAM) num_chips_connected++;   // increment the number of chips connected
                                                                          // ignore others.. hmmmph
        }

        if( num_chips_connected == 0x0)
        {
            PL340_WARN(cout << " There are not chips connected to this device, are you sure this is what you wanted to do? \n");
        }

        switch(MEMORY_WIDTH)
        {
            case 16:
                    memory_width = 0x0;
                    break;
            case 32:
                    memory_width = 0x1;
                    break;
            case 64:
                    memory_width = 0x2;
                    break;
            default:
                    memory_width = 0x1;
                    PL340_WARN(cout << "Invalid MEMORY_WIDTH specified ..  Defaulting to 32 \n");
        }

        memc_state = PL340_CONFIG;    // we should be in config mode after the reset.

        // this gives the current status of the memory controller.
        memc_status   = ( 4<<10 ) | ( 1 << 9) | (4 << 7) | (1 << 4) | (memory_width << 2) | ((uint32_t)memc_state & 0x3);
        memc_cmd      = 0x0;
                      
        direct_cmd    = 0x0;
        memory_cfg   = 0x0;
        refresh_prd  = 0x0;
        cas_latency  = 0x0;
        t_dqss       = 0x0;
        t_mrd        = 0x0;
        t_ras        = 0x0;
        t_rc         = 0x0;
        t_rcd        = 0x0;
        t_rfc        = 0x0;
        t_rp         = 0x0;
        t_rrd        = 0x0;
        t_wr         = 0x0;
        t_wtr        = 0x0;
        t_xp         = 0x0;
        t_xsr        = 0x0;
        t_esr        = 0x0;

        id_00_cfg    = 0x0;
        id_01_cfg    = 0x0;
        id_02_cfg    = 0x0;
        id_03_cfg    = 0x0;
        id_04_cfg    = 0x0;
        id_05_cfg    = 0x0;
        id_06_cfg    = 0x0;
        id_07_cfg    = 0x0;
        id_08_cfg    = 0x0;
        id_09_cfg    = 0x0;
        id_10_cfg    = 0x0;
        id_11_cfg    = 0x0;
        id_12_cfg    = 0x0;
        id_13_cfg    = 0x0;
        id_14_cfg    = 0x0;
        id_15_cfg    = 0x0;

        chip_0_cfg   = 0x0;
        chip_1_cfg   = 0x0;
        chip_2_cfg   = 0x0;
        chip_3_cfg   = 0x0;
              
        user_status  = 0x0;
        user_config  = 0x0;

        periph_id_0  = 0x40;
        periph_id_1  = 0x13;
        periph_id_2  = 0x14;
        periph_id_3  = 0x0;

        pcell_id_0   = 0x0D;
        pcell_id_1   = 0xF0;
        pcell_id_2   = 0x05;
        pcell_id_3   = 0xB1;
    }

    behavior reset(int level )
    {
        composition.reset(level);

        int i = 0x0;       

        chips_connected[0] = IF_CHIP0;
        chips_connected[1] = IF_CHIP1;
        chips_connected[2] = IF_CHIP2;
        chips_connected[3] = IF_CHIP3;


        num_chips_connected = 0x0;
        for(i = 0; i < 4; i++ )
        {
            if(chips_connected[i] == PL340_NOT_CONNECTED ) continue;
            if(chips_connected[i] == PL340_DRAM) num_chips_connected++;   // increment the number of chips connected
                                                                          // ignore others.. hmmmph
        }

        if( num_chips_connected == 0x0)
        {
            PL340_WARN(cout << " There are not chips connected to this device, are you sure this is what you wanted to do? \n");
        }

        switch(MEMORY_WIDTH)
        {
            case 16:
                    memory_width = 0x0;
                    break;
            case 32:
                    memory_width = 0x1;
                    break;
            case 64:
                    memory_width = 0x2;
                    break;
            default:
                    memory_width = 0x1;
                    PL340_WARN(cout << "Invalid MEMORY_WIDTH specified ..  Defaulting to 32 \n");
        }

        memc_state = PL340_CONFIG;    // we should be in config mode after the reset.

        // this gives the current status of the memory controller.
        memc_status   = ( 4<<10 ) | ( 1 << 9) | (4 << 7) | (1 << 4) | (memory_width << 2) | ((uint32_t)memc_state & 0x3);
        memc_cmd      = 0x0;
                      
        direct_cmd    = 0x0;
        memory_cfg   = 0x0;
        refresh_prd  = 0x0;
        cas_latency  = 0x0;
        t_dqss       = 0x0;
        t_mrd        = 0x0;
        t_ras        = 0x0;
        t_rc         = 0x0;
        t_rcd        = 0x0;
        t_rfc        = 0x0;
        t_rp         = 0x0;
        t_rrd        = 0x0;
        t_wr         = 0x0;
        t_wtr        = 0x0;
        t_xp         = 0x0;
        t_xsr        = 0x0;
        t_esr        = 0x0;

        id_00_cfg    = 0x0;
        id_01_cfg    = 0x0;
        id_02_cfg    = 0x0;
        id_03_cfg    = 0x0;
        id_04_cfg    = 0x0;
        id_05_cfg    = 0x0;
        id_06_cfg    = 0x0;
        id_07_cfg    = 0x0;
        id_08_cfg    = 0x0;
        id_09_cfg    = 0x0;
        id_10_cfg    = 0x0;
        id_11_cfg    = 0x0;
        id_12_cfg    = 0x0;
        id_13_cfg    = 0x0;
        id_14_cfg    = 0x0;
        id_15_cfg    = 0x0;

        chip_0_cfg   = 0x0;
        chip_1_cfg   = 0x0;
        chip_2_cfg   = 0x0;
        chip_3_cfg   = 0x0;
              
        user_status  = 0x0;
        user_config  = 0x0;

        periph_id_0  = 0x40;
        periph_id_1  = 0x13;
        periph_id_2  = 0x14;
        periph_id_3  = 0x0;

        pcell_id_0   = 0x0D;
        pcell_id_1   = 0xF0;
        pcell_id_2   = 0x05;
        pcell_id_3   = 0xB1;
    }

    // debugger register access support
    behaviour debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects) : AccessFuncResult
    {
        do_reg_read(reg_id, 4, (uint32_t*)datap);

        return ACCESS_FUNC_OK;
    }

    behaviour debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects) : AccessFuncResult
    {
        do_reg_write( reg_id, 4, (uint32_t *) datap);

        return ACCESS_FUNC_OK;
    }
}
