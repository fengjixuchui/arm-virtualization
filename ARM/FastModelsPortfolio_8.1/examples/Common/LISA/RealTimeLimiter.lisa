// This file was generated by System Generator Canvas
// --------------------------------------------------
component RealTimeLimiter
{
    properties {
        version = "8.1.37";
        component_type = "Other";
    }

    includes
    {
        #include "sg/SystemInclude.h"
        #ifdef _WINDOWS
            #define sleep_milliseconds(x) Sleep(x)
        #else
            #include <sys/time.h>
            #define sleep_milliseconds(x) usleep(x*1000)
        #endif
    }

    resources
    {
        PARAMETER { type(bool), default(false), runtime(true), description("Rate limit simulation") } ENABLE;
        PARAMETER { type(int), default(100), min(10), runtime(true), description("Rate limit to at most this percentage of real time (100: limit to wall clock rate)") } RELATIVE_SPEED;

        // holds the wall clock time of the last timer signal in milliseconds
        uint32_t lastRealTimeMs;

        // current time budget in milliseconds
        int budget;

        // time averaging constants
        enum
        {
            // max time in milliseconds we allow simulator to fall behind real time and catch up without distortion
            MAX_TIME_BUDGET = -1000,  // -1000 == 1 second
        };
    }

    composition
    {
        // timer for receiving clock signals
        timer : ClockTimer;
        divider : ClockDivider(mul=10);
    }

    connection
    {
        self.clk_in => divider.clk_in;
        divider.clk_out => timer.clk_in;
        timer.timer_callback => self.timer_callback_handler;
    }

    slave port<ClockSignal> clk_in;

    internal slave  port <TimerCallback> timer_callback_handler
    {
        behaviour signal() : uint32_t
        {
            // get simulated time in ms
            int simMsPerTick = 1000 / 10;

            // get real time passed in ms
            uint32_t ct = get_msTime();
            int realMsPerTick = ct - lastRealTimeMs;
            lastRealTimeMs = ct;

            // limit real time passed to one second to avoid extreme cases
            if (realMsPerTick > 1000)
                realMsPerTick = 1000;

            // update time budget (the ms we have been too fast recently)
            budget += simMsPerTick * 100 / RELATIVE_SPEED;
            budget -= realMsPerTick;

            // limit time budget to catch up for at most 1 second
            // (we can catch up at most 1 second of simulation time by running faster than real time)
            if (budget < MAX_TIME_BUDGET)
                budget = MAX_TIME_BUDGET;

            // limit time budget to at most one second of sleep
            // (this can never occur, the max value in theory is 100 if the OS sleep works correctly)
            if (budget > 1000)
                budget = 1000;

            // if our time budget is positive: sleep, if it is negavtive or 0: continue as fast as possible
            if (ENABLE && budget > 0)
                sleep_milliseconds(budget);

            // call us back next clock tick (100ms == 10Hz simulated time)
            return 1;
        }
    }

    behavior reset(int level)
    {
        composition.reset(level);

        timer.timer_control.cancel();
        timer.timer_control.set(1);

        lastRealTimeMs = get_msTime();
        budget = 0;
    }

    // return the current wall clock time in milliseconds
    behavior get_msTime(void) : uint32_t
    {
#ifdef WIN32
        return (GetTickCount());
#else
        struct timeval tv;
        if (gettimeofday(&tv, NULL) != 0) {
            return 0;
        }
        return (tv.tv_sec*1000)+(tv.tv_usec/1000);
#endif
    }
}
