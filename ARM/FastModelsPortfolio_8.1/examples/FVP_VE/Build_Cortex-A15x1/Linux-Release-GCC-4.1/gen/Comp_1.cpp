/*
 * 
 *
 * This is an automatically generated file. Do not edit.
 *
 * Copyright 2009 ARM Limited.
 * Copyright 2011 ARM Limited.
 *
 * All rights reserved.
 */
/** \file
 * System components.
 */

#include "GlobalDefs.h"
#include "Components.h"

#include "Component__VEDaughterBoard_ClassDef.h"
#include "Component__VEMotherBoard_ClassDef.h"
#include "Component__FVP_VE_Cortex_A15x1_ClassDef.h"
#include "Component__FlashLoader_ClassDef.h"
#include "Component__IntelStrataFlashJ3_ClassDef.h"
#include "Component__PL370_HDLCD_ClassDef.h"
#include "Component__RAMDevice_ClassDef.h"
#include "Component__TZSwitch_ClassDef.h"
#include "Component__VEDCC_ClassDef.h"
#include "Component__VEInterruptMapper_ClassDef.h"
#include "Component__VEDaughterBoard_ClassDef.h"
#include "Component__RAMDevice_ClassDef.h"
#include "Component__TZSwitch_ClassDef.h"
#include "Component__PL370_HDLCD_ClassDef.h"
#include "Component__VEInterruptMapper_ClassDef.h"
#include "Component__IntelStrataFlashJ3_ClassDef.h"
#include "Component__FlashLoader_ClassDef.h"
#include "Component__VEDCC_ClassDef.h"
#include "Component__AudioOut_SDL_ClassDef.h"
#include "Component__FlashLoader_ClassDef.h"
#include "Component__HostBridge_ClassDef.h"
#include "Component__IntelStrataFlashJ3_ClassDef.h"
#include "Component__MMC_ClassDef.h"
#include "Component__PL011_Uart_ClassDef.h"
#include "Component__PL031_RTC_ClassDef.h"
#include "Component__PL041_AACI_ClassDef.h"
#include "Component__PL050_KMI_ClassDef.h"
#include "Component__PL111_CLCD_ClassDef.h"
#include "Component__PL180_MCI_ClassDef.h"
#include "Component__PS2Keyboard_ClassDef.h"
#include "Component__PS2Mouse_ClassDef.h"
#include "Component__RAMDevice_ClassDef.h"
#include "Component__SP804_Timer_ClassDef.h"
#include "Component__SP805_Watchdog_ClassDef.h"
#include "Component__SP810_SysCtrl_ClassDef.h"
#include "Component__VEVisualisation_ClassDef.h"
#include "Component__VE_CompactFlash_ClassDef.h"
#include "Component__VE_SysRegs_ClassDef.h"
#include "Component__VFS2_ClassDef.h"
#include "Component__VirtualEthernetCrossover_ClassDef.h"
#include "Component__VEMotherBoard_ClassDef.h"
#include "Component__CounterModule_ClassDef.h"
#include "Component__SP804_Timer_ClassDef.h"
#include "Component__CounterModule_ClassDef.h"
#include "Component__AudioOut_SDL_ClassDef.h"
#include "Component__VE_CompactFlash_ClassDef.h"
#include "Component__HostBridge_ClassDef.h"
#include "Component__MMC_ClassDef.h"
#include "Component__PL011_Uart_ClassDef.h"
#include "Component__PL031_RTC_ClassDef.h"
#include "Component__PL041_AACI_ClassDef.h"
#include "Component__PL050_KMI_ClassDef.h"
#include "Component__PL11x_CLCD_ClassDef.h"
#include "Component__PL111_CLCD_ClassDef.h"
#include "Component__PL11x_CLCD_ClassDef.h"
#include "Component__PL180_MCI_ClassDef.h"
#include "Component__PS2Keyboard_ClassDef.h"
#include "Component__PS2Mouse_ClassDef.h"


#include "eslapi/CADITypes.h"


#include "sg/SGBasicComponentFactory.h"

#include "TerminateScheduler.h"
#include "ParameterFilter.h"

#include <sg/MSCFixes.h>

// make the MSG_<...> symbols available in the global namespace
using namespace sg::message;

// component CADI interfaces
// ------------------------------------------------------------------------------
// CADI Interface for component Component__FVP_VE_Cortex_A15x1
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__FVP_VE_Cortex_A15x1_CADI : public sg::CADIBase
{
public:
        Component__FVP_VE_Cortex_A15x1_CADI(Component__FVP_VE_Cortex_A15x1* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__FVP_VE_Cortex_A15x1 *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__VEDaughterBoard
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__VEDaughterBoard_CADI : public sg::CADIBase
{
public:
        Component__VEDaughterBoard_CADI(Component__VEDaughterBoard* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__VEDaughterBoard *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__RAMDevice
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__RAMDevice_CADI : public sg::CADIBase
{
public:
        Component__RAMDevice_CADI(Component__RAMDevice* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__RAMDevice *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__TZSwitch
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__TZSwitch_CADI : public sg::CADIBase
{
public:
        Component__TZSwitch_CADI(Component__TZSwitch* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__TZSwitch *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PL370_HDLCD
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PL370_HDLCD_CADI : public sg::CADIBase
{
public:
        Component__PL370_HDLCD_CADI(Component__PL370_HDLCD* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PL370_HDLCD *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__VEInterruptMapper
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__VEInterruptMapper_CADI : public sg::CADIBase
{
public:
        Component__VEInterruptMapper_CADI(Component__VEInterruptMapper* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__VEInterruptMapper *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__IntelStrataFlashJ3
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__IntelStrataFlashJ3_CADI : public sg::CADIBase
{
public:
        Component__IntelStrataFlashJ3_CADI(Component__IntelStrataFlashJ3* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__IntelStrataFlashJ3 *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__FlashLoader
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__FlashLoader_CADI : public sg::CADIBase
{
public:
        Component__FlashLoader_CADI(Component__FlashLoader* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__FlashLoader *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__VEDCC
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__VEDCC_CADI : public sg::CADIBase
{
public:
        Component__VEDCC_CADI(Component__VEDCC* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__VEDCC *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__VEMotherBoard
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__VEMotherBoard_CADI : public sg::CADIBase
{
public:
        Component__VEMotherBoard_CADI(Component__VEMotherBoard* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__VEMotherBoard *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__SP804_Timer
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__SP804_Timer_CADI : public sg::CADIBase
{
public:
        Component__SP804_Timer_CADI(Component__SP804_Timer* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__SP804_Timer *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__CounterModule
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__CounterModule_CADI : public sg::CADIBase
{
public:
        Component__CounterModule_CADI(Component__CounterModule* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__CounterModule *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__AudioOut_SDL
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__AudioOut_SDL_CADI : public sg::CADIBase
{
public:
        Component__AudioOut_SDL_CADI(Component__AudioOut_SDL* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__AudioOut_SDL *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__VE_CompactFlash
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__VE_CompactFlash_CADI : public sg::CADIBase
{
public:
        Component__VE_CompactFlash_CADI(Component__VE_CompactFlash* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__VE_CompactFlash *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__HostBridge
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__HostBridge_CADI : public sg::CADIBase
{
public:
        Component__HostBridge_CADI(Component__HostBridge* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__HostBridge *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__MMC
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__MMC_CADI : public sg::CADIBase
{
public:
        Component__MMC_CADI(Component__MMC* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__MMC *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PL011_Uart
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PL011_Uart_CADI : public sg::CADIBase
{
public:
        Component__PL011_Uart_CADI(Component__PL011_Uart* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PL011_Uart *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PL031_RTC
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PL031_RTC_CADI : public sg::CADIBase
{
public:
        Component__PL031_RTC_CADI(Component__PL031_RTC* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PL031_RTC *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PL041_AACI
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PL041_AACI_CADI : public sg::CADIBase
{
public:
        Component__PL041_AACI_CADI(Component__PL041_AACI* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PL041_AACI *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PL050_KMI
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PL050_KMI_CADI : public sg::CADIBase
{
public:
        Component__PL050_KMI_CADI(Component__PL050_KMI* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PL050_KMI *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PL111_CLCD
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PL111_CLCD_CADI : public sg::CADIBase
{
public:
        Component__PL111_CLCD_CADI(Component__PL111_CLCD* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PL111_CLCD *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PL11x_CLCD
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PL11x_CLCD_CADI : public sg::CADIBase
{
public:
        Component__PL11x_CLCD_CADI(Component__PL11x_CLCD* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PL11x_CLCD *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PL180_MCI
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PL180_MCI_CADI : public sg::CADIBase
{
public:
        Component__PL180_MCI_CADI(Component__PL180_MCI* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PL180_MCI *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PS2Keyboard
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PS2Keyboard_CADI : public sg::CADIBase
{
public:
        Component__PS2Keyboard_CADI(Component__PS2Keyboard* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PS2Keyboard *component;
};

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// CADI Interface for component Component__PS2Mouse
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

class Component__PS2Mouse_CADI : public sg::CADIBase
{
public:
        Component__PS2Mouse_CADI(Component__PS2Mouse* parentComponent, sg::ComponentBase* simulationEngine);

    eslapi::CADIReturn_t CADIXfaceBypass(uint32_t commandLength, const char *command, uint32_t maxResponseLength, char *response);
    sg::accessfunc::AccessFuncResult GetExtendedTargetFeatures(MxU32 /*id*/, std::string &data, bool /*se*/);

private:
    Component__PS2Mouse *component;
};

} // FVP_VE_Cortex_A15x1_NMS


// non inline behaviors
#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::interconnect()
{{if(!controlPort_cluster__.interconnect.empty()) controlPort_cluster__.interconnect();if(!controlPort_motherboard__.interconnect.empty()) controlPort_motherboard__.interconnect();if(!controlPort_daughterboard__.interconnect.empty()) controlPort_daughterboard__.interconnect();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::disconnect()
{{if(!controlPort_cluster__.disconnect.empty()) controlPort_cluster__.disconnect();if(!controlPort_motherboard__.disconnect.empty()) controlPort_motherboard__.disconnect();if(!controlPort_daughterboard__.disconnect.empty()) controlPort_daughterboard__.disconnect();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::update()
{{if(!controlPort_cluster__.update.empty()) controlPort_cluster__.update();if(!controlPort_motherboard__.update.empty()) controlPort_motherboard__.update();if(!controlPort_daughterboard__.update.empty()) controlPort_daughterboard__.update();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::communicate()
{{if(!controlPort_cluster__.communicate.empty()) controlPort_cluster__.communicate();if(!controlPort_motherboard__.communicate.empty()) controlPort_motherboard__.communicate();if(!controlPort_daughterboard__.communicate.empty()) controlPort_daughterboard__.communicate();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::traceEndOfCycle()
{{if(!controlPort_cluster__.traceEndOfCycle.empty()) controlPort_cluster__.traceEndOfCycle();if(!controlPort_motherboard__.traceEndOfCycle.empty()) controlPort_motherboard__.traceEndOfCycle();if(!controlPort_daughterboard__.traceEndOfCycle.empty()) controlPort_daughterboard__.traceEndOfCycle();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::loadApplicationFile(const std::string& filename)
{{if(!controlPort_cluster__.loadApplicationFile.empty()) controlPort_cluster__.loadApplicationFile(filename);if(!controlPort_motherboard__.loadApplicationFile.empty()) controlPort_motherboard__.loadApplicationFile(filename);if(!controlPort_daughterboard__.loadApplicationFile.empty()) controlPort_daughterboard__.loadApplicationFile(filename);};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::init()
{{if(!controlPort_cluster__.init.empty()) controlPort_cluster__.init();if(!controlPort_motherboard__.init.empty()) controlPort_motherboard__.init();if(!controlPort_daughterboard__.init.empty()) controlPort_daughterboard__.init();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::terminate()
{{if(!controlPort_cluster__.terminate.empty()) controlPort_cluster__.terminate();if(!controlPort_motherboard__.terminate.empty()) controlPort_motherboard__.terminate();if(!controlPort_daughterboard__.terminate.empty()) controlPort_daughterboard__.terminate();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::reset(int level)
{{if(!controlPort_cluster__.reset.empty()) controlPort_cluster__.reset(level);if(!controlPort_motherboard__.reset.empty()) controlPort_motherboard__.reset(level);if(!controlPort_daughterboard__.reset.empty()) controlPort_daughterboard__.reset(level);};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__FVP_VE_Cortex_A15x1::save(MxODataStream& os)
{{if(!controlPort_cluster__.save.empty()) controlPort_cluster__.save(os);if(!controlPort_motherboard__.save.empty()) controlPort_motherboard__.save(os);if(!controlPort_daughterboard__.save.empty()) controlPort_daughterboard__.save(os);};return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__FVP_VE_Cortex_A15x1::restore(MxIDataStream& is)
{{if(!controlPort_cluster__.restore.empty()) controlPort_cluster__.restore(is);if(!controlPort_motherboard__.restore.empty()) controlPort_motherboard__.restore(is);if(!controlPort_daughterboard__.restore.empty()) controlPort_daughterboard__.restore(is);};return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/FVP_VE_Cortex_A15x1.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FVP_VE_Cortex_A15x1::step()
{{if(!controlPort_cluster__.step.empty()) controlPort_cluster__.step();if(!controlPort_motherboard__.step.empty()) controlPort_motherboard__.step();if(!controlPort_daughterboard__.step.empty()) controlPort_daughterboard__.step();};
}
}

#line 664 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__FVP_VE_Cortex_A15x1
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__FVP_VE_Cortex_A15x1::Component__FVP_VE_Cortex_A15x1(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)



	,cadiParameterProxy_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1__(0)
	,cadiParameterProxy_motherboard_of_VEMotherBoard_to_FVP_VE_Cortex_A15x1__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "System";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Top level component of the Cortex_A15x1 Versatile Express inspired model.";
	properties__["documentation_file"] = "";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = FVP_VE_Cortex_A15x1_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *VEDaughterBoard_factory = VEDaughterBoard_GetFactory();
		sg::ComponentFactory *VEMotherBoard_factory = VEMotherBoard_GetFactory();
		sg::ComponentFactory *ARMCortexA15x1CT_factory = ARMCortexA15x1CT_GetFactory();
		{
			sg::Params params_cluster__ = params.getParamsFor("cluster");
			params_cluster__["PERIPHBASE"] = MxU64CONST(0x000000002C000000);
			{
				bool dummy = true;
				if(!params_cluster__.get("cpu0.semihosting-heap_base", dummy))
					parameterFilter_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1__.override_default(params_cluster__["cpu0.semihosting-heap_base"], "cpu0.semihosting-heap_base");
			}
			{
				bool dummy = true;
				if(!params_cluster__.get("cpu0.semihosting-heap_limit", dummy))
					parameterFilter_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1__.override_default(params_cluster__["cpu0.semihosting-heap_limit"], "cpu0.semihosting-heap_limit");
			}
			{
				bool dummy = true;
				if(!params_cluster__.get("cpu0.semihosting-stack_limit", dummy))
					parameterFilter_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1__.override_default(params_cluster__["cpu0.semihosting-stack_limit"], "cpu0.semihosting-stack_limit");
			}
			{
				bool dummy = true;
				if(!params_cluster__.get("cpu0.semihosting-stack_base", dummy))
					parameterFilter_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1__.override_default(params_cluster__["cpu0.semihosting-stack_base"], "cpu0.semihosting-stack_base");
			}
			add(cluster = ARMCortexA15x1CT_factory->instantiate("cluster", simulationContext, params_cluster__));
		}
		{
			sg::Params params_motherboard__ = params.getParamsFor("motherboard");
			{
				bool dummy = true;
				if(!params_motherboard__.get("proc_id0", dummy))
					parameterFilter_motherboard_of_VEMotherBoard_to_FVP_VE_Cortex_A15x1__.override_default(params_motherboard__["proc_id0"], "proc_id0");
			}
			motherboard = dynamic_cast<Component__VEMotherBoard*>(VEMotherBoard_factory->instantiate("motherboard", simulationContext, params_motherboard__));
			assert(motherboard);
			add(motherboard);
		}
		{
			sg::Params params_daughterboard__ = params.getParamsFor("daughterboard");
			daughterboard = dynamic_cast<Component__VEDaughterBoard*>(VEDaughterBoard_factory->instantiate("daughterboard", simulationContext, params_daughterboard__));
			assert(daughterboard);
			add(daughterboard);
		}
		VEDaughterBoard_factory->dereference();
		VEMotherBoard_factory->dereference();
		ARMCortexA15x1CT_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__FVP_VE_Cortex_A15x1::control_port__configure, this);
    bind_method(control_port, init, &Component__FVP_VE_Cortex_A15x1::init, this);
    bind_method(control_port, interconnect, &Component__FVP_VE_Cortex_A15x1::interconnect, this);
//  bind_method(control_port, postConnect, &Component__FVP_VE_Cortex_A15x1::postConnect, this);
    bind_method(control_port, reset, &Component__FVP_VE_Cortex_A15x1::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__FVP_VE_Cortex_A15x1::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__FVP_VE_Cortex_A15x1::disconnect, this);
    bind_method(control_port, terminate, &Component__FVP_VE_Cortex_A15x1::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__FVP_VE_Cortex_A15x1::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__FVP_VE_Cortex_A15x1::refresh, this);
    bind_method(control_port, step, &Component__FVP_VE_Cortex_A15x1::step, this);
    bind_method(control_port, update, &Component__FVP_VE_Cortex_A15x1::update, this);
    bind_method(control_port, communicate, &Component__FVP_VE_Cortex_A15x1::communicate, this);
    bind_method(control_port, getProperty, &Component__FVP_VE_Cortex_A15x1::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__FVP_VE_Cortex_A15x1::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__FVP_VE_Cortex_A15x1::control_port__bypass, this);
    bind_method(control_port, run, &Component__FVP_VE_Cortex_A15x1::control_port__run, this);
    bind_method(control_port, stop, &Component__FVP_VE_Cortex_A15x1::control_port__stop, this);
    bind_method(control_port, idle, &Component__FVP_VE_Cortex_A15x1::control_port__idle, this);
    bind_method(control_port, quit, &Component__FVP_VE_Cortex_A15x1::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__FVP_VE_Cortex_A15x1::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__FVP_VE_Cortex_A15x1::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__FVP_VE_Cortex_A15x1::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__FVP_VE_Cortex_A15x1::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__FVP_VE_Cortex_A15x1::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__FVP_VE_Cortex_A15x1::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__FVP_VE_Cortex_A15x1::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__FVP_VE_Cortex_A15x1::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_cluster__.connectTo(cluster->findPort("$control"));
	controlPort_motherboard__.connectTo(motherboard->findPort("$control"));
	controlPort_daughterboard__.connectTo(daughterboard->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports


    // add abstract ports


    // wire up static connection map
	daughterboard->findPort("cpu_clk").connectTo(cluster->findPort("clk_in"));
	cluster->findPort("pvbus_m0").connectTo(daughterboard->findPort("cpu_pvbus"));
	for (MxU32 i__ = 0; i__ < 224; ++i__)
	{
	daughterboard->findPort("cpu_irqs", i__).connectTo(cluster->findPort("irqs", i__));

	}
	motherboard->findPort("masterclk").connectTo(daughterboard->findPort("clk_in"));
	for (MxU32 i__ = 0; i__ < 48; ++i__)
	{
	motherboard->findPort("interrupts", i__).connectTo(daughterboard->findPort("interrupts", i__));

	}
	for (MxU32 i__ = 0; i__ < 8; ++i__)
	{
	daughterboard->findPort("smb_cs", i__).connectTo(motherboard->findPort("smb_cs", i__));

	}
	motherboard->findPort("clcd_pvbus").connectTo(daughterboard->findPort("clcd_pvbus"));
	daughterboard->findPort("mmb").connectTo(motherboard->findPort("mmb_db1"));
	motherboard->findPort("CB", 0).connectTo(daughterboard->findPort("CB"));
	for (MxU32 i__ = 0; i__ < 4; ++i__)
	{
	cluster->findPort("ticks", i__).connectTo(motherboard->findPort("cluster0_ticks", i__));

	}
	motherboard->findPort("virtio_m").connectTo(cluster->findPort("acp_s"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__FVP_VE_Cortex_A15x1::~Component__FVP_VE_Cortex_A15x1()
{
}

void Component__FVP_VE_Cortex_A15x1::control_port__configure(const sg::Params& params)
{
	if(controlPort_cluster__.configure.implemented()) controlPort_cluster__.configure(params.getParamsFor("cluster"));
	if(controlPort_motherboard__.configure.implemented()) controlPort_motherboard__.configure(params.getParamsFor("motherboard"));
	if(controlPort_daughterboard__.configure.implemented()) controlPort_daughterboard__.configure(params.getParamsFor("daughterboard"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__FVP_VE_Cortex_A15x1_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__FVP_VE_Cortex_A15x1::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_cluster__.populateCADIMap.implemented())
			{
				controlPort_cluster__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("cluster", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1__ = new CADIParameterProxy(cadi, &parameterFilter_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_motherboard__.populateCADIMap.implemented())
			{
				controlPort_motherboard__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("motherboard", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_motherboard_of_VEMotherBoard_to_FVP_VE_Cortex_A15x1__ = new CADIParameterProxy(cadi, &parameterFilter_motherboard_of_VEMotherBoard_to_FVP_VE_Cortex_A15x1__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_daughterboard__.populateCADIMap.implemented())
			{
				controlPort_daughterboard__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__FVP_VE_Cortex_A15x1::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__FVP_VE_Cortex_A15x1::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__FVP_VE_Cortex_A15x1::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__FVP_VE_Cortex_A15x1::control_port__bypass(const std::string&)
{
    return "";
}


void Component__FVP_VE_Cortex_A15x1::control_port__run()
{
}


void Component__FVP_VE_Cortex_A15x1::control_port__stop()
{
}


void Component__FVP_VE_Cortex_A15x1::control_port__idle()
{
}


void Component__FVP_VE_Cortex_A15x1::control_port__quit()
{
}


void Component__FVP_VE_Cortex_A15x1::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__FVP_VE_Cortex_A15x1::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__FVP_VE_Cortex_A15x1::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__FVP_VE_Cortex_A15x1::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__FVP_VE_Cortex_A15x1::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__FVP_VE_Cortex_A15x1::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1__;
	cadiParameterProxy_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1__ = 0;
	delete cadiParameterProxy_motherboard_of_VEMotherBoard_to_FVP_VE_Cortex_A15x1__;
	cadiParameterProxy_motherboard_of_VEMotherBoard_to_FVP_VE_Cortex_A15x1__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__FVP_VE_Cortex_A15x1::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__FVP_VE_Cortex_A15x1::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__FVP_VE_Cortex_A15x1::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__FVP_VE_Cortex_A15x1::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__FVP_VE_Cortex_A15x1::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__FVP_VE_Cortex_A15x1::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__FVP_VE_Cortex_A15x1::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__FVP_VE_Cortex_A15x1::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__FVP_VE_Cortex_A15x1::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__FVP_VE_Cortex_A15x1::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__FVP_VE_Cortex_A15x1::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__FVP_VE_Cortex_A15x1::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__FVP_VE_Cortex_A15x1::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__FVP_VE_Cortex_A15x1::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__FVP_VE_Cortex_A15x1::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__FVP_VE_Cortex_A15x1::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__FVP_VE_Cortex_A15x1::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__FVP_VE_Cortex_A15x1::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__FVP_VE_Cortex_A15x1::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__FVP_VE_Cortex_A15x1::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__FVP_VE_Cortex_A15x1::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 142 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::init()
{
 if (secure_memory)
 {
 secure_region->control.routeAccesses(TZINPUT_SECURE, TZROUTE_TO_PORT_B);
 secure_region->control.routeAccesses(TZINPUT_NORMAL, TZROUTE_ABORT);
 nonsecure_region->control.routeAccesses(TZINPUT_SECURE, TZROUTE_ABORT);
 nonsecure_region->control.routeAccesses(TZINPUT_NORMAL, TZROUTE_TO_PORT_A);
 }
 else
 {
 secure_region->control.routeAccesses(TZINPUT_ANY, TZROUTE_TO_PORT_A);
 nonsecure_region->control.routeAccesses(TZINPUT_ANY, TZROUTE_TO_PORT_A);
 }

 dram_aliased->control.routeAccesses(TZINPUT_ANY, (dram_alias) ? TZROUTE_TO_PORT_A : TZROUTE_ABORT);

 dram_limit_4->control.routeAccesses(TZINPUT_ANY, (dram_size < 4) ? TZROUTE_ABORT : TZROUTE_TO_PORT_A);
 dram_limit_8->control.routeAccesses(TZINPUT_ANY, (dram_size < 8) ? TZROUTE_ABORT : TZROUTE_TO_PORT_A);

 {if(!controlPort_pvbusdecoder__.init.empty()) controlPort_pvbusdecoder__.init();if(!controlPort_coresight_mapper__.init.empty()) controlPort_coresight_mapper__.init();if(!controlPort_sram__.init.empty()) controlPort_sram__.init();if(!controlPort_vedcc__.init.empty()) controlPort_vedcc__.init();if(!controlPort_clockdivider__.init.empty()) controlPort_clockdivider__.init();if(!controlPort_clockCLCD__.init.empty()) controlPort_clockCLCD__.init();if(!controlPort_dram__.init.empty()) controlPort_dram__.init();if(!controlPort_dram_aliased__.init.empty()) controlPort_dram_aliased__.init();if(!controlPort_dram_limit_4__.init.empty()) controlPort_dram_limit_4__.init();if(!controlPort_dram_limit_8__.init.empty()) controlPort_dram_limit_8__.init();if(!controlPort_introuter__.init.empty()) controlPort_introuter__.init();if(!controlPort_secure_region__.init.empty()) controlPort_secure_region__.init();if(!controlPort_nonsecure_region__.init.empty()) controlPort_nonsecure_region__.init();if(!controlPort_securitydecoder__.init.empty()) controlPort_securitydecoder__.init();if(!controlPort_securepvbusdecoder__.init.empty()) controlPort_securepvbusdecoder__.init();if(!controlPort_secureRO__.init.empty()) controlPort_secureRO__.init();if(!controlPort_secureROloader__.init.empty()) controlPort_secureROloader__.init();if(!controlPort_secureSRAM__.init.empty()) controlPort_secureSRAM__.init();if(!controlPort_secureDRAM__.init.empty()) controlPort_secureDRAM__.init();if(!controlPort_hdlcd__.init.empty()) controlPort_hdlcd__.init();if(!controlPort_dmc__.init.empty()) controlPort_dmc__.init();if(!controlPort_dmc_phy__.init.empty()) controlPort_dmc_phy__.init();};
 
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::interconnect()
{{if(!controlPort_pvbusdecoder__.interconnect.empty()) controlPort_pvbusdecoder__.interconnect();if(!controlPort_coresight_mapper__.interconnect.empty()) controlPort_coresight_mapper__.interconnect();if(!controlPort_sram__.interconnect.empty()) controlPort_sram__.interconnect();if(!controlPort_vedcc__.interconnect.empty()) controlPort_vedcc__.interconnect();if(!controlPort_clockdivider__.interconnect.empty()) controlPort_clockdivider__.interconnect();if(!controlPort_clockCLCD__.interconnect.empty()) controlPort_clockCLCD__.interconnect();if(!controlPort_dram__.interconnect.empty()) controlPort_dram__.interconnect();if(!controlPort_dram_aliased__.interconnect.empty()) controlPort_dram_aliased__.interconnect();if(!controlPort_dram_limit_4__.interconnect.empty()) controlPort_dram_limit_4__.interconnect();if(!controlPort_dram_limit_8__.interconnect.empty()) controlPort_dram_limit_8__.interconnect();if(!controlPort_introuter__.interconnect.empty()) controlPort_introuter__.interconnect();if(!controlPort_secure_region__.interconnect.empty()) controlPort_secure_region__.interconnect();if(!controlPort_nonsecure_region__.interconnect.empty()) controlPort_nonsecure_region__.interconnect();if(!controlPort_securitydecoder__.interconnect.empty()) controlPort_securitydecoder__.interconnect();if(!controlPort_securepvbusdecoder__.interconnect.empty()) controlPort_securepvbusdecoder__.interconnect();if(!controlPort_secureRO__.interconnect.empty()) controlPort_secureRO__.interconnect();if(!controlPort_secureROloader__.interconnect.empty()) controlPort_secureROloader__.interconnect();if(!controlPort_secureSRAM__.interconnect.empty()) controlPort_secureSRAM__.interconnect();if(!controlPort_secureDRAM__.interconnect.empty()) controlPort_secureDRAM__.interconnect();if(!controlPort_hdlcd__.interconnect.empty()) controlPort_hdlcd__.interconnect();if(!controlPort_dmc__.interconnect.empty()) controlPort_dmc__.interconnect();if(!controlPort_dmc_phy__.interconnect.empty()) controlPort_dmc_phy__.interconnect();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::disconnect()
{{if(!controlPort_pvbusdecoder__.disconnect.empty()) controlPort_pvbusdecoder__.disconnect();if(!controlPort_coresight_mapper__.disconnect.empty()) controlPort_coresight_mapper__.disconnect();if(!controlPort_sram__.disconnect.empty()) controlPort_sram__.disconnect();if(!controlPort_vedcc__.disconnect.empty()) controlPort_vedcc__.disconnect();if(!controlPort_clockdivider__.disconnect.empty()) controlPort_clockdivider__.disconnect();if(!controlPort_clockCLCD__.disconnect.empty()) controlPort_clockCLCD__.disconnect();if(!controlPort_dram__.disconnect.empty()) controlPort_dram__.disconnect();if(!controlPort_dram_aliased__.disconnect.empty()) controlPort_dram_aliased__.disconnect();if(!controlPort_dram_limit_4__.disconnect.empty()) controlPort_dram_limit_4__.disconnect();if(!controlPort_dram_limit_8__.disconnect.empty()) controlPort_dram_limit_8__.disconnect();if(!controlPort_introuter__.disconnect.empty()) controlPort_introuter__.disconnect();if(!controlPort_secure_region__.disconnect.empty()) controlPort_secure_region__.disconnect();if(!controlPort_nonsecure_region__.disconnect.empty()) controlPort_nonsecure_region__.disconnect();if(!controlPort_securitydecoder__.disconnect.empty()) controlPort_securitydecoder__.disconnect();if(!controlPort_securepvbusdecoder__.disconnect.empty()) controlPort_securepvbusdecoder__.disconnect();if(!controlPort_secureRO__.disconnect.empty()) controlPort_secureRO__.disconnect();if(!controlPort_secureROloader__.disconnect.empty()) controlPort_secureROloader__.disconnect();if(!controlPort_secureSRAM__.disconnect.empty()) controlPort_secureSRAM__.disconnect();if(!controlPort_secureDRAM__.disconnect.empty()) controlPort_secureDRAM__.disconnect();if(!controlPort_hdlcd__.disconnect.empty()) controlPort_hdlcd__.disconnect();if(!controlPort_dmc__.disconnect.empty()) controlPort_dmc__.disconnect();if(!controlPort_dmc_phy__.disconnect.empty()) controlPort_dmc_phy__.disconnect();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::update()
{{if(!controlPort_pvbusdecoder__.update.empty()) controlPort_pvbusdecoder__.update();if(!controlPort_coresight_mapper__.update.empty()) controlPort_coresight_mapper__.update();if(!controlPort_sram__.update.empty()) controlPort_sram__.update();if(!controlPort_vedcc__.update.empty()) controlPort_vedcc__.update();if(!controlPort_clockdivider__.update.empty()) controlPort_clockdivider__.update();if(!controlPort_clockCLCD__.update.empty()) controlPort_clockCLCD__.update();if(!controlPort_dram__.update.empty()) controlPort_dram__.update();if(!controlPort_dram_aliased__.update.empty()) controlPort_dram_aliased__.update();if(!controlPort_dram_limit_4__.update.empty()) controlPort_dram_limit_4__.update();if(!controlPort_dram_limit_8__.update.empty()) controlPort_dram_limit_8__.update();if(!controlPort_introuter__.update.empty()) controlPort_introuter__.update();if(!controlPort_secure_region__.update.empty()) controlPort_secure_region__.update();if(!controlPort_nonsecure_region__.update.empty()) controlPort_nonsecure_region__.update();if(!controlPort_securitydecoder__.update.empty()) controlPort_securitydecoder__.update();if(!controlPort_securepvbusdecoder__.update.empty()) controlPort_securepvbusdecoder__.update();if(!controlPort_secureRO__.update.empty()) controlPort_secureRO__.update();if(!controlPort_secureROloader__.update.empty()) controlPort_secureROloader__.update();if(!controlPort_secureSRAM__.update.empty()) controlPort_secureSRAM__.update();if(!controlPort_secureDRAM__.update.empty()) controlPort_secureDRAM__.update();if(!controlPort_hdlcd__.update.empty()) controlPort_hdlcd__.update();if(!controlPort_dmc__.update.empty()) controlPort_dmc__.update();if(!controlPort_dmc_phy__.update.empty()) controlPort_dmc_phy__.update();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::communicate()
{{if(!controlPort_pvbusdecoder__.communicate.empty()) controlPort_pvbusdecoder__.communicate();if(!controlPort_coresight_mapper__.communicate.empty()) controlPort_coresight_mapper__.communicate();if(!controlPort_sram__.communicate.empty()) controlPort_sram__.communicate();if(!controlPort_vedcc__.communicate.empty()) controlPort_vedcc__.communicate();if(!controlPort_clockdivider__.communicate.empty()) controlPort_clockdivider__.communicate();if(!controlPort_clockCLCD__.communicate.empty()) controlPort_clockCLCD__.communicate();if(!controlPort_dram__.communicate.empty()) controlPort_dram__.communicate();if(!controlPort_dram_aliased__.communicate.empty()) controlPort_dram_aliased__.communicate();if(!controlPort_dram_limit_4__.communicate.empty()) controlPort_dram_limit_4__.communicate();if(!controlPort_dram_limit_8__.communicate.empty()) controlPort_dram_limit_8__.communicate();if(!controlPort_introuter__.communicate.empty()) controlPort_introuter__.communicate();if(!controlPort_secure_region__.communicate.empty()) controlPort_secure_region__.communicate();if(!controlPort_nonsecure_region__.communicate.empty()) controlPort_nonsecure_region__.communicate();if(!controlPort_securitydecoder__.communicate.empty()) controlPort_securitydecoder__.communicate();if(!controlPort_securepvbusdecoder__.communicate.empty()) controlPort_securepvbusdecoder__.communicate();if(!controlPort_secureRO__.communicate.empty()) controlPort_secureRO__.communicate();if(!controlPort_secureROloader__.communicate.empty()) controlPort_secureROloader__.communicate();if(!controlPort_secureSRAM__.communicate.empty()) controlPort_secureSRAM__.communicate();if(!controlPort_secureDRAM__.communicate.empty()) controlPort_secureDRAM__.communicate();if(!controlPort_hdlcd__.communicate.empty()) controlPort_hdlcd__.communicate();if(!controlPort_dmc__.communicate.empty()) controlPort_dmc__.communicate();if(!controlPort_dmc_phy__.communicate.empty()) controlPort_dmc_phy__.communicate();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::traceEndOfCycle()
{{if(!controlPort_pvbusdecoder__.traceEndOfCycle.empty()) controlPort_pvbusdecoder__.traceEndOfCycle();if(!controlPort_coresight_mapper__.traceEndOfCycle.empty()) controlPort_coresight_mapper__.traceEndOfCycle();if(!controlPort_sram__.traceEndOfCycle.empty()) controlPort_sram__.traceEndOfCycle();if(!controlPort_vedcc__.traceEndOfCycle.empty()) controlPort_vedcc__.traceEndOfCycle();if(!controlPort_clockdivider__.traceEndOfCycle.empty()) controlPort_clockdivider__.traceEndOfCycle();if(!controlPort_clockCLCD__.traceEndOfCycle.empty()) controlPort_clockCLCD__.traceEndOfCycle();if(!controlPort_dram__.traceEndOfCycle.empty()) controlPort_dram__.traceEndOfCycle();if(!controlPort_dram_aliased__.traceEndOfCycle.empty()) controlPort_dram_aliased__.traceEndOfCycle();if(!controlPort_dram_limit_4__.traceEndOfCycle.empty()) controlPort_dram_limit_4__.traceEndOfCycle();if(!controlPort_dram_limit_8__.traceEndOfCycle.empty()) controlPort_dram_limit_8__.traceEndOfCycle();if(!controlPort_introuter__.traceEndOfCycle.empty()) controlPort_introuter__.traceEndOfCycle();if(!controlPort_secure_region__.traceEndOfCycle.empty()) controlPort_secure_region__.traceEndOfCycle();if(!controlPort_nonsecure_region__.traceEndOfCycle.empty()) controlPort_nonsecure_region__.traceEndOfCycle();if(!controlPort_securitydecoder__.traceEndOfCycle.empty()) controlPort_securitydecoder__.traceEndOfCycle();if(!controlPort_securepvbusdecoder__.traceEndOfCycle.empty()) controlPort_securepvbusdecoder__.traceEndOfCycle();if(!controlPort_secureRO__.traceEndOfCycle.empty()) controlPort_secureRO__.traceEndOfCycle();if(!controlPort_secureROloader__.traceEndOfCycle.empty()) controlPort_secureROloader__.traceEndOfCycle();if(!controlPort_secureSRAM__.traceEndOfCycle.empty()) controlPort_secureSRAM__.traceEndOfCycle();if(!controlPort_secureDRAM__.traceEndOfCycle.empty()) controlPort_secureDRAM__.traceEndOfCycle();if(!controlPort_hdlcd__.traceEndOfCycle.empty()) controlPort_hdlcd__.traceEndOfCycle();if(!controlPort_dmc__.traceEndOfCycle.empty()) controlPort_dmc__.traceEndOfCycle();if(!controlPort_dmc_phy__.traceEndOfCycle.empty()) controlPort_dmc_phy__.traceEndOfCycle();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::loadApplicationFile(const std::string& filename)
{{if(!controlPort_pvbusdecoder__.loadApplicationFile.empty()) controlPort_pvbusdecoder__.loadApplicationFile(filename);if(!controlPort_coresight_mapper__.loadApplicationFile.empty()) controlPort_coresight_mapper__.loadApplicationFile(filename);if(!controlPort_sram__.loadApplicationFile.empty()) controlPort_sram__.loadApplicationFile(filename);if(!controlPort_vedcc__.loadApplicationFile.empty()) controlPort_vedcc__.loadApplicationFile(filename);if(!controlPort_clockdivider__.loadApplicationFile.empty()) controlPort_clockdivider__.loadApplicationFile(filename);if(!controlPort_clockCLCD__.loadApplicationFile.empty()) controlPort_clockCLCD__.loadApplicationFile(filename);if(!controlPort_dram__.loadApplicationFile.empty()) controlPort_dram__.loadApplicationFile(filename);if(!controlPort_dram_aliased__.loadApplicationFile.empty()) controlPort_dram_aliased__.loadApplicationFile(filename);if(!controlPort_dram_limit_4__.loadApplicationFile.empty()) controlPort_dram_limit_4__.loadApplicationFile(filename);if(!controlPort_dram_limit_8__.loadApplicationFile.empty()) controlPort_dram_limit_8__.loadApplicationFile(filename);if(!controlPort_introuter__.loadApplicationFile.empty()) controlPort_introuter__.loadApplicationFile(filename);if(!controlPort_secure_region__.loadApplicationFile.empty()) controlPort_secure_region__.loadApplicationFile(filename);if(!controlPort_nonsecure_region__.loadApplicationFile.empty()) controlPort_nonsecure_region__.loadApplicationFile(filename);if(!controlPort_securitydecoder__.loadApplicationFile.empty()) controlPort_securitydecoder__.loadApplicationFile(filename);if(!controlPort_securepvbusdecoder__.loadApplicationFile.empty()) controlPort_securepvbusdecoder__.loadApplicationFile(filename);if(!controlPort_secureRO__.loadApplicationFile.empty()) controlPort_secureRO__.loadApplicationFile(filename);if(!controlPort_secureROloader__.loadApplicationFile.empty()) controlPort_secureROloader__.loadApplicationFile(filename);if(!controlPort_secureSRAM__.loadApplicationFile.empty()) controlPort_secureSRAM__.loadApplicationFile(filename);if(!controlPort_secureDRAM__.loadApplicationFile.empty()) controlPort_secureDRAM__.loadApplicationFile(filename);if(!controlPort_hdlcd__.loadApplicationFile.empty()) controlPort_hdlcd__.loadApplicationFile(filename);if(!controlPort_dmc__.loadApplicationFile.empty()) controlPort_dmc__.loadApplicationFile(filename);if(!controlPort_dmc_phy__.loadApplicationFile.empty()) controlPort_dmc_phy__.loadApplicationFile(filename);};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::terminate()
{{if(!controlPort_pvbusdecoder__.terminate.empty()) controlPort_pvbusdecoder__.terminate();if(!controlPort_coresight_mapper__.terminate.empty()) controlPort_coresight_mapper__.terminate();if(!controlPort_sram__.terminate.empty()) controlPort_sram__.terminate();if(!controlPort_vedcc__.terminate.empty()) controlPort_vedcc__.terminate();if(!controlPort_clockdivider__.terminate.empty()) controlPort_clockdivider__.terminate();if(!controlPort_clockCLCD__.terminate.empty()) controlPort_clockCLCD__.terminate();if(!controlPort_dram__.terminate.empty()) controlPort_dram__.terminate();if(!controlPort_dram_aliased__.terminate.empty()) controlPort_dram_aliased__.terminate();if(!controlPort_dram_limit_4__.terminate.empty()) controlPort_dram_limit_4__.terminate();if(!controlPort_dram_limit_8__.terminate.empty()) controlPort_dram_limit_8__.terminate();if(!controlPort_introuter__.terminate.empty()) controlPort_introuter__.terminate();if(!controlPort_secure_region__.terminate.empty()) controlPort_secure_region__.terminate();if(!controlPort_nonsecure_region__.terminate.empty()) controlPort_nonsecure_region__.terminate();if(!controlPort_securitydecoder__.terminate.empty()) controlPort_securitydecoder__.terminate();if(!controlPort_securepvbusdecoder__.terminate.empty()) controlPort_securepvbusdecoder__.terminate();if(!controlPort_secureRO__.terminate.empty()) controlPort_secureRO__.terminate();if(!controlPort_secureROloader__.terminate.empty()) controlPort_secureROloader__.terminate();if(!controlPort_secureSRAM__.terminate.empty()) controlPort_secureSRAM__.terminate();if(!controlPort_secureDRAM__.terminate.empty()) controlPort_secureDRAM__.terminate();if(!controlPort_hdlcd__.terminate.empty()) controlPort_hdlcd__.terminate();if(!controlPort_dmc__.terminate.empty()) controlPort_dmc__.terminate();if(!controlPort_dmc_phy__.terminate.empty()) controlPort_dmc_phy__.terminate();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::reset(int level)
{{if(!controlPort_pvbusdecoder__.reset.empty()) controlPort_pvbusdecoder__.reset(level);if(!controlPort_coresight_mapper__.reset.empty()) controlPort_coresight_mapper__.reset(level);if(!controlPort_sram__.reset.empty()) controlPort_sram__.reset(level);if(!controlPort_vedcc__.reset.empty()) controlPort_vedcc__.reset(level);if(!controlPort_clockdivider__.reset.empty()) controlPort_clockdivider__.reset(level);if(!controlPort_clockCLCD__.reset.empty()) controlPort_clockCLCD__.reset(level);if(!controlPort_dram__.reset.empty()) controlPort_dram__.reset(level);if(!controlPort_dram_aliased__.reset.empty()) controlPort_dram_aliased__.reset(level);if(!controlPort_dram_limit_4__.reset.empty()) controlPort_dram_limit_4__.reset(level);if(!controlPort_dram_limit_8__.reset.empty()) controlPort_dram_limit_8__.reset(level);if(!controlPort_introuter__.reset.empty()) controlPort_introuter__.reset(level);if(!controlPort_secure_region__.reset.empty()) controlPort_secure_region__.reset(level);if(!controlPort_nonsecure_region__.reset.empty()) controlPort_nonsecure_region__.reset(level);if(!controlPort_securitydecoder__.reset.empty()) controlPort_securitydecoder__.reset(level);if(!controlPort_securepvbusdecoder__.reset.empty()) controlPort_securepvbusdecoder__.reset(level);if(!controlPort_secureRO__.reset.empty()) controlPort_secureRO__.reset(level);if(!controlPort_secureROloader__.reset.empty()) controlPort_secureROloader__.reset(level);if(!controlPort_secureSRAM__.reset.empty()) controlPort_secureSRAM__.reset(level);if(!controlPort_secureDRAM__.reset.empty()) controlPort_secureDRAM__.reset(level);if(!controlPort_hdlcd__.reset.empty()) controlPort_hdlcd__.reset(level);if(!controlPort_dmc__.reset.empty()) controlPort_dmc__.reset(level);if(!controlPort_dmc_phy__.reset.empty()) controlPort_dmc_phy__.reset(level);};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEDaughterBoard::save(MxODataStream& os)
{{if(!controlPort_pvbusdecoder__.save.empty()) controlPort_pvbusdecoder__.save(os);if(!controlPort_coresight_mapper__.save.empty()) controlPort_coresight_mapper__.save(os);if(!controlPort_sram__.save.empty()) controlPort_sram__.save(os);if(!controlPort_vedcc__.save.empty()) controlPort_vedcc__.save(os);if(!controlPort_clockdivider__.save.empty()) controlPort_clockdivider__.save(os);if(!controlPort_clockCLCD__.save.empty()) controlPort_clockCLCD__.save(os);if(!controlPort_dram__.save.empty()) controlPort_dram__.save(os);if(!controlPort_dram_aliased__.save.empty()) controlPort_dram_aliased__.save(os);if(!controlPort_dram_limit_4__.save.empty()) controlPort_dram_limit_4__.save(os);if(!controlPort_dram_limit_8__.save.empty()) controlPort_dram_limit_8__.save(os);if(!controlPort_introuter__.save.empty()) controlPort_introuter__.save(os);if(!controlPort_secure_region__.save.empty()) controlPort_secure_region__.save(os);if(!controlPort_nonsecure_region__.save.empty()) controlPort_nonsecure_region__.save(os);if(!controlPort_securitydecoder__.save.empty()) controlPort_securitydecoder__.save(os);if(!controlPort_securepvbusdecoder__.save.empty()) controlPort_securepvbusdecoder__.save(os);if(!controlPort_secureRO__.save.empty()) controlPort_secureRO__.save(os);if(!controlPort_secureROloader__.save.empty()) controlPort_secureROloader__.save(os);if(!controlPort_secureSRAM__.save.empty()) controlPort_secureSRAM__.save(os);if(!controlPort_secureDRAM__.save.empty()) controlPort_secureDRAM__.save(os);if(!controlPort_hdlcd__.save.empty()) controlPort_hdlcd__.save(os);if(!controlPort_dmc__.save.empty()) controlPort_dmc__.save(os);if(!controlPort_dmc_phy__.save.empty()) controlPort_dmc_phy__.save(os);};return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEDaughterBoard::restore(MxIDataStream& is)
{{if(!controlPort_pvbusdecoder__.restore.empty()) controlPort_pvbusdecoder__.restore(is);if(!controlPort_coresight_mapper__.restore.empty()) controlPort_coresight_mapper__.restore(is);if(!controlPort_sram__.restore.empty()) controlPort_sram__.restore(is);if(!controlPort_vedcc__.restore.empty()) controlPort_vedcc__.restore(is);if(!controlPort_clockdivider__.restore.empty()) controlPort_clockdivider__.restore(is);if(!controlPort_clockCLCD__.restore.empty()) controlPort_clockCLCD__.restore(is);if(!controlPort_dram__.restore.empty()) controlPort_dram__.restore(is);if(!controlPort_dram_aliased__.restore.empty()) controlPort_dram_aliased__.restore(is);if(!controlPort_dram_limit_4__.restore.empty()) controlPort_dram_limit_4__.restore(is);if(!controlPort_dram_limit_8__.restore.empty()) controlPort_dram_limit_8__.restore(is);if(!controlPort_introuter__.restore.empty()) controlPort_introuter__.restore(is);if(!controlPort_secure_region__.restore.empty()) controlPort_secure_region__.restore(is);if(!controlPort_nonsecure_region__.restore.empty()) controlPort_nonsecure_region__.restore(is);if(!controlPort_securitydecoder__.restore.empty()) controlPort_securitydecoder__.restore(is);if(!controlPort_securepvbusdecoder__.restore.empty()) controlPort_securepvbusdecoder__.restore(is);if(!controlPort_secureRO__.restore.empty()) controlPort_secureRO__.restore(is);if(!controlPort_secureROloader__.restore.empty()) controlPort_secureROloader__.restore(is);if(!controlPort_secureSRAM__.restore.empty()) controlPort_secureSRAM__.restore(is);if(!controlPort_secureDRAM__.restore.empty()) controlPort_secureDRAM__.restore(is);if(!controlPort_hdlcd__.restore.empty()) controlPort_hdlcd__.restore(is);if(!controlPort_dmc__.restore.empty()) controlPort_dmc__.restore(is);if(!controlPort_dmc_phy__.restore.empty()) controlPort_dmc_phy__.restore(is);};return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDaughterBoard::step()
{{if(!controlPort_pvbusdecoder__.step.empty()) controlPort_pvbusdecoder__.step();if(!controlPort_coresight_mapper__.step.empty()) controlPort_coresight_mapper__.step();if(!controlPort_sram__.step.empty()) controlPort_sram__.step();if(!controlPort_vedcc__.step.empty()) controlPort_vedcc__.step();if(!controlPort_clockdivider__.step.empty()) controlPort_clockdivider__.step();if(!controlPort_clockCLCD__.step.empty()) controlPort_clockCLCD__.step();if(!controlPort_dram__.step.empty()) controlPort_dram__.step();if(!controlPort_dram_aliased__.step.empty()) controlPort_dram_aliased__.step();if(!controlPort_dram_limit_4__.step.empty()) controlPort_dram_limit_4__.step();if(!controlPort_dram_limit_8__.step.empty()) controlPort_dram_limit_8__.step();if(!controlPort_introuter__.step.empty()) controlPort_introuter__.step();if(!controlPort_secure_region__.step.empty()) controlPort_secure_region__.step();if(!controlPort_nonsecure_region__.step.empty()) controlPort_nonsecure_region__.step();if(!controlPort_securitydecoder__.step.empty()) controlPort_securitydecoder__.step();if(!controlPort_securepvbusdecoder__.step.empty()) controlPort_securepvbusdecoder__.step();if(!controlPort_secureRO__.step.empty()) controlPort_secureRO__.step();if(!controlPort_secureROloader__.step.empty()) controlPort_secureROloader__.step();if(!controlPort_secureSRAM__.step.empty()) controlPort_secureSRAM__.step();if(!controlPort_secureDRAM__.step.empty()) controlPort_secureDRAM__.step();if(!controlPort_hdlcd__.step.empty()) controlPort_hdlcd__.step();if(!controlPort_dmc__.step.empty()) controlPort_dmc__.step();if(!controlPort_dmc_phy__.step.empty()) controlPort_dmc_phy__.step();};
}
}

#line 167 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDaughterBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { unsigned 
Component__VEDaughterBoard::abstract_port__coresight_mapper_control__remap(pv::RemapRequest& req_)
{
 
 
 
 return 0;
 
}
}

#line 1425 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__VEDaughterBoard
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__VEDaughterBoard::Component__VEDaughterBoard(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,dram_size(GetParameterValue(params, "dram_size", MxS64CONST(0x4), MxS64CONST(0x2), MxS64CONST(0x8)))
	,dram_alias(!!GetParameterValue(params, "dram_alias", MxS64CONST(0x1), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,secure_memory(!!GetParameterValue(params, "secure_memory", MxS64CONST(0x0), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))


	,cadiParameterProxy_sram_of_RAMDevice_to_VEDaughterBoard__(0)
	,cadiParameterProxy_clockdivider_of_ClockDivider_to_VEDaughterBoard__(0)
	,cadiParameterProxy_clockCLCD_of_ClockDivider_to_VEDaughterBoard__(0)
	,cadiParameterProxy_dram_of_RAMDevice_to_VEDaughterBoard__(0)
	,cadiParameterProxy_secureRO_of_IntelStrataFlashJ3_to_VEDaughterBoard__(0)
	,cadiParameterProxy_secureSRAM_of_RAMDevice_to_VEDaughterBoard__(0)
	,cadiParameterProxy_secureDRAM_of_RAMDevice_to_VEDaughterBoard__(0)
	,cadiParameterProxy_dmc_of_RAMDevice_to_VEDaughterBoard__(0)
	,cadiParameterProxy_dmc_phy_of_RAMDevice_to_VEDaughterBoard__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "System";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Daughtercard, inspired by the ARM Versatile Express development platform.";
	properties__["documentation_file"] = "";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = VEDaughterBoard_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *VEDCC_factory = VEDCC_GetFactory();
		sg::ComponentFactory *VEInterruptMapper_factory = VEInterruptMapper_GetFactory();
		sg::ComponentFactory *ClockDivider_factory = ClockDivider_GetFactory();
		sg::ComponentFactory *PVBusDecoder_factory = PVBusDecoder_GetFactory();
		sg::ComponentFactory *PVBusMapper_factory = PVBusMapper_GetFactory();
		sg::ComponentFactory *TZSwitch_factory = TZSwitch_GetFactory();
		sg::ComponentFactory *FlashLoader_factory = FlashLoader_GetFactory();
		sg::ComponentFactory *PL370_HDLCD_factory = PL370_HDLCD_GetFactory();
		sg::ComponentFactory *RAMDevice_factory = RAMDevice_GetFactory();
		sg::ComponentFactory *IntelStrataFlashJ3_factory = IntelStrataFlashJ3_GetFactory();
		{
			sg::Params params_pvbusdecoder__ = params.getParamsFor("pvbusdecoder");
			add(pvbusdecoder = PVBusDecoder_factory->instantiate("pvbusdecoder", simulationContext, params_pvbusdecoder__));
		}
		{
			sg::Params params_coresight_mapper__ = params.getParamsFor("coresight_mapper");
			add(coresight_mapper = PVBusMapper_factory->instantiate("coresight_mapper", simulationContext, params_coresight_mapper__));
		}
		{
			sg::Params params_sram__ = params.getParamsFor("sram");
			params_sram__["size"] = MxU64CONST(0x0000000000010000);
			sram = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("sram", simulationContext, params_sram__));
			assert(sram);
			add(sram);
		}
		{
			sg::Params params_vedcc__ = params.getParamsFor("vedcc");
			vedcc = dynamic_cast<Component__VEDCC*>(VEDCC_factory->instantiate("vedcc", simulationContext, params_vedcc__));
			assert(vedcc);
			add(vedcc);
		}
		{
			sg::Params params_clockdivider__ = params.getParamsFor("clockdivider");
			params_clockdivider__["mul"] = MxU64CONST(0x0000000005F5E100);
			add(clockdivider = ClockDivider_factory->instantiate("clockdivider", simulationContext, params_clockdivider__));
		}
		{
			sg::Params params_clockCLCD__ = params.getParamsFor("clockCLCD");
			params_clockCLCD__["mul"] = MxU64CONST(0x00000000000186A0);
			add(clockCLCD = ClockDivider_factory->instantiate("clockCLCD", simulationContext, params_clockCLCD__));
		}
		{
			sg::Params params_dram__ = params.getParamsFor("dram");
			params_dram__["size"] = MxU64CONST(0x0000000200000000);
			dram = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("dram", simulationContext, params_dram__));
			assert(dram);
			add(dram);
		}
		{
			sg::Params params_dram_aliased__ = params.getParamsFor("dram_aliased");
			dram_aliased = dynamic_cast<Component__TZSwitch*>(TZSwitch_factory->instantiate("dram_aliased", simulationContext, params_dram_aliased__));
			assert(dram_aliased);
			add(dram_aliased);
		}
		{
			sg::Params params_dram_limit_4__ = params.getParamsFor("dram_limit_4");
			dram_limit_4 = dynamic_cast<Component__TZSwitch*>(TZSwitch_factory->instantiate("dram_limit_4", simulationContext, params_dram_limit_4__));
			assert(dram_limit_4);
			add(dram_limit_4);
		}
		{
			sg::Params params_dram_limit_8__ = params.getParamsFor("dram_limit_8");
			dram_limit_8 = dynamic_cast<Component__TZSwitch*>(TZSwitch_factory->instantiate("dram_limit_8", simulationContext, params_dram_limit_8__));
			assert(dram_limit_8);
			add(dram_limit_8);
		}
		{
			sg::Params params_introuter__ = params.getParamsFor("introuter");
			introuter = dynamic_cast<Component__VEInterruptMapper*>(VEInterruptMapper_factory->instantiate("introuter", simulationContext, params_introuter__));
			assert(introuter);
			add(introuter);
		}
		{
			sg::Params params_secure_region__ = params.getParamsFor("secure_region");
			secure_region = dynamic_cast<Component__TZSwitch*>(TZSwitch_factory->instantiate("secure_region", simulationContext, params_secure_region__));
			assert(secure_region);
			add(secure_region);
		}
		{
			sg::Params params_nonsecure_region__ = params.getParamsFor("nonsecure_region");
			nonsecure_region = dynamic_cast<Component__TZSwitch*>(TZSwitch_factory->instantiate("nonsecure_region", simulationContext, params_nonsecure_region__));
			assert(nonsecure_region);
			add(nonsecure_region);
		}
		{
			sg::Params params_securitydecoder__ = params.getParamsFor("securitydecoder");
			add(securitydecoder = PVBusDecoder_factory->instantiate("securitydecoder", simulationContext, params_securitydecoder__));
		}
		{
			sg::Params params_securepvbusdecoder__ = params.getParamsFor("securepvbusdecoder");
			add(securepvbusdecoder = PVBusDecoder_factory->instantiate("securepvbusdecoder", simulationContext, params_securepvbusdecoder__));
		}
		{
			sg::Params params_secureRO__ = params.getParamsFor("secureRO");
			params_secureRO__["size"] = MxU64CONST(0x0000000004000000);
			secureRO = dynamic_cast<Component__IntelStrataFlashJ3*>(IntelStrataFlashJ3_factory->instantiate("secureRO", simulationContext, params_secureRO__));
			assert(secureRO);
			add(secureRO);
		}
		{
			sg::Params params_secureROloader__ = params.getParamsFor("secureROloader");
			secureROloader = dynamic_cast<Component__FlashLoader*>(FlashLoader_factory->instantiate("secureROloader", simulationContext, params_secureROloader__));
			assert(secureROloader);
			add(secureROloader);
		}
		{
			sg::Params params_secureSRAM__ = params.getParamsFor("secureSRAM");
			params_secureSRAM__["size"] = MxU64CONST(0x0000000000020000);
			secureSRAM = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("secureSRAM", simulationContext, params_secureSRAM__));
			assert(secureSRAM);
			add(secureSRAM);
		}
		{
			sg::Params params_secureDRAM__ = params.getParamsFor("secureDRAM");
			params_secureDRAM__["size"] = MxU64CONST(0x0000000002000000);
			secureDRAM = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("secureDRAM", simulationContext, params_secureDRAM__));
			assert(secureDRAM);
			add(secureDRAM);
		}
		{
			sg::Params params_hdlcd__ = params.getParamsFor("hdlcd");
			hdlcd = dynamic_cast<Component__PL370_HDLCD*>(PL370_HDLCD_factory->instantiate("hdlcd", simulationContext, params_hdlcd__));
			assert(hdlcd);
			add(hdlcd);
		}
		{
			sg::Params params_dmc__ = params.getParamsFor("dmc");
			params_dmc__["size"] = MxU64CONST(0x0000000000001000);
			dmc = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("dmc", simulationContext, params_dmc__));
			assert(dmc);
			add(dmc);
		}
		{
			sg::Params params_dmc_phy__ = params.getParamsFor("dmc_phy");
			params_dmc_phy__["size"] = MxU64CONST(0x0000000000001000);
			dmc_phy = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("dmc_phy", simulationContext, params_dmc_phy__));
			assert(dmc_phy);
			add(dmc_phy);
		}
		VEDCC_factory->dereference();
		VEInterruptMapper_factory->dereference();
		ClockDivider_factory->dereference();
		PVBusDecoder_factory->dereference();
		PVBusMapper_factory->dereference();
		TZSwitch_factory->dereference();
		FlashLoader_factory->dereference();
		PL370_HDLCD_factory->dereference();
		RAMDevice_factory->dereference();
		IntelStrataFlashJ3_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__VEDaughterBoard::control_port__configure, this);
    bind_method(control_port, init, &Component__VEDaughterBoard::init, this);
    bind_method(control_port, interconnect, &Component__VEDaughterBoard::interconnect, this);
//  bind_method(control_port, postConnect, &Component__VEDaughterBoard::postConnect, this);
    bind_method(control_port, reset, &Component__VEDaughterBoard::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__VEDaughterBoard::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__VEDaughterBoard::disconnect, this);
    bind_method(control_port, terminate, &Component__VEDaughterBoard::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__VEDaughterBoard::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__VEDaughterBoard::refresh, this);
    bind_method(control_port, step, &Component__VEDaughterBoard::step, this);
    bind_method(control_port, update, &Component__VEDaughterBoard::update, this);
    bind_method(control_port, communicate, &Component__VEDaughterBoard::communicate, this);
    bind_method(control_port, getProperty, &Component__VEDaughterBoard::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__VEDaughterBoard::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__VEDaughterBoard::control_port__bypass, this);
    bind_method(control_port, run, &Component__VEDaughterBoard::control_port__run, this);
    bind_method(control_port, stop, &Component__VEDaughterBoard::control_port__stop, this);
    bind_method(control_port, idle, &Component__VEDaughterBoard::control_port__idle, this);
    bind_method(control_port, quit, &Component__VEDaughterBoard::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__VEDaughterBoard::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__VEDaughterBoard::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__VEDaughterBoard::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__VEDaughterBoard::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__VEDaughterBoard::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__VEDaughterBoard::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__VEDaughterBoard::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__VEDaughterBoard::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_pvbusdecoder__.connectTo(pvbusdecoder->findPort("$control"));
	controlPort_coresight_mapper__.connectTo(coresight_mapper->findPort("$control"));
	controlPort_sram__.connectTo(sram->findPort("$control"));
	controlPort_vedcc__.connectTo(vedcc->findPort("$control"));
	controlPort_clockdivider__.connectTo(clockdivider->findPort("$control"));
	controlPort_clockCLCD__.connectTo(clockCLCD->findPort("$control"));
	controlPort_dram__.connectTo(dram->findPort("$control"));
	controlPort_dram_aliased__.connectTo(dram_aliased->findPort("$control"));
	controlPort_dram_limit_4__.connectTo(dram_limit_4->findPort("$control"));
	controlPort_dram_limit_8__.connectTo(dram_limit_8->findPort("$control"));
	controlPort_introuter__.connectTo(introuter->findPort("$control"));
	controlPort_secure_region__.connectTo(secure_region->findPort("$control"));
	controlPort_nonsecure_region__.connectTo(nonsecure_region->findPort("$control"));
	controlPort_securitydecoder__.connectTo(securitydecoder->findPort("$control"));
	controlPort_securepvbusdecoder__.connectTo(securepvbusdecoder->findPort("$control"));
	controlPort_secureRO__.connectTo(secureRO->findPort("$control"));
	controlPort_secureROloader__.connectTo(secureROloader->findPort("$control"));
	controlPort_secureSRAM__.connectTo(secureSRAM->findPort("$control"));
	controlPort_secureDRAM__.connectTo(secureDRAM->findPort("$control"));
	controlPort_hdlcd__.connectTo(hdlcd->findPort("$control"));
	controlPort_dmc__.connectTo(dmc->findPort("$control"));
	controlPort_dmc_phy__.connectTo(dmc_phy->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(coresight_mapper_control, remap, &Component__VEDaughterBoard::abstract_port__coresight_mapper_control__remap, this);


    // add abstract ports
	coresight_mapper_control.SetName__("coresight_mapper_control");
	publishSlavePort("clk_in", clk_in);
	clk_in.SetName__("clk_in");
	publishSlavePortArray("interrupts", interrupts, 48);
	{for(int i = 0; i < 48; ++i) interrupts[i].SetName__("interrupts");}
	publishMasterPortArray("smb_cs", smb_cs, 8);
	{for(int i = 0; i < 8; ++i) smb_cs[i].SetName__("smb_cs");}
	publishMasterPort("mmb", mmb);
	mmb.SetName__("mmb");
	publishSlavePort("CB", CB);
	CB.SetName__("CB");
	publishMasterPort("cpu_clk", cpu_clk);
	cpu_clk.SetName__("cpu_clk");
	publishSlavePort("cpu_pvbus", cpu_pvbus);
	cpu_pvbus.SetName__("cpu_pvbus");
	publishMasterPort("cpu_memorymapped_debug", cpu_memorymapped_debug);
	cpu_memorymapped_debug.SetName__("cpu_memorymapped_debug");
	publishSlavePort("clcd_pvbus", clcd_pvbus);
	clcd_pvbus.SetName__("clcd_pvbus");
	publishMasterPortArray("cpu_irqs", cpu_irqs, 224);
	{for(int i = 0; i < 224; ++i) cpu_irqs[i].SetName__("cpu_irqs");}


    // wire up static connection map
	clk_in.connectTo(clockdivider->findPort("clk_in"));
	clk_in.connectTo(clockCLCD->findPort("clk_in"));
	clockdivider->findPort("clk_out").connectTo(cpu_clk);
	clockCLCD->findPort("clk_out").connectTo(hdlcd->findPort("clk_in"));
	cpu_pvbus.connectTo(securitydecoder->findPort("pvbus_s"));
	FVP_VE_Cortex_A15x1__Builtin__AddressablePortProtocol tmp__; // temporary addressable port control port
	tmp__.setName("tmp_addressmap_control");
	tmp__.setParent(this);	tmp__.connectTo(securitydecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00000000), MxU64CONST(0x07FFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x07FFFFFF))->connectTo(secure_region->findPort("pvbus_input"));
	tmp__.disconnectFrom(securitydecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(securitydecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x08000000), MxU64CONST(0x7DFFFFFF), MxU64CONST(0x08000000), MxU64CONST(0x7DFFFFFF))->connectTo(nonsecure_region->findPort("pvbus_input"));
	tmp__.disconnectFrom(securitydecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(securitydecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x7E000000), MxU64CONST(0x7FFFFFFF), MxU64CONST(0x7E000000), MxU64CONST(0x7FFFFFFF))->connectTo(secure_region->findPort("pvbus_input"));
	tmp__.disconnectFrom(securitydecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(securitydecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x80000000), MxU64CONST(0xFFFFFFFFFF), MxU64CONST(0x80000000), MxU64CONST(0xFFFFFFFFFF))->connectTo(nonsecure_region->findPort("pvbus_input"));
	tmp__.disconnectFrom(securitydecoder->findPort("pvbus_m_range"));
	secure_region->findPort("pvbus_port_a").connectTo(pvbusdecoder->findPort("pvbus_s"));
	secure_region->findPort("pvbus_port_b").connectTo(securepvbusdecoder->findPort("pvbus_s"));
	nonsecure_region->findPort("pvbus_port_a").connectTo(pvbusdecoder->findPort("pvbus_s"));
	clcd_pvbus.connectTo(pvbusdecoder->findPort("pvbus_s"));
	hdlcd->findPort("display").connectTo(mmb);
	for (MxU32 i__ = 0; i__ < 48; ++i__)
	{
	interrupts[i__].connectTo(introuter->findPort("irq_in", i__));

	}
	for (MxU32 i__ = 0; i__ < 224; ++i__)
	{
	introuter->findPort("irq_out", i__).connectTo(cpu_irqs[i__]);

	}
	hdlcd->findPort("intr").connectTo(cpu_irqs[85]);
	hdlcd->findPort("pvbus_m").connectTo(pvbusdecoder->findPort("pvbus_s"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x80000000), MxU64CONST(0xFFFFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x7FFFFFFF))->connectTo(dram->findPort("pvbus"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x800000000), MxU64CONST(0x87FFFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x7FFFFFFF))->connectTo(dram_aliased->findPort("pvbus_input"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x880000000), MxU64CONST(0x8FFFFFFFF), MxU64CONST(0x80000000), MxU64CONST(0xFFFFFFFF))->connectTo(dram_limit_4->findPort("pvbus_input"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x900000000), MxU64CONST(0x9FFFFFFFF), MxU64CONST(0x100000000), MxU64CONST(0x1FFFFFFFF))->connectTo(dram_limit_8->findPort("pvbus_input"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x8000000000), MxU64CONST(0x807FFFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x7FFFFFFF))->connectTo(dram_aliased->findPort("pvbus_input"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x8080000000), MxU64CONST(0x80FFFFFFFF), MxU64CONST(0x80000000), MxU64CONST(0xFFFFFFFF))->connectTo(dram_limit_4->findPort("pvbus_input"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x8100000000), MxU64CONST(0x81FFFFFFFF), MxU64CONST(0x100000000), MxU64CONST(0x1FFFFFFFF))->connectTo(dram_limit_8->findPort("pvbus_input"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	dram_aliased->findPort("pvbus_port_a").connectTo(dram->findPort("pvbus"));
	dram_limit_4->findPort("pvbus_port_a").connectTo(dram->findPort("pvbus"));
	dram_limit_8->findPort("pvbus_port_a").connectTo(dram->findPort("pvbus"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x2E000000), MxU64CONST(0x2E00FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(sram->findPort("pvbus"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	CB.connectTo(vedcc->findPort("CB"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF))->connectTo(smb_cs[0]);
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x08000000), MxU64CONST(0x0BFFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF))->connectTo(smb_cs[0]);
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x0C000000), MxU64CONST(0x0FFFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF))->connectTo(smb_cs[4]);
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x10000000), MxU64CONST(0x13FFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF))->connectTo(smb_cs[5]);
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x14000000), MxU64CONST(0x17FFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF))->connectTo(smb_cs[1]);
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x18000000), MxU64CONST(0x1BFFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF))->connectTo(smb_cs[2]);
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x1C000000), MxU64CONST(0x1FFFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF))->connectTo(smb_cs[3]);
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x22000000), MxU64CONST(0x223FFFFF), MxU64CONST(0x00000000), MxU64CONST(0x003FFFFF))->connectTo(coresight_mapper->findPort("pvbus_s"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x2B000000), MxU64CONST(0x2B00FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(hdlcd->findPort("pvbus"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x2B0A0000), MxU64CONST(0x2B0AFFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(dmc->findPort("pvbus"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(securepvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x03FFFFFF))->connectTo(secureRO->findPort("pvbus"));
	tmp__.disconnectFrom(securepvbusdecoder->findPort("pvbus_m_range"));
	secureROloader->findPort("flash_device0").connectTo(secureRO->findPort("flashloader"));
	tmp__.connectTo(securepvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x04000000), MxU64CONST(0x0401FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0001FFFF))->connectTo(secureSRAM->findPort("pvbus"));
	tmp__.disconnectFrom(securepvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(securepvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x7E000000), MxU64CONST(0x7FFFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x01FFFFFF))->connectTo(secureDRAM->findPort("pvbus"));
	tmp__.disconnectFrom(securepvbusdecoder->findPort("pvbus_m_range"));
	tmp__.connectTo(pvbusdecoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x7FEF0000), MxU64CONST(0x7FEFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(dmc_phy->findPort("pvbus"));
	tmp__.disconnectFrom(pvbusdecoder->findPort("pvbus_m_range"));
	coresight_mapper->findPort("control").connectTo(coresight_mapper_control);
	coresight_mapper->findPort("pvbus_m", 0).connectTo(cpu_memorymapped_debug);


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__VEDaughterBoard::~Component__VEDaughterBoard()
{
}

void Component__VEDaughterBoard::control_port__configure(const sg::Params& params)
{
	if(controlPort_pvbusdecoder__.configure.implemented()) controlPort_pvbusdecoder__.configure(params.getParamsFor("pvbusdecoder"));
	if(controlPort_coresight_mapper__.configure.implemented()) controlPort_coresight_mapper__.configure(params.getParamsFor("coresight_mapper"));
	if(controlPort_sram__.configure.implemented()) controlPort_sram__.configure(params.getParamsFor("sram"));
	if(controlPort_vedcc__.configure.implemented()) controlPort_vedcc__.configure(params.getParamsFor("vedcc"));
	if(controlPort_clockdivider__.configure.implemented()) controlPort_clockdivider__.configure(params.getParamsFor("clockdivider"));
	if(controlPort_clockCLCD__.configure.implemented()) controlPort_clockCLCD__.configure(params.getParamsFor("clockCLCD"));
	if(controlPort_dram__.configure.implemented()) controlPort_dram__.configure(params.getParamsFor("dram"));
	if(controlPort_dram_aliased__.configure.implemented()) controlPort_dram_aliased__.configure(params.getParamsFor("dram_aliased"));
	if(controlPort_dram_limit_4__.configure.implemented()) controlPort_dram_limit_4__.configure(params.getParamsFor("dram_limit_4"));
	if(controlPort_dram_limit_8__.configure.implemented()) controlPort_dram_limit_8__.configure(params.getParamsFor("dram_limit_8"));
	if(controlPort_introuter__.configure.implemented()) controlPort_introuter__.configure(params.getParamsFor("introuter"));
	if(controlPort_secure_region__.configure.implemented()) controlPort_secure_region__.configure(params.getParamsFor("secure_region"));
	if(controlPort_nonsecure_region__.configure.implemented()) controlPort_nonsecure_region__.configure(params.getParamsFor("nonsecure_region"));
	if(controlPort_securitydecoder__.configure.implemented()) controlPort_securitydecoder__.configure(params.getParamsFor("securitydecoder"));
	if(controlPort_securepvbusdecoder__.configure.implemented()) controlPort_securepvbusdecoder__.configure(params.getParamsFor("securepvbusdecoder"));
	if(controlPort_secureRO__.configure.implemented()) controlPort_secureRO__.configure(params.getParamsFor("secureRO"));
	if(controlPort_secureROloader__.configure.implemented()) controlPort_secureROloader__.configure(params.getParamsFor("secureROloader"));
	if(controlPort_secureSRAM__.configure.implemented()) controlPort_secureSRAM__.configure(params.getParamsFor("secureSRAM"));
	if(controlPort_secureDRAM__.configure.implemented()) controlPort_secureDRAM__.configure(params.getParamsFor("secureDRAM"));
	if(controlPort_hdlcd__.configure.implemented()) controlPort_hdlcd__.configure(params.getParamsFor("hdlcd"));
	if(controlPort_dmc__.configure.implemented()) controlPort_dmc__.configure(params.getParamsFor("dmc"));
	if(controlPort_dmc_phy__.configure.implemented()) controlPort_dmc_phy__.configure(params.getParamsFor("dmc_phy"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__VEDaughterBoard_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__VEDaughterBoard::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pvbusdecoder__.populateCADIMap.implemented())
			{
				controlPort_pvbusdecoder__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_coresight_mapper__.populateCADIMap.implemented())
			{
				controlPort_coresight_mapper__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_sram__.populateCADIMap.implemented())
			{
				controlPort_sram__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("sram", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_sram_of_RAMDevice_to_VEDaughterBoard__ = new CADIParameterProxy(cadi, &parameterFilter_sram_of_RAMDevice_to_VEDaughterBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_vedcc__.populateCADIMap.implemented())
			{
				controlPort_vedcc__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clockdivider__.populateCADIMap.implemented())
			{
				controlPort_clockdivider__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("clockdivider", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_clockdivider_of_ClockDivider_to_VEDaughterBoard__ = new CADIParameterProxy(cadi, &parameterFilter_clockdivider_of_ClockDivider_to_VEDaughterBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clockCLCD__.populateCADIMap.implemented())
			{
				controlPort_clockCLCD__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("clockCLCD", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_clockCLCD_of_ClockDivider_to_VEDaughterBoard__ = new CADIParameterProxy(cadi, &parameterFilter_clockCLCD_of_ClockDivider_to_VEDaughterBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dram__.populateCADIMap.implemented())
			{
				controlPort_dram__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("dram", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_dram_of_RAMDevice_to_VEDaughterBoard__ = new CADIParameterProxy(cadi, &parameterFilter_dram_of_RAMDevice_to_VEDaughterBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dram_aliased__.populateCADIMap.implemented())
			{
				controlPort_dram_aliased__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dram_limit_4__.populateCADIMap.implemented())
			{
				controlPort_dram_limit_4__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dram_limit_8__.populateCADIMap.implemented())
			{
				controlPort_dram_limit_8__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_introuter__.populateCADIMap.implemented())
			{
				controlPort_introuter__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_secure_region__.populateCADIMap.implemented())
			{
				controlPort_secure_region__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_nonsecure_region__.populateCADIMap.implemented())
			{
				controlPort_nonsecure_region__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_securitydecoder__.populateCADIMap.implemented())
			{
				controlPort_securitydecoder__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_securepvbusdecoder__.populateCADIMap.implemented())
			{
				controlPort_securepvbusdecoder__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_secureRO__.populateCADIMap.implemented())
			{
				controlPort_secureRO__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("secureRO", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_secureRO_of_IntelStrataFlashJ3_to_VEDaughterBoard__ = new CADIParameterProxy(cadi, &parameterFilter_secureRO_of_IntelStrataFlashJ3_to_VEDaughterBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_secureROloader__.populateCADIMap.implemented())
			{
				controlPort_secureROloader__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_secureSRAM__.populateCADIMap.implemented())
			{
				controlPort_secureSRAM__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("secureSRAM", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_secureSRAM_of_RAMDevice_to_VEDaughterBoard__ = new CADIParameterProxy(cadi, &parameterFilter_secureSRAM_of_RAMDevice_to_VEDaughterBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_secureDRAM__.populateCADIMap.implemented())
			{
				controlPort_secureDRAM__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("secureDRAM", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_secureDRAM_of_RAMDevice_to_VEDaughterBoard__ = new CADIParameterProxy(cadi, &parameterFilter_secureDRAM_of_RAMDevice_to_VEDaughterBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_hdlcd__.populateCADIMap.implemented())
			{
				controlPort_hdlcd__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dmc__.populateCADIMap.implemented())
			{
				controlPort_dmc__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("dmc", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_dmc_of_RAMDevice_to_VEDaughterBoard__ = new CADIParameterProxy(cadi, &parameterFilter_dmc_of_RAMDevice_to_VEDaughterBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dmc_phy__.populateCADIMap.implemented())
			{
				controlPort_dmc_phy__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("dmc_phy", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_dmc_phy_of_RAMDevice_to_VEDaughterBoard__ = new CADIParameterProxy(cadi, &parameterFilter_dmc_phy_of_RAMDevice_to_VEDaughterBoard__);
			}
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__VEDaughterBoard::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__VEDaughterBoard::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__VEDaughterBoard::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__VEDaughterBoard::control_port__bypass(const std::string&)
{
    return "";
}


void Component__VEDaughterBoard::control_port__run()
{
}


void Component__VEDaughterBoard::control_port__stop()
{
}


void Component__VEDaughterBoard::control_port__idle()
{
}


void Component__VEDaughterBoard::control_port__quit()
{
}


void Component__VEDaughterBoard::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__VEDaughterBoard::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__VEDaughterBoard::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__VEDaughterBoard::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__VEDaughterBoard::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__VEDaughterBoard::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_sram_of_RAMDevice_to_VEDaughterBoard__;
	cadiParameterProxy_sram_of_RAMDevice_to_VEDaughterBoard__ = 0;
	delete cadiParameterProxy_clockdivider_of_ClockDivider_to_VEDaughterBoard__;
	cadiParameterProxy_clockdivider_of_ClockDivider_to_VEDaughterBoard__ = 0;
	delete cadiParameterProxy_clockCLCD_of_ClockDivider_to_VEDaughterBoard__;
	cadiParameterProxy_clockCLCD_of_ClockDivider_to_VEDaughterBoard__ = 0;
	delete cadiParameterProxy_dram_of_RAMDevice_to_VEDaughterBoard__;
	cadiParameterProxy_dram_of_RAMDevice_to_VEDaughterBoard__ = 0;
	delete cadiParameterProxy_secureRO_of_IntelStrataFlashJ3_to_VEDaughterBoard__;
	cadiParameterProxy_secureRO_of_IntelStrataFlashJ3_to_VEDaughterBoard__ = 0;
	delete cadiParameterProxy_secureSRAM_of_RAMDevice_to_VEDaughterBoard__;
	cadiParameterProxy_secureSRAM_of_RAMDevice_to_VEDaughterBoard__ = 0;
	delete cadiParameterProxy_secureDRAM_of_RAMDevice_to_VEDaughterBoard__;
	cadiParameterProxy_secureDRAM_of_RAMDevice_to_VEDaughterBoard__ = 0;
	delete cadiParameterProxy_dmc_of_RAMDevice_to_VEDaughterBoard__;
	cadiParameterProxy_dmc_of_RAMDevice_to_VEDaughterBoard__ = 0;
	delete cadiParameterProxy_dmc_phy_of_RAMDevice_to_VEDaughterBoard__;
	cadiParameterProxy_dmc_phy_of_RAMDevice_to_VEDaughterBoard__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__VEDaughterBoard::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__VEDaughterBoard::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__VEDaughterBoard::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__VEDaughterBoard::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_dram_size: *data = dram_size; break;
	case PARAMETER_ID_dram_alias: *data = dram_alias; break;
	case PARAMETER_ID_secure_memory: *data = secure_memory; break;

        default:
            printf("error: Component__VEDaughterBoard::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEDaughterBoard::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VEDaughterBoard::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEDaughterBoard::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_dram_size:
		{
			*(const_cast<int32_t*>(&dram_size)) = *data;
		}
		break;
	case PARAMETER_ID_dram_alias:
		{
			*(const_cast<bool*>(&dram_alias)) = !!*data;
		}
		break;
	case PARAMETER_ID_secure_memory:
		{
			*(const_cast<bool*>(&secure_memory)) = !!*data;
		}
		break;

        default:
            printf("error: Component__VEDaughterBoard::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEDaughterBoard::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VEDaughterBoard::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__VEDaughterBoard::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__VEDaughterBoard::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__VEDaughterBoard::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__VEDaughterBoard::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__VEDaughterBoard::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__VEDaughterBoard::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__VEDaughterBoard::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__VEDaughterBoard::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__VEDaughterBoard::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "dram_size") id = PARAMETER_ID_dram_size;
    if (name == "dram_alias") id = PARAMETER_ID_dram_alias;
    if (name == "secure_memory") id = PARAMETER_ID_secure_memory;

    return id;
}

void Component__VEDaughterBoard::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 37 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::init()
{
 {if(!controlPort_bus_slave__.init.empty()) controlPort_bus_slave__.init();};
 
 
 __RAMDevice_internal_1.setFillPattern(0xdfdfdfcf,0xcfdfdfdf);
 __RAMDevice_internal_1.setAccess(0, size, pv::ACCESSTYPE_RW, pv::ACCESSMODE_MEMORY);

 if (global_monitor_ignores_non_ex_store)
 {
 pv::slave_config_t slave_config;

 slave_config.ignoreNonExclusiveStoresToGlobalMonitor();

 __RAMDevice_internal_1.configure(&slave_config);
 }
 
}
}

#line 64 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__RAMDevice::debug_read(uint32_t space_id, uint32_t block_id, uint64_t offset, uint32_t size_in_maus, uint64_t* data, bool side_effects, sg::MemoryAccessContext* mac)
{
 pv::bus_addr_t start_address = offset % size;
 uint8_t * ptr = (uint8_t *)data;
 uint32_t size_in_bytes = size_in_maus * mac->GetMauInBytes();

 while (size_in_bytes > 0) {
 pv::bus_addr_t block_limit;
 uint8_t const *storage = __RAMDevice_internal_1.getReadStorage(start_address,
 &block_limit);
 uint32_t transfer_bytes = block_limit - start_address;
 if (transfer_bytes > size_in_bytes) transfer_bytes = size_in_bytes;
 if (transfer_bytes == 0) break;

 memcpy(ptr, storage, transfer_bytes);

 size_in_bytes -= transfer_bytes;
 start_address = (start_address + transfer_bytes) % size;
 ptr += transfer_bytes;
 }
 return ACCESS_FUNC_OK;
 
}
}

#line 94 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__RAMDevice::debug_write(uint32_t space_id, uint32_t block_id, uint64_t offset, uint32_t size_in_maus, const uint64_t* data, bool side_effects, sg::MemoryAccessContext* mac)
{
 pv::bus_addr_t start_address = offset % size;
 uint8_t const *ptr = (uint8_t *)data;
 uint32_t size_in_bytes = size_in_maus * mac->GetMauInBytes();

 while (size_in_bytes > 0) {
 pv::bus_addr_t block_limit;
 uint8_t * storage = __RAMDevice_internal_1.getWriteStorage(start_address,
 &block_limit);
 uint32_t transfer_bytes = block_limit - start_address;
 if (transfer_bytes > size_in_bytes) transfer_bytes = size_in_bytes;
 if (transfer_bytes == 0) break;

 memcpy(storage, ptr, transfer_bytes);

 size_in_bytes -= transfer_bytes;
 start_address = (start_address + transfer_bytes) % size;
 ptr += transfer_bytes;
 }
 return ACCESS_FUNC_OK;
 
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::interconnect()
{{if(!controlPort_bus_slave__.interconnect.empty()) controlPort_bus_slave__.interconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::disconnect()
{{if(!controlPort_bus_slave__.disconnect.empty()) controlPort_bus_slave__.disconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::update()
{{if(!controlPort_bus_slave__.update.empty()) controlPort_bus_slave__.update();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::communicate()
{{if(!controlPort_bus_slave__.communicate.empty()) controlPort_bus_slave__.communicate();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::traceEndOfCycle()
{{if(!controlPort_bus_slave__.traceEndOfCycle.empty()) controlPort_bus_slave__.traceEndOfCycle();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::loadApplicationFile(const std::string& filename)
{{if(!controlPort_bus_slave__.loadApplicationFile.empty()) controlPort_bus_slave__.loadApplicationFile(filename);};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::terminate()
{{if(!controlPort_bus_slave__.terminate.empty()) controlPort_bus_slave__.terminate();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::reset(int level)
{{if(!controlPort_bus_slave__.reset.empty()) controlPort_bus_slave__.reset(level);};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__RAMDevice::save(MxODataStream& os)
{{if(!controlPort_bus_slave__.save.empty()) controlPort_bus_slave__.save(os);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__RAMDevice::restore(MxIDataStream& is)
{{if(!controlPort_bus_slave__.restore.empty()) controlPort_bus_slave__.restore(is);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/RAMDevice.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__RAMDevice::step()
{{if(!controlPort_bus_slave__.step.empty()) controlPort_bus_slave__.step();};
}
}

#line 2698 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__RAMDevice
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__RAMDevice::Component__RAMDevice(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,size(GetParameterValue(params, "size", MxS64CONST(0x100000000), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,global_monitor_ignores_non_ex_store(!!GetParameterValue(params, "global_monitor_ignores_non_ex_store", MxS64CONST(0x0), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))


	,cadiParameterProxy_bus_slave_of_PVBusSlave_to_RAMDevice__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "RAM device, can be dynamic or static ram.";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = RAMDevice_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_bus_slave__ = params.getParamsFor("bus_slave");
			params_bus_slave__["size"] = size;
			add(bus_slave = PVBusSlave_factory->instantiate("bus_slave", simulationContext, params_bus_slave__));
		}
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__RAMDevice::control_port__configure, this);
    bind_method(control_port, init, &Component__RAMDevice::init, this);
    bind_method(control_port, interconnect, &Component__RAMDevice::interconnect, this);
//  bind_method(control_port, postConnect, &Component__RAMDevice::postConnect, this);
    bind_method(control_port, reset, &Component__RAMDevice::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__RAMDevice::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__RAMDevice::disconnect, this);
    bind_method(control_port, terminate, &Component__RAMDevice::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__RAMDevice::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__RAMDevice::refresh, this);
    bind_method(control_port, step, &Component__RAMDevice::step, this);
    bind_method(control_port, update, &Component__RAMDevice::update, this);
    bind_method(control_port, communicate, &Component__RAMDevice::communicate, this);
    bind_method(control_port, getProperty, &Component__RAMDevice::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__RAMDevice::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__RAMDevice::control_port__bypass, this);
    bind_method(control_port, run, &Component__RAMDevice::control_port__run, this);
    bind_method(control_port, stop, &Component__RAMDevice::control_port__stop, this);
    bind_method(control_port, idle, &Component__RAMDevice::control_port__idle, this);
    bind_method(control_port, quit, &Component__RAMDevice::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__RAMDevice::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__RAMDevice::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__RAMDevice::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__RAMDevice::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__RAMDevice::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__RAMDevice::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__RAMDevice::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__RAMDevice::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_bus_slave__.connectTo(bus_slave->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports


    // add abstract ports
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	__RAMDevice_internal_1.SetName__("__RAMDevice_internal_1");


    // wire up static connection map
	pvbus.connectTo(bus_slave->findPort("pvbus_s"));
	__RAMDevice_internal_1.connectTo(bus_slave->findPort("control"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__RAMDevice::~Component__RAMDevice()
{
}

void Component__RAMDevice::control_port__configure(const sg::Params& params)
{
	if(controlPort_bus_slave__.configure.implemented()) controlPort_bus_slave__.configure(params.getParamsFor("bus_slave"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__RAMDevice_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__RAMDevice::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_bus_slave__.populateCADIMap.implemented())
			{
				controlPort_bus_slave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("bus_slave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_bus_slave_of_PVBusSlave_to_RAMDevice__ = new CADIParameterProxy(cadi, &parameterFilter_bus_slave_of_PVBusSlave_to_RAMDevice__);
			}
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__RAMDevice::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__RAMDevice::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__RAMDevice::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__RAMDevice::control_port__bypass(const std::string&)
{
    return "";
}


void Component__RAMDevice::control_port__run()
{
}


void Component__RAMDevice::control_port__stop()
{
}


void Component__RAMDevice::control_port__idle()
{
}


void Component__RAMDevice::control_port__quit()
{
}


void Component__RAMDevice::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__RAMDevice::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__RAMDevice::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__RAMDevice::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__RAMDevice::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__RAMDevice::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_bus_slave_of_PVBusSlave_to_RAMDevice__;
	cadiParameterProxy_bus_slave_of_PVBusSlave_to_RAMDevice__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__RAMDevice::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__RAMDevice::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__RAMDevice::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__RAMDevice::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_size: *data = size; break;

        default:
            printf("error: Component__RAMDevice::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__RAMDevice::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__RAMDevice::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__RAMDevice::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_size:
		{
			*(const_cast<uint64_t*>(&size)) = *data;
		}
		break;

        default:
            printf("error: Component__RAMDevice::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__RAMDevice::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__RAMDevice::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__RAMDevice::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__RAMDevice::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__RAMDevice::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__RAMDevice::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__RAMDevice::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__RAMDevice::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__RAMDevice::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__RAMDevice::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__RAMDevice::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "size") id = PARAMETER_ID_size;

    return id;
}

void Component__RAMDevice::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 189 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::init()
{
 {if(!controlPort_pvbus_mapper__.init.empty()) controlPort_pvbus_mapper__.init();};

 
 assert(TZROUTE_IGNORE == 0);
 assert(TZROUTE_TO_PORT_A == 1);
 assert(TZROUTE_TO_PORT_B == 2);
 assert(TZROUTE_ABORT == 3);

 
 control.routeAccesses(TZINPUT_SECURE, TZSwitch_RouteOption(secure));
 control.routeAccesses(TZINPUT_NORMAL, TZSwitch_RouteOption(normal));
 
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::interconnect()
{{if(!controlPort_pvbus_mapper__.interconnect.empty()) controlPort_pvbus_mapper__.interconnect();};
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::disconnect()
{{if(!controlPort_pvbus_mapper__.disconnect.empty()) controlPort_pvbus_mapper__.disconnect();};
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::update()
{{if(!controlPort_pvbus_mapper__.update.empty()) controlPort_pvbus_mapper__.update();};
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::communicate()
{{if(!controlPort_pvbus_mapper__.communicate.empty()) controlPort_pvbus_mapper__.communicate();};
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::traceEndOfCycle()
{{if(!controlPort_pvbus_mapper__.traceEndOfCycle.empty()) controlPort_pvbus_mapper__.traceEndOfCycle();};
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::loadApplicationFile(const std::string& filename)
{{if(!controlPort_pvbus_mapper__.loadApplicationFile.empty()) controlPort_pvbus_mapper__.loadApplicationFile(filename);};
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::terminate()
{{if(!controlPort_pvbus_mapper__.terminate.empty()) controlPort_pvbus_mapper__.terminate();};
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::reset(int level)
{{if(!controlPort_pvbus_mapper__.reset.empty()) controlPort_pvbus_mapper__.reset(level);};
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__TZSwitch::save(MxODataStream& os)
{{if(!controlPort_pvbus_mapper__.save.empty()) controlPort_pvbus_mapper__.save(os);};return true;
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__TZSwitch::restore(MxIDataStream& is)
{{if(!controlPort_pvbus_mapper__.restore.empty()) controlPort_pvbus_mapper__.restore(is);};return true;
}
}

#line 69 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::step()
{{if(!controlPort_pvbus_mapper__.step.empty()) controlPort_pvbus_mapper__.step();};
}
}

#line 116 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__TZSwitch::abstract_port__control__routeAccesses(TZSwitch_InputFilter input, TZSwitch_RouteOption destination)
{
 
 unsigned new_route;

 switch(destination)
 {
 case TZROUTE_IGNORE: new_route = PVBUSMAPPER_IGNORE; break;
 case TZROUTE_TO_PORT_A: new_route = PORT_A; break;
 case TZROUTE_TO_PORT_B: new_route = PORT_B; break;
 case TZROUTE_ABORT: new_route = PVBUSMAPPER_ABORT; break;

 default:
 assert(!"Argument destination invalid");
 new_route = PVBUSMAPPER_IGNORE;
 break;
 }

 bool routing_changed = false;

 if ((input == TZINPUT_SECURE) || (input == TZINPUT_ANY))
 {
 if (route.secure != new_route)
 {
 route.secure = new_route;
 routing_changed = true;
 }

 
 secure = destination;
 }
 else
 {
 assert(input == TZINPUT_NORMAL);
 }

 if ((input == TZINPUT_NORMAL) || (input == TZINPUT_ANY))
 {
 if (route.normal != new_route)
 {
 route.normal = new_route;
 routing_changed = true;
 }

 
 normal = destination;
 }
 else
 {
 assert(input == TZINPUT_SECURE);
 }

 if (routing_changed)
 {
 
 mapper_control.allBusMapChanging();
 }
 
}
}

#line 206 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/TZSwitch.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { unsigned 
Component__TZSwitch::abstract_port__mapper_control__remap(pv::RemapRequest& req)
{
 return req.getTransactionAttributes()->isNormalWorld() ? route.normal
 : route.secure;
 
}
}

#line 3430 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__TZSwitch
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__TZSwitch::Component__TZSwitch(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,secure(GetParameterValue(params, "secure", MxS64CONST(0x1), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,normal(GetParameterValue(params, "normal", MxS64CONST(0x2), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))



{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Bus";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Allow TrustZone secure/normal bus signals to be routed separately";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = TZSwitch_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *PVBusMapper_factory = PVBusMapper_GetFactory();
		{
			sg::Params params_pvbus_mapper__ = params.getParamsFor("pvbus_mapper");
			add(pvbus_mapper = PVBusMapper_factory->instantiate("pvbus_mapper", simulationContext, params_pvbus_mapper__));
		}
		PVBusMapper_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__TZSwitch::control_port__configure, this);
    bind_method(control_port, init, &Component__TZSwitch::init, this);
    bind_method(control_port, interconnect, &Component__TZSwitch::interconnect, this);
//  bind_method(control_port, postConnect, &Component__TZSwitch::postConnect, this);
    bind_method(control_port, reset, &Component__TZSwitch::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__TZSwitch::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__TZSwitch::disconnect, this);
    bind_method(control_port, terminate, &Component__TZSwitch::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__TZSwitch::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__TZSwitch::refresh, this);
    bind_method(control_port, step, &Component__TZSwitch::step, this);
    bind_method(control_port, update, &Component__TZSwitch::update, this);
    bind_method(control_port, communicate, &Component__TZSwitch::communicate, this);
    bind_method(control_port, getProperty, &Component__TZSwitch::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__TZSwitch::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__TZSwitch::control_port__bypass, this);
    bind_method(control_port, run, &Component__TZSwitch::control_port__run, this);
    bind_method(control_port, stop, &Component__TZSwitch::control_port__stop, this);
    bind_method(control_port, idle, &Component__TZSwitch::control_port__idle, this);
    bind_method(control_port, quit, &Component__TZSwitch::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__TZSwitch::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__TZSwitch::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__TZSwitch::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__TZSwitch::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__TZSwitch::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__TZSwitch::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__TZSwitch::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__TZSwitch::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_pvbus_mapper__.connectTo(pvbus_mapper->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(control, routeAccesses, &Component__TZSwitch::abstract_port__control__routeAccesses, this);
	bind_method(mapper_control, remap, &Component__TZSwitch::abstract_port__mapper_control__remap, this);


    // add abstract ports
	publishSlavePort("pvbus_input", pvbus_input);
	pvbus_input.SetName__("pvbus_input");
	publishMasterPort("pvbus_port_a", pvbus_port_a);
	pvbus_port_a.SetName__("pvbus_port_a");
	publishMasterPort("pvbus_port_b", pvbus_port_b);
	pvbus_port_b.SetName__("pvbus_port_b");
	publishSlavePort("control", control);
	control.SetName__("control");
	mapper_control.SetName__("mapper_control");


    // wire up static connection map
	pvbus_input.connectTo(pvbus_mapper->findPort("pvbus_s"));
	pvbus_mapper->findPort("control").connectTo(mapper_control);
	pvbus_mapper->findPort("pvbus_m", 0).connectTo(pvbus_port_a);
	pvbus_mapper->findPort("pvbus_m", 1).connectTo(pvbus_port_b);


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__TZSwitch::~Component__TZSwitch()
{
}

void Component__TZSwitch::control_port__configure(const sg::Params& params)
{
	if(controlPort_pvbus_mapper__.configure.implemented()) controlPort_pvbus_mapper__.configure(params.getParamsFor("pvbus_mapper"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__TZSwitch_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__TZSwitch::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pvbus_mapper__.populateCADIMap.implemented())
			{
				controlPort_pvbus_mapper__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__TZSwitch::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__TZSwitch::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__TZSwitch::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__TZSwitch::control_port__bypass(const std::string&)
{
    return "";
}


void Component__TZSwitch::control_port__run()
{
}


void Component__TZSwitch::control_port__stop()
{
}


void Component__TZSwitch::control_port__idle()
{
}


void Component__TZSwitch::control_port__quit()
{
}


void Component__TZSwitch::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__TZSwitch::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__TZSwitch::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__TZSwitch::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__TZSwitch::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__TZSwitch::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__TZSwitch::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__TZSwitch::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__TZSwitch::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__TZSwitch::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_secure: *data = secure; break;
	case PARAMETER_ID_normal: *data = normal; break;

        default:
            printf("error: Component__TZSwitch::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__TZSwitch::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__TZSwitch::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__TZSwitch::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_secure:
		{
			secure = *data;
		}
		break;
	case PARAMETER_ID_normal:
		{
			normal = *data;
		}
		break;

        default:
            printf("error: Component__TZSwitch::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__TZSwitch::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__TZSwitch::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__TZSwitch::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__TZSwitch::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__TZSwitch::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__TZSwitch::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__TZSwitch::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__TZSwitch::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__TZSwitch::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__TZSwitch::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__TZSwitch::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "secure") id = PARAMETER_ID_secure;
    if (name == "normal") id = PARAMETER_ID_normal;

    return id;
}

void Component__TZSwitch::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 513 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL370_HDLCD::timer_callback()
{
 if (diagnostic==4)
 {
 ostringstream W;
 W << getInstancePath() << ": timer fired; enabled=" << enabled << endl;
 message(W.str(), MSG_INFO);
 }

 
 if (!enabled)
 {
 return 0;
 }
 
 
 update_registers(); 
 
 
 blit_frame();
 
 return 10000;
 
}
}

#line 548 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::init()
{
 fdata = NULL;
 pv::TransactionMasterControl t_control;
 t_control >> busmaster->findPort("control");
 dma = t_control.createStreamingTransactionGenerator();
 fbuffer_changed = true;
 force_redraw = true;
 bits_per_pixel = 16; 
 blit.pixels_per_line = &pixels_per_line;
 blit.default_red = &default_red;
 blit.default_green = &default_green;
 blit.default_blue = &default_blue;
 blit.offset_red = &offset_red;
 blit.offset_green = &offset_green;
 blit.offset_blue = &offset_blue;
 blit.size_red = &size_red;
 blit.size_green = &size_green;
 blit.size_blue = &size_blue;
 blit.bytes_per_pixel = &bytes_per_pixel;
 {if(!controlPort_busslave__.init.empty()) controlPort_busslave__.init();if(!controlPort_busmaster__.init.empty()) controlPort_busmaster__.init();if(!controlPort_timer__.init.empty()) controlPort_timer__.init();};

 
}
}

#line 572 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::reset(int level)
{
 {if(!controlPort_busslave__.reset.empty()) controlPort_busslave__.reset(level);if(!controlPort_busmaster__.reset.empty()) controlPort_busmaster__.reset(level);if(!controlPort_timer__.reset.empty()) controlPort_timer__.reset(level);};

 __PL370_HDLCD_internal_1.cancel();
 dma->setRange(0, 0);

 
 int_raw = 0x0;
 int_mask = 0x0;
 user_out = 0x0;
 fb_base = 0x0;
 fb_line_len = 0x0;
 fb_line_count = 0x0;
 fb_line_pitch = 0x0;
 bus_opts = 0x408;
 v_sync = 0x0;
 v_back_porch = 0x0;
 v_data = 0x0;
 v_front_porch = 0x0;
 h_sync = 0x0;
 h_back_porch = 0x0;
 h_data = 0x0;
 h_front_porch = 0x0;
 polarities = 0x7;
 command = 0x0;
 pixel_fmt = 0x0;
 red_select = 0x0;
 green_select = 0x0;
 blue_select = 0x0;

 
 reg_changed = false;
 big_endian = false;
 bytes_per_pixel = 1; 
 enabled = false;
 default_red = 0x0;
 default_green = 0x0;
 default_blue = 0x0;
 size_red = 0x0;
 size_green = 0x0;
 size_blue = 0x0;
 offset_red = 0x0;
 offset_green = 0x0;
 offset_blue = 0x0;

 
 be_pixel_order = false;
 big_endian = false;
 bgr = false;

 colour_format_changed = false;

 update_registers();

 if(display.lock.implemented())
 fdata = display.lock();
 else
 fdata = NULL;

 if(fdata != NULL)
 {
 if (fdata->changed)
 {
 update_palette();
 }
 }
 if(display.unlock.implemented())
 display.unlock();
 
}
}

#line 643 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::terminate()
{
 delete dma;
 {if(!controlPort_busslave__.terminate.empty()) controlPort_busslave__.terminate();if(!controlPort_busmaster__.terminate.empty()) controlPort_busmaster__.terminate();if(!controlPort_timer__.terminate.empty()) controlPort_timer__.terminate();};
 
}
}

#line 649 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::update_registers()
{
 if (reg_changed) {
 fbuffer_changed = true;
 }
 if(reg_changed & (1<<HDLCDPixelFmt))
 {
 big_endian = (pixel_fmt & BIG_ENDIAN_MASK) != 0;
 bytes_per_pixel = ((pixel_fmt & BYTES_PER_PIXEL_MASK) >> BYTES_PER_PIXEL_SHIFT) + 1;
 
 colour_format_changed = true;
 pixels_per_line = (fb_line_len/4) * bytes_per_pixel;
 bits_per_pixel = bytes_per_pixel * 8;
 }
 if(reg_changed & (1<<HDLCDRedSelect))
 {
 default_red = (red_select & COLOR_DEFAULT_MASK) >> COLOR_DEFAULT_SHIFT;
 offset_red = (red_select & COLOR_OFFSET_MASK) >> COLOR_OFFSET_SHIFT;
 size_red = (red_select & COLOR_SIZE_MASK) >> COLOR_SIZE_SHIFT;
 colour_format_changed = true;
 }
 if(reg_changed & (1<<HDLCDGreenSelect))
 {
 default_green = (green_select & COLOR_DEFAULT_MASK) >> COLOR_DEFAULT_SHIFT;
 offset_green = (green_select & COLOR_OFFSET_MASK) >> COLOR_OFFSET_SHIFT;
 size_green = (green_select & COLOR_SIZE_MASK) >> COLOR_SIZE_SHIFT;
 colour_format_changed = true;
 }
 if(reg_changed & (1<<HDLCDBlueSelect))
 {
 default_blue = (blue_select & COLOR_DEFAULT_MASK) >> COLOR_DEFAULT_SHIFT;
 offset_blue = (blue_select & COLOR_OFFSET_MASK) >> COLOR_OFFSET_SHIFT;
 size_blue = (blue_select & COLOR_SIZE_MASK) >> COLOR_SIZE_SHIFT;
 colour_format_changed = true;
 }
 if(colour_format_changed)
 {
 bgr = offset_blue > offset_red;
 }

 if(reg_changed & (1<<HDLCDFBBase)) 
 {
 uint32_t fbuffer_bytes = v_data * h_data * bytes_per_pixel;
 if (diagnostic==4)
 {
 ostringstream W;
 W << getInstancePath() << ": engaging DMA for range " << hex << setw(10) << setfill('0') << hex << fb_base << ":" << setw(10) << setfill('0') << (fb_base + fbuffer_bytes) << endl;
 W << "buffer is " << dec << v_data << " by " << h_data << " by " << (bytes_per_pixel*8) << "bpp\n";
 message(W.str(), MSG_INFO);
 }
 dma->setRange(fb_base, fbuffer_bytes);
 }

 if((reg_changed & (1<<HDLCDIntRaw)) || (reg_changed & (1<<HDLCDIntMask))) 
 {
 update_interrupts(); 
 }

 reg_changed = false;
 
}
}

#line 710 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::update_interrupts()
{
 if (int_raw & int_mask) {
 if (intr.setValue.implemented())
 {
 intr.setValue(sg::Signal::Set);
 }
 } else {
 if (intr.setValue.implemented())
 {
 intr.setValue(sg::Signal::Clear);
 }
 }
 
}
}

#line 725 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::update_palette()
{
 force_redraw = true;
 
 palette_changed = false;
 
}
}

#line 733 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint8_t* 
Component__PL370_HDLCD::blit_line(uint8_t* dst, const uint8_t* src, uint32_t len)
{
 if(src)
 {
 switch(bytes_per_pixel)
 {
 case 1:
 dst = (uint8_t*)blit.blit_line((uint32_t*)dst, src, len); break;
 case 2:
 dst = (uint8_t*)blit.blit_line((uint32_t*)dst, (uint16_t*)src, len); break;
 case 3:
 case 4:
 dst = (uint8_t*)blit.blit_line((uint32_t*)dst, (uint32_t*)src, len); break;
 }
 } else {
 dst += 4*len; 
 }

 return dst;
 
}
}

#line 755 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::blit_frame()
{
 if (diagnostic==4)
 {
 ostringstream W;
 W << getInstancePath() << ": blit frame" << endl;
 message(W.str(), MSG_INFO);
 }

 unsigned int src_len = (bytes_per_pixel == 3? 4 : bytes_per_pixel); 
 if(display.setPreferredLayout.implemented())
 display.setPreferredLayout(h_data , v_data, 24); 

 if(display.lock.implemented())
 fdata = display.lock();
 else
 fdata = NULL;
 
 if (fdata == NULL)
 {
 return;
 }

 unsigned int render_bytes_per_line = fdata->width * 4;
 unsigned int render_height = fdata->height;
 unsigned int bytes_per_line = h_data * bytes_per_pixel;

 if (render_bytes_per_line/4 > bytes_per_line/src_len) {
 render_bytes_per_line = (bytes_per_line/src_len)*4;
 }
 if (render_height > fb_line_count) {
 render_height = fb_line_count;
 }
 
 fbuffer_changed |= force_redraw;

 dma->startDma(fb_base);
 
 const uint8_t* src_ptr;

 for (uint32_t line = 0; line < render_height; ++line)
 {
 uint32_t line_offset = 0;
 
 uint8_t* dest_ptr = fdata->buffer + line * fdata->pitch;
 
 while (line_offset < bytes_per_line)
 {
 uint32_t len = bytes_per_line - line_offset;
 bool changed = dma->getDmaData(&src_ptr, &len);
 
 fbuffer_changed |= changed;
 
 if (line_offset/src_len < render_bytes_per_line/4) {
 uint32_t render_len = (render_bytes_per_line/4 - line_offset/src_len)*4;
 if (render_len/4 > len/src_len) render_len = (len/src_len)*4;
 
 dest_ptr = blit_line(dest_ptr, src_ptr, render_len);
 }
 line_offset += len;
 }
 }

 if(display.unlock.implemented())
 display.unlock();
 
 if (fbuffer_changed)
 {
 if(display.update.implemented())
 display.update(0,0, h_data , v_data);
 }

 fbuffer_changed = false;
 force_redraw = false;

 
 int_raw |= INT_VSYNC|INT_DMA;
 update_interrupts();
 
 
}
}

#line 836 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL370_HDLCD::registerRead(uint32_t device_addr)
{
 uint32_t data = 0;
 uint32_t peri_id = 0x000bb370;

 switch (device_addr) {

 case 0x000:
 
 data |= (0x1cdc & 0xffff) << 16;
 data |= (0x00 & 0xff) << 8;
 data |= (0x00 & 0xff) << 0;
 break;
 case 0x010:
 
 data = int_raw;
 break;
 case 0x018:
 data = int_mask;
 break;
 case 0x01c: 
 data = int_raw & int_mask;
 break;
 case 0x020: 
 data = user_out;
 break;
 case 0x100:
 data = fb_base;
 break;
 case 0x104:
 data = fb_line_len;
 break;
 case 0x108:
 data = fb_line_count - 1;
 break;
 case 0x10c:
 data = fb_line_pitch;
 break;
 case 0x110:
 data = bus_opts;
 break;
 case 0x200:
 data = v_sync;
 break;
 case 0x204:
 data = v_back_porch;
 break;
 case 0x208:
 data = v_data;
 break;
 case 0x20c:
 data = v_front_porch;
 break;

 case 0x210:
 data = h_sync;
 break;
 case 0x214:
 data = h_back_porch;
 break;
 case 0x218:
 data = h_data;
 break;
 case 0x21c:
 data = h_front_porch;
 break;
 case 0x220:
 data = polarities;
 break;
 case 0x230:
 data = command;
 break;
 case 0x240:
 data = pixel_fmt;
 break;
 case 0x244:
 data = red_select;
 break;
 case 0x248:
 data = green_select;
 break;
 case 0x24c:
 data = blue_select;
 break;
 
 case 0xFE0: data = (peri_id >> 0) & 0xff; break; 
 case 0xFE4: data = (peri_id >> 8) & 0xff; break;
 case 0xFE8: data = (peri_id >> 16) & 0xff; break;
 case 0xFEC: data = (peri_id >> 24) & 0xff; break;
 case 0xFF0: data = 0x0D; break; 
 case 0xFF4: data = 0xF0; break;
 case 0xFF8: data = 0x05; break;
 case 0xFFC: data = 0xB1; break;

 }
 if (diagnostic==4)
 {
 ostringstream W;
 W << getInstancePath() << ": HDLCD register read " << setw(3)<<setfill('0')<<hex<<(uint32_t)device_addr<<" -> "<<setw(8)<<data<<endl;
 message(W.str(), MSG_INFO);
 }
 return data;
 
}
}

#line 940 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::registerWrite(uint32_t device_addr, uint32_t data)
{
 if (diagnostic==4)
 {
 ostringstream W;
 W << getInstancePath() << ": HDLCD register write " << setw(3)<<setfill('0')<<hex<<(uint32_t)device_addr<<" -> "<<setw(8)<<data<<endl;
 message(W.str(), MSG_INFO);
 }

 switch (device_addr) {
 case 0x010: 
 int_raw = data & HDLCD_ALL_INT_MASK;

 reg_changed |= (1<<HDLCDIntRaw);
 break;
 case 0x014:
 
 int_raw &= ~(data & HDLCD_ALL_INT_MASK);
 update_interrupts();
 
 break;
 case 0x018:
 int_mask = data & HDLCD_ALL_INT_MASK;
 reg_changed |= (1<<HDLCDIntMask);
 break;
 case 0x020:
 user_out = data;
 reg_changed |= (1<<HDLCDUserOut);
 break;
 case 0x100:
 fb_base = data & BYTE_ALIENGED_MASK;
 reg_changed |= (1<<HDLCDFBBase);
 break;
 case 0x104:
 fb_line_len = data & BYTE_ALIENGED_MASK;
 reg_changed |= (1<<HDLCDFBLineLen);
 break;
 case 0x108:
 fb_line_count = (data & LENGTH_MASK) + 1;
 reg_changed |= (1<<HDLCDFBLineCount);
 break;
 case 0x10c:
 fb_line_pitch = data & BYTE_ALIENGED_MASK;
 reg_changed |= (1<<HDLCDFBLinePitch);
 break;
 case 0x110:
 bus_opts = data & 0xfff;
 
 reg_changed |= (1<<HDLCDBusOpts);
 break;
 case 0x200:
 v_sync = data & LENGTH_MASK;
 reg_changed |= (1<<HDLCDVSync);
 break;
 case 0x204:
 v_back_porch = data & LENGTH_MASK;
 reg_changed |= (1<<HDLCDVBackPorch);
 break;
 case 0x208:
 v_data = (data & LENGTH_MASK) + 1;
 reg_changed |= (1<<HDLCDVData);
 break;
 case 0x20c:
 v_front_porch = data & LENGTH_MASK;
 reg_changed |= (1<<HDLCDVFrontPorch);
 break;
 case 0x210:
 h_sync = data & LENGTH_MASK;
 reg_changed |= (1<<HDLCDHSync);
 break;
 case 0x214:
 h_back_porch = data & LENGTH_MASK;
 reg_changed |= (1<<HDLCDHBackPorch);
 break;
 case 0x218:
 h_data = (data & LENGTH_MASK) + 1;
 reg_changed |= (1<<HDLCDHData);
 break;
 case 0x21c:
 h_front_porch = data & LENGTH_MASK;
 reg_changed |= (1<<HDLCDHFrontPorch);
 break;
 case 0x220:
 polarities = data & HDLCD_POLARITY_MASK;
 reg_changed |= (1<<HDLCDPolarities);
 break;
 case 0x230:
 command = data & HDLCD_ENABLE;

 enabled = (command & HDLCD_ENABLE) != 0;
 
 if (enabled)
 {
 if (v_data==0)
 {
 enabled=false;
 message(getInstancePath()+": HDLCD_ENABLE: not enabling because v_data uninitialised\n",MSG_ERROR);
 }
 
 if (h_data==0)
 {
 enabled=false;
 message(getInstancePath()+": HDLCD_ENABLE: not enabling because h_data uninitialised\n",MSG_ERROR);
 }
 }
 
 if (enabled) 
 {
 
 __PL370_HDLCD_internal_1.set(1);
 }
 else 
 {
 
 __PL370_HDLCD_internal_1.cancel();
 }
 reg_changed |= (1<<HDLCDCommand);
 break;
 case 0x240:
 pixel_fmt = data & HDLCD_PIXEL_FMT_MASK;

 reg_changed |= (1<<HDLCDPixelFmt);
 break;
 case 0x244:
 red_select = data & HDLCD_COLOR_MASK;

 reg_changed |= (1<<HDLCDRedSelect);
 break;
 case 0x248:
 green_select = data & HDLCD_COLOR_MASK;

 reg_changed |= (1<<HDLCDGreenSelect);
 break;
 case 0x24c:
 blue_select = data & HDLCD_COLOR_MASK;

 reg_changed |= (1<<HDLCDBlueSelect);
 break;

 

 }
 
 
}
}

#line 1087 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL370_HDLCD::debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects)
{
 *datap = registerRead(reg_id);
 return ACCESS_FUNC_OK;
 
}
}

#line 1093 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL370_HDLCD::debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects)
{
 registerWrite(reg_id, (uint32_t)*datap);
 return ACCESS_FUNC_OK;
 
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::interconnect()
{{if(!controlPort_busslave__.interconnect.empty()) controlPort_busslave__.interconnect();if(!controlPort_busmaster__.interconnect.empty()) controlPort_busmaster__.interconnect();if(!controlPort_timer__.interconnect.empty()) controlPort_timer__.interconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::disconnect()
{{if(!controlPort_busslave__.disconnect.empty()) controlPort_busslave__.disconnect();if(!controlPort_busmaster__.disconnect.empty()) controlPort_busmaster__.disconnect();if(!controlPort_timer__.disconnect.empty()) controlPort_timer__.disconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::update()
{{if(!controlPort_busslave__.update.empty()) controlPort_busslave__.update();if(!controlPort_busmaster__.update.empty()) controlPort_busmaster__.update();if(!controlPort_timer__.update.empty()) controlPort_timer__.update();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::communicate()
{{if(!controlPort_busslave__.communicate.empty()) controlPort_busslave__.communicate();if(!controlPort_busmaster__.communicate.empty()) controlPort_busmaster__.communicate();if(!controlPort_timer__.communicate.empty()) controlPort_timer__.communicate();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::traceEndOfCycle()
{{if(!controlPort_busslave__.traceEndOfCycle.empty()) controlPort_busslave__.traceEndOfCycle();if(!controlPort_busmaster__.traceEndOfCycle.empty()) controlPort_busmaster__.traceEndOfCycle();if(!controlPort_timer__.traceEndOfCycle.empty()) controlPort_timer__.traceEndOfCycle();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::loadApplicationFile(const std::string& filename)
{{if(!controlPort_busslave__.loadApplicationFile.empty()) controlPort_busslave__.loadApplicationFile(filename);if(!controlPort_busmaster__.loadApplicationFile.empty()) controlPort_busmaster__.loadApplicationFile(filename);if(!controlPort_timer__.loadApplicationFile.empty()) controlPort_timer__.loadApplicationFile(filename);};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL370_HDLCD::save(MxODataStream& os)
{{if(!controlPort_busslave__.save.empty()) controlPort_busslave__.save(os);if(!controlPort_busmaster__.save.empty()) controlPort_busmaster__.save(os);if(!controlPort_timer__.save.empty()) controlPort_timer__.save(os);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL370_HDLCD::restore(MxIDataStream& is)
{{if(!controlPort_busslave__.restore.empty()) controlPort_busslave__.restore(is);if(!controlPort_busmaster__.restore.empty()) controlPort_busmaster__.restore(is);if(!controlPort_timer__.restore.empty()) controlPort_timer__.restore(is);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL370_HDLCD::step()
{{if(!controlPort_busslave__.step.empty()) controlPort_busslave__.step();if(!controlPort_busmaster__.step.empty()) controlPort_busmaster__.step();if(!controlPort_timer__.step.empty()) controlPort_timer__.step();};
}
}

#line 463 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL370_HDLCD::abstract_port__device__read(pv::ReadTransaction tx)
{
 if (tx.getAccessWidth() != pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 return tx.setReturnData32((uint32_t)registerRead(tx.getAddress()));
 
}
}

#line 469 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL370_HDLCD::abstract_port__device__write(pv::WriteTransaction tx)
{
 if (tx.getAccessWidth() != pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 registerWrite(tx.getAddress(),tx.getData32());
 return tx.writeComplete();
 
}
}

#line 476 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL370_HDLCD::abstract_port__device__debugRead(pv::ReadTransaction tx)
{
 return device.read(tx);
 
}
}

#line 481 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL370_HDLCD::abstract_port__device__debugWrite(pv::WriteTransaction tx)
{
 return device.write(tx);
 
}
}

#line 541 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL370_HDLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL370_HDLCD::abstract_port__timer_callback_handler__signal()
{
 return timer_callback();
 
}
}

#line 4726 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PL370_HDLCD
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PL370_HDLCD::Component__PL370_HDLCD(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,diagnostic(GetParameterValue(params, "diagnostic", MxS64CONST(0x0), MxS64CONST(0x0), MxS64CONST(0x4)))


	,cadiParameterProxy_busslave_of_PVBusSlave_to_PL370_HDLCD__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "ARM PrimeCell HD Color LCD Controller(Nominal Designation PL370)";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PL370_HDLCD_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		sg::ComponentFactory *PVBusMaster_factory = PVBusMaster_GetFactory();
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_busslave__ = params.getParamsFor("busslave");
			params_busslave__["size"] = MxU64CONST(0x0000000000001000);
			add(busslave = PVBusSlave_factory->instantiate("busslave", simulationContext, params_busslave__));
		}
		{
			sg::Params params_busmaster__ = params.getParamsFor("busmaster");
			add(busmaster = PVBusMaster_factory->instantiate("busmaster", simulationContext, params_busmaster__));
		}
		{
			sg::Params params_timer__ = params.getParamsFor("timer");
			add(timer = ClockTimer_factory->instantiate("timer", simulationContext, params_timer__));
		}
		ClockTimer_factory->dereference();
		PVBusMaster_factory->dereference();
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PL370_HDLCD::control_port__configure, this);
    bind_method(control_port, init, &Component__PL370_HDLCD::init, this);
    bind_method(control_port, interconnect, &Component__PL370_HDLCD::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PL370_HDLCD::postConnect, this);
    bind_method(control_port, reset, &Component__PL370_HDLCD::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PL370_HDLCD::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PL370_HDLCD::disconnect, this);
    bind_method(control_port, terminate, &Component__PL370_HDLCD::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PL370_HDLCD::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PL370_HDLCD::refresh, this);
    bind_method(control_port, step, &Component__PL370_HDLCD::step, this);
    bind_method(control_port, update, &Component__PL370_HDLCD::update, this);
    bind_method(control_port, communicate, &Component__PL370_HDLCD::communicate, this);
    bind_method(control_port, getProperty, &Component__PL370_HDLCD::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PL370_HDLCD::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PL370_HDLCD::control_port__bypass, this);
    bind_method(control_port, run, &Component__PL370_HDLCD::control_port__run, this);
    bind_method(control_port, stop, &Component__PL370_HDLCD::control_port__stop, this);
    bind_method(control_port, idle, &Component__PL370_HDLCD::control_port__idle, this);
    bind_method(control_port, quit, &Component__PL370_HDLCD::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PL370_HDLCD::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PL370_HDLCD::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PL370_HDLCD::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PL370_HDLCD::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PL370_HDLCD::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PL370_HDLCD::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PL370_HDLCD::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PL370_HDLCD::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_busslave__.connectTo(busslave->findPort("$control"));
	controlPort_busmaster__.connectTo(busmaster->findPort("$control"));
	controlPort_timer__.connectTo(timer->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(device, read, &Component__PL370_HDLCD::abstract_port__device__read, this);
	bind_method(device, write, &Component__PL370_HDLCD::abstract_port__device__write, this);
	bind_method(device, debugRead, &Component__PL370_HDLCD::abstract_port__device__debugRead, this);
	bind_method(device, debugWrite, &Component__PL370_HDLCD::abstract_port__device__debugWrite, this);
	bind_method(timer_callback_handler, signal, &Component__PL370_HDLCD::abstract_port__timer_callback_handler__signal, this);


    // add abstract ports
	device.SetName__("device");
	publishSlavePort("clk_in", clk_in);
	clk_in.SetName__("clk_in");
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	publishMasterPort("display", display);
	display.SetName__("display");
	publishMasterPort("intr", intr);
	intr.SetName__("intr");
	publishMasterPort("pvbus_m", pvbus_m);
	pvbus_m.SetName__("pvbus_m");
	timer_callback_handler.SetName__("timer_callback_handler");
	__PL370_HDLCD_internal_1.SetName__("__PL370_HDLCD_internal_1");


    // wire up static connection map
	pvbus.connectTo(busslave->findPort("pvbus_s"));
	busslave->findPort("device").connectTo(device);
	clk_in.connectTo(timer->findPort("clk_in"));
	timer->findPort("timer_callback").connectTo(timer_callback_handler);
	busmaster->findPort("pvbus_m").connectTo(pvbus_m);
	__PL370_HDLCD_internal_1.connectTo(timer->findPort("timer_control"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PL370_HDLCD::~Component__PL370_HDLCD()
{
}

void Component__PL370_HDLCD::control_port__configure(const sg::Params& params)
{
	if(controlPort_busslave__.configure.implemented()) controlPort_busslave__.configure(params.getParamsFor("busslave"));
	if(controlPort_busmaster__.configure.implemented()) controlPort_busmaster__.configure(params.getParamsFor("busmaster"));
	if(controlPort_timer__.configure.implemented()) controlPort_timer__.configure(params.getParamsFor("timer"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PL370_HDLCD_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PL370_HDLCD::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busslave__.populateCADIMap.implemented())
			{
				controlPort_busslave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("busslave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_busslave_of_PVBusSlave_to_PL370_HDLCD__ = new CADIParameterProxy(cadi, &parameterFilter_busslave_of_PVBusSlave_to_PL370_HDLCD__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busmaster__.populateCADIMap.implemented())
			{
				controlPort_busmaster__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_timer__.populateCADIMap.implemented())
			{
				controlPort_timer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PL370_HDLCD::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PL370_HDLCD::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PL370_HDLCD::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PL370_HDLCD::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PL370_HDLCD::control_port__run()
{
}


void Component__PL370_HDLCD::control_port__stop()
{
}


void Component__PL370_HDLCD::control_port__idle()
{
}


void Component__PL370_HDLCD::control_port__quit()
{
}


void Component__PL370_HDLCD::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PL370_HDLCD::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PL370_HDLCD::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PL370_HDLCD::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PL370_HDLCD::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PL370_HDLCD::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_busslave_of_PVBusSlave_to_PL370_HDLCD__;
	cadiParameterProxy_busslave_of_PVBusSlave_to_PL370_HDLCD__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PL370_HDLCD::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PL370_HDLCD::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PL370_HDLCD::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PL370_HDLCD::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_diagnostic: *data = diagnostic; break;

        default:
            printf("error: Component__PL370_HDLCD::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL370_HDLCD::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL370_HDLCD::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL370_HDLCD::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_diagnostic:
		{
			*(const_cast<uint32_t*>(&diagnostic)) = *data;
		}
		break;

        default:
            printf("error: Component__PL370_HDLCD::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL370_HDLCD::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL370_HDLCD::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PL370_HDLCD::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PL370_HDLCD::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PL370_HDLCD::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PL370_HDLCD::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PL370_HDLCD::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PL370_HDLCD::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PL370_HDLCD::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PL370_HDLCD::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PL370_HDLCD::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "diagnostic") id = PARAMETER_ID_diagnostic;

    return id;
}

void Component__PL370_HDLCD::reset_resources__()
{
    // resource initialization code
	HDLCD_VERSION = 0; // reset register
	HDLCD_INT_RAWSTAT = 0; // reset register
	HDLCD_INT_CLEAR = 0; // reset register
	HDLCD_INT_MASK = 0; // reset register
	HDLCD_INT_STATUS = 0; // reset register
	HDLCD_FB_BASE = 0; // reset register
	HDLCD_FB_LINE_LENGTH = 0; // reset register
	HDLCD_FB_LINE_COUNT = 0; // reset register
	HDLCD_FB_LINE_PITCH = 0; // reset register
	HDLCD_BUS_OPTIONS = 0; // reset register
	HDLCD_V_SYNC = 0; // reset register
	HDLCD_V_BACK_PORCH = 0; // reset register
	HDLCD_V_DATA = 0; // reset register
	HDLCD_V_FRONT_PORCH = 0; // reset register
	HDLCD_H_SYNC = 0; // reset register
	HDLCD_H_BACK_PORCH = 0; // reset register
	HDLCD_H_DATA = 0; // reset register
	HDLCD_H_FRONT_PORCH = 0; // reset register
	HDLCD_POLARITIES = 0; // reset register
	HDLCD_COMMAND = 0; // reset register
	HDLCD_PIXELFORMAT = 0; // reset register
	HDLCD_REDSELECT = 0; // reset register
	HDLCD_GREENSELECT = 0; // reset register
	HDLCD_BLUESELECT = 0; // reset register
	HDLCDPERIPHID0 = 0; // reset register
	HDLCDPERIPHID1 = 0; // reset register
	HDLCDPERIPHID2 = 0; // reset register
	HDLCDPERIPHID3 = 0; // reset register
	HDLCDPCELLID0 = 0; // reset register
	HDLCDPCELLID1 = 0; // reset register
	HDLCDPCELLID2 = 0; // reset register
	HDLCDPCELLID3 = 0; // reset register

}


} // FVP_VE_Cortex_A15x1_NMS
#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::interconnect()
{;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::disconnect()
{;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::update()
{;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::communicate()
{;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::traceEndOfCycle()
{;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::loadApplicationFile(const std::string& filename)
{;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::init()
{;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::terminate()
{;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::reset(int level)
{;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEInterruptMapper::save(MxODataStream& os)
{;return true;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEInterruptMapper::restore(MxIDataStream& is)
{;return true;
}
}

#line 4 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::step()
{;
}
}

#line 21 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEInterruptMapper.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEInterruptMapper::abstract_port__irq_in__setValue(uint32_t index, sg::Signal::State state)
{
 if (!0) ; else printf("VEInterruptMapper: Received %s signal from int %d\n", state==sg::Signal::Set? "Set":"Clear", index);
 irq_out[index].setValue(state); 
 
}
}

#line 5465 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__VEInterruptMapper
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__VEInterruptMapper::Component__VEInterruptMapper(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)




{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Interrupt Mapping peripheral (non-cascaded)";
	properties__["documentation_file"] = "";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = VEInterruptMapper_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__VEInterruptMapper::control_port__configure, this);
    bind_method(control_port, init, &Component__VEInterruptMapper::init, this);
    bind_method(control_port, interconnect, &Component__VEInterruptMapper::interconnect, this);
//  bind_method(control_port, postConnect, &Component__VEInterruptMapper::postConnect, this);
    bind_method(control_port, reset, &Component__VEInterruptMapper::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__VEInterruptMapper::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__VEInterruptMapper::disconnect, this);
    bind_method(control_port, terminate, &Component__VEInterruptMapper::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__VEInterruptMapper::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__VEInterruptMapper::refresh, this);
    bind_method(control_port, step, &Component__VEInterruptMapper::step, this);
    bind_method(control_port, update, &Component__VEInterruptMapper::update, this);
    bind_method(control_port, communicate, &Component__VEInterruptMapper::communicate, this);
    bind_method(control_port, getProperty, &Component__VEInterruptMapper::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__VEInterruptMapper::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__VEInterruptMapper::control_port__bypass, this);
    bind_method(control_port, run, &Component__VEInterruptMapper::control_port__run, this);
    bind_method(control_port, stop, &Component__VEInterruptMapper::control_port__stop, this);
    bind_method(control_port, idle, &Component__VEInterruptMapper::control_port__idle, this);
    bind_method(control_port, quit, &Component__VEInterruptMapper::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__VEInterruptMapper::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__VEInterruptMapper::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__VEInterruptMapper::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__VEInterruptMapper::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__VEInterruptMapper::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__VEInterruptMapper::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__VEInterruptMapper::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__VEInterruptMapper::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_vector_method(irq_in, setValue, 48, &Component__VEInterruptMapper::abstract_port__irq_in__setValue, this);


    // add abstract ports
	publishSlavePortArray("irq_in", irq_in, 48);
	{for(int i = 0; i < 48; ++i) irq_in[i].SetName__("irq_in");}
	publishMasterPortArray("irq_out", irq_out, 224);
	{for(int i = 0; i < 224; ++i) irq_out[i].SetName__("irq_out");}


    // wire up static connection map


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__VEInterruptMapper::~Component__VEInterruptMapper()
{
}

void Component__VEInterruptMapper::control_port__configure(const sg::Params& params)
{


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__VEInterruptMapper_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__VEInterruptMapper::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";


    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__VEInterruptMapper::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__VEInterruptMapper::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__VEInterruptMapper::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__VEInterruptMapper::control_port__bypass(const std::string&)
{
    return "";
}


void Component__VEInterruptMapper::control_port__run()
{
}


void Component__VEInterruptMapper::control_port__stop()
{
}


void Component__VEInterruptMapper::control_port__idle()
{
}


void Component__VEInterruptMapper::control_port__quit()
{
}


void Component__VEInterruptMapper::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__VEInterruptMapper::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__VEInterruptMapper::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__VEInterruptMapper::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__VEInterruptMapper::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__VEInterruptMapper::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__VEInterruptMapper::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__VEInterruptMapper::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__VEInterruptMapper::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__VEInterruptMapper::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__VEInterruptMapper::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEInterruptMapper::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VEInterruptMapper::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEInterruptMapper::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__VEInterruptMapper::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEInterruptMapper::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VEInterruptMapper::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__VEInterruptMapper::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__VEInterruptMapper::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__VEInterruptMapper::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__VEInterruptMapper::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__VEInterruptMapper::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__VEInterruptMapper::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__VEInterruptMapper::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__VEInterruptMapper::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__VEInterruptMapper::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__VEInterruptMapper::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 218 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::do_read(pv::bus_addr_t address, int width, uint32_t* data)
{
 uint32_t block = address_to_block(address); 
 uint32_t word;
 int access_type;

 if (block == edit_block) { 
 access_type = edit_state; 
 } else {
 access_type = 0x00FF00FF; 
 }

 switch (access_type & 0xff) {
 case 0x00FF00FF & 0xff: 
 flash_read(address, width, data);
 if ((edit_state & 0xff) == (0x00FF00FF & 0xff)) {
 clear_read_special();
 }
 return;

 case 0x00900090 & 0xff: 
 cfi_read(address % 8, &word);
 break;

 case 0x00D000D0 & 0xff:
 case 0x70707070 & 0xff:
 case 0x00E800E8 & 0xff:
 case 0x00010001 & 0xff:
 word = 0x00800080; 
 break;

 case 0x00980098 & 0xff:
 cfi_read(address, &word); 
 break;
 default:
 word = 0xdeaddead;
 break;
 }

 switch (width) { 
 case 1: *data = word & 0xff; break;
 case 2: *data = word & 0xffff; break;
 case 4: *data = word; break;
 }
 
}
}

#line 266 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::erase(pv::bus_addr_t base, pv::bus_addr_t end)
{
 pv::bus_addr_t next_block;

 assert((base & 0x7) == 0);
 assert((end & 0x7) == 0);

 while (base < end) {
 uint32_t* storage = (uint32_t *)mbs_control.getWriteStorage(base, &next_block);
 assert((next_block & 0x7) == 0);

 for (; base < next_block; base += 8, storage += 2) {
 storage[0] = 0xffffffff;
 storage[1] = 0xffffffff;
 }
 }
 
}
}

#line 285 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::flash_write(pv::bus_addr_t address, int width, const uint32_t* data)
{
 uint8_t* storage = mbs_control.getWriteStorage(address, NULL);
 switch (width) {
 case 1: *storage = (*storage & 0x00) | (uint8_t) *data; break;
 case 2: *(uint16_t *)storage = (*(uint16_t *)storage & 0x0000) | (uint16_t) *data; break;
 case 4: *(uint32_t *)storage = (*(uint32_t *)storage & 0x00000000) | (uint32_t) *data; break;
 }
 
}
}

#line 295 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::do_write(pv::bus_addr_t address, int width, uint32_t* data)
{
 uint32_t block = address_to_block(address);

 if (block == edit_block &&
 ((edit_state & 0xff) == (0x00100010 & 0xff) ||
 (edit_state & 0xff) == (0x00400040 & 0xff)))
 {
 flash_write(address, width, data);
 edit_state = 0x00D000D0;
 return;
 }
 else if ((edit_state & 0xff) == (0x00E800E8 & 0xff))
 {
 switch (block_write_state)
 {
 case IntelStrataFlashJ3_BLOCK_WRITE_COUNT:
 if (block == edit_block)
 {
 block_write_count = ((*data & 0xff) + 1)*4; 
 block_write_state = IntelStrataFlashJ3_BLOCK_WRITE_START;
 return;
 }
 break;
 case IntelStrataFlashJ3_BLOCK_WRITE_START:
 
 block_write_address = address;
 block_write_state = IntelStrataFlashJ3_BLOCK_WRITE_CONTINUE;
 
 case IntelStrataFlashJ3_BLOCK_WRITE_CONTINUE:
 if (address >= block_write_address &&
 address <= block_write_address+0x80-width)
 {
 
 flash_write(address,width,data);

 block_write_count -= width;

 if (block_write_count == 0)
 edit_state = 0x00D000D0;

 return;
 }
 else
 {
 
 edit_state = 0x00D000D0;
 return;
 }
 break;
 }
 }

 switch(*data & 0xff) {
 case 0x00200020 & 0xff:
 {
 uint32_t offset = address_to_offset(address) / 4;
 if (offset == 0) {
 uint32_t block = address_to_block(address);
 erase(block_to_address(block),
 block_to_address(block + 1));
 }
 }
 break;
 case 0x00010001 & 0xff:
 if (edit_state != 0x00600060 || block != edit_block)
 {
 }
 break;
 case 0x00E800E8 & 0xff:
 block_write_state = IntelStrataFlashJ3_BLOCK_WRITE_COUNT;
 break;
 default:
 break;
 }

 edit_state = *data;
 set_edit_block(block);
 
}
}

#line 375 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::cfi_read(pv::bus_addr_t address, uint32_t* data)
{
 uint32_t offset = (address_to_offset(address) / 4) & 0xffff;

 if (offset > cfi_length()) {
 *data = 0;
 }
 else {
 uint32_t value = (uint32_t)(cfi_data[offset]);
 *data = value | (value << 16);
 }
 
}
}

#line 388 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::set_read_special(pv::bus_addr_t base, pv::bus_addr_t end)
{
 mbs_control.setAccess(base, end, pv::ACCESSTYPE_READ, pv::ACCESSMODE_DEVICE);
 
}
}

#line 393 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::set_edit_block(uint32_t block)
{
 if (block != edit_block && in_read_special_mode) {
 set_read_array(block_to_address(edit_block),
 block_to_address(edit_block + 1));
 }
 if (block != edit_block || !in_read_special_mode) {
 edit_block = block;
 set_read_special(block_to_address(block),
 block_to_address(block + 1));
 in_read_special_mode = true;
 }
 
}
}

#line 407 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__IntelStrataFlashJ3::address_to_offset(pv::bus_addr_t address)
{
 return (uint32_t)(address & ((1 << block_size_bits) - 1));
 
}
}

#line 412 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__IntelStrataFlashJ3::cfi_length()
{
 return sizeof(cfi_data) / sizeof(cfi_data[0]);
 
}
}

#line 417 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__IntelStrataFlashJ3::address_to_block(pv::bus_addr_t address)
{
 return (uint32_t)(address >> (block_size_bits));
 
}
}

#line 422 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::flash_read(pv::bus_addr_t address, int width, uint32_t* data)
{
 uint8_t const* storage = mbs_control.getReadStorage(address, NULL);
 switch (width) {
 case 1: *data = (uint32_t)(*storage);
 case 2: *data = (uint32_t)(*(uint16_t*)storage);
 case 4: *data = *(uint32_t*)storage;
 }
 
}
}

#line 432 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::clear_read_special()
{
 if (in_read_special_mode) {
 set_read_array(block_to_address(edit_block),
 block_to_address(edit_block+1));
 in_read_special_mode = false;
 }
 
}
}

#line 441 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::bus_addr_t 
Component__IntelStrataFlashJ3::block_to_address(uint32_t block)
{
 return ((pv::bus_addr_t)block) << block_size_bits;
 
}
}

#line 446 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::set_read_array(pv::bus_addr_t base, pv::bus_addr_t end)
{
 mbs_control.setAccess(base, end,
 pv::ACCESSTYPE_READ,
 pv::ACCESSMODE_MEMORY);
 
}
}

#line 453 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::bus_addr_t 
Component__IntelStrataFlashJ3::get_size()
{
 return bytes;
 
}
}

#line 458 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__IntelStrataFlashJ3::get_size_shift(uint32_t size)
{
 uint32_t shift=0;
 while(size != 2)
 {
 size=size>>1;
 shift++;
 }

 return shift;
 
}
}

#line 470 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::init()
{
 {if(!controlPort_mbs__.init.empty()) controlPort_mbs__.init();};
 
 bytes = size;
 block_size_bits = 18;
 blocks = address_to_block(get_size());
 edit_block = (uint32_t)-1;
 edit_state = 0x00FF00FF;
 erase_region_size = (1 << block_size_bits)/2;
 in_read_special_mode = false;

 fill1 = 0xe7ff0010;
 fill2 = 0xe800e800;
 mbs_control.setFillPattern(fill1, fill2);
 mbs_control.setAccess(0, bytes, pv::ACCESSTYPE_WRITE, pv::ACCESSMODE_DEVICE);
 
 set_read_array(0, bytes);


 const uint8_t cfi_default_data[] = {
 0x89, 0x18, 
 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

 0x51, 
 0x52, 
 0x59, 

 0x01, 
 0x00, 

 0x31, 
 0x00, 

 0x00, 
 0x00, 

 0x00, 
 0x00, 

 0x27, 
 0x36, 
 0x00, 
 0x00, 
 0x07, 
 0x07, 
 0x0a, 
 0x00, 
 0x04, 
 0x04, 
 0x04, 
 0x00, 
 0x18, 

 0x02, 
 0x00, 

 0x05, 
 0x00, 

 0x01, 

 
 0x7f, 
 0, 

 0, 
 2, 
 

 
 0x50, 
 0x52, 
 0x49, 
 0x31, 
 0x31, 

 0x00, 
 0x00, 
 0x00, 
 0x00, 

 0x00, 

 0x00, 
 0x00, 

 0x50, 
 0x50, 
 0x00, 
 };

 memcpy((void *)cfi_data, (void *)cfi_default_data, sizeof(cfi_default_data)/sizeof(cfi_default_data[0]));

 cfi_data[0x2d] = (uint8_t)((blocks - 1) & 0xff); 
 cfi_data[0x2e] = (uint8_t)((blocks - 1) >> 8);
 cfi_data[0x2f] = (uint8_t)((erase_region_size / 256) & 0xff);
 cfi_data[0x30] = (uint8_t)((erase_region_size / 256) >> 8);
 cfi_data[0x27] = (uint8_t)(get_size_shift(size));
 
}
}

#line 582 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__IntelStrataFlashJ3::debug_read(uint32_t , uint32_t , uint64_t offset, uint32_t size_in_maus, uint64_t* data, bool , sg::MemoryAccessContext* mac)
{
 pv::bus_addr_t start_address = offset % size;
 uint8_t * ptr = (uint8_t *)data;
 uint32_t size_in_bytes = size_in_maus * mac->GetMauInBytes();

 while (size_in_bytes > 0) {
 pv::bus_addr_t block_limit;
 uint8_t const *storage = mbs_control.getReadStorage(start_address,
 &block_limit);
 uint32_t transfer_bytes = block_limit - start_address;
 if (transfer_bytes > size_in_bytes) transfer_bytes = size_in_bytes;
 if (transfer_bytes == 0) break;

 memcpy(ptr, storage, transfer_bytes);

 size_in_bytes -= transfer_bytes;
 start_address = (start_address + transfer_bytes) % size;
 ptr += transfer_bytes;
 }
 return ACCESS_FUNC_OK;
 
}
}

#line 612 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__IntelStrataFlashJ3::debug_write(uint32_t , uint32_t , uint64_t offset, uint32_t size_in_maus, const uint64_t* data, bool , sg::MemoryAccessContext* mac)
{
 pv::bus_addr_t start_address = offset % size;
 uint8_t const *ptr = (uint8_t *)data;
 uint32_t size_in_bytes = size_in_maus * mac->GetMauInBytes();

 while (size_in_bytes > 0) {
 pv::bus_addr_t block_limit;
 uint8_t * storage = mbs_control.getWriteStorage(start_address,
 &block_limit);
 uint32_t transfer_bytes = block_limit - start_address;
 if (transfer_bytes > size_in_bytes) transfer_bytes = size_in_bytes;
 if (transfer_bytes == 0) break;

 memcpy(storage, ptr, transfer_bytes);

 size_in_bytes -= transfer_bytes;
 start_address = (start_address + transfer_bytes) % size;
 ptr += transfer_bytes;
 }
 return ACCESS_FUNC_OK;
 
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::interconnect()
{{if(!controlPort_mbs__.interconnect.empty()) controlPort_mbs__.interconnect();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::disconnect()
{{if(!controlPort_mbs__.disconnect.empty()) controlPort_mbs__.disconnect();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::update()
{{if(!controlPort_mbs__.update.empty()) controlPort_mbs__.update();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::communicate()
{{if(!controlPort_mbs__.communicate.empty()) controlPort_mbs__.communicate();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::traceEndOfCycle()
{{if(!controlPort_mbs__.traceEndOfCycle.empty()) controlPort_mbs__.traceEndOfCycle();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::loadApplicationFile(const std::string& filename)
{{if(!controlPort_mbs__.loadApplicationFile.empty()) controlPort_mbs__.loadApplicationFile(filename);};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::terminate()
{{if(!controlPort_mbs__.terminate.empty()) controlPort_mbs__.terminate();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::reset(int level)
{{if(!controlPort_mbs__.reset.empty()) controlPort_mbs__.reset(level);};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__IntelStrataFlashJ3::save(MxODataStream& os)
{{if(!controlPort_mbs__.save.empty()) controlPort_mbs__.save(os);};return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__IntelStrataFlashJ3::restore(MxIDataStream& is)
{{if(!controlPort_mbs__.restore.empty()) controlPort_mbs__.restore(is);};return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__IntelStrataFlashJ3::step()
{{if(!controlPort_mbs__.step.empty()) controlPort_mbs__.step();};
}
}

#line 76 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__IntelStrataFlashJ3::abstract_port__mem_port__read(pv::ReadTransaction tx)
{
 
 
 
 

 
 if (!tx.isAligned()) return tx.generateAbort();

 
 
 switch (tx.getAccessWidth())
 {
 case pv::ACCESS_8_BITS: case pv::ACCESS_16_BITS: case pv::ACCESS_32_BITS:
 {
 uint32_t data;
 do_read(tx.getAddress(), tx.getAccessByteWidth(), &data);
 return tx.setReturnData32(data);
 }
 case pv::ACCESS_64_BITS:
 {
 uint32_t datalo;
 uint32_t datahi;
 do_read(tx.getAddress(), 4, &datalo);
 do_read(tx.getAddress()+4, 4, &datahi);
 const uint64_t data = uint64_t(datalo) | (uint64_t(datahi) << 32);
 return tx.setReturnData64(data);
 }
 default:
 
 return tx.readComplete();
 }
 
}
}

#line 111 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__IntelStrataFlashJ3::abstract_port__mem_port__write(pv::WriteTransaction tx)
{
 
 if (!tx.isAligned()) return tx.generateAbort();

 uint32_t data;
 switch (tx.getAccessWidth())
 {
 case pv::ACCESS_8_BITS: data = tx.getData8(); break;
 case pv::ACCESS_16_BITS: data = tx.getData16(); break;
 case pv::ACCESS_32_BITS: data = tx.getData32(); break;
 case pv::ACCESS_64_BITS:
 {
 
 
 uint32_t datalo = uint32_t(tx.getData64() & 0x00000000FFFFFFFFull);
 uint32_t datahi = uint32_t((tx.getData64() & 0xFFFFFFFF00000000ull) >> 32);
 do_write(tx.getAddress(), 4, &datalo);
 do_write(tx.getAddress()+4, 4, &datahi);
 return tx.writeComplete();
 }
 default:
 
 return tx.writeComplete();
 }
 do_write(tx.getAddress(), tx.getAccessByteWidth(), &data);
 return tx.writeComplete();
 
}
}

#line 140 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__IntelStrataFlashJ3::abstract_port__mem_port__debugRead(pv::ReadTransaction tx)
{
 return mem_port.read(tx);
 
}
}

#line 145 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__IntelStrataFlashJ3::abstract_port__mem_port__debugWrite(pv::WriteTransaction tx)
{
 
 pv::bus_addr_t limit;
 uint8_t* storage = mbs_control.getWriteStorage(tx.getAddress(), &limit);

 unsigned const access_width_in_bytes = tx.getAccessByteWidth();
 if (tx.getAddress() + access_width_in_bytes - 1 <= limit)
 {
 switch (access_width_in_bytes)
 {
 case 1:
 *storage = tx.getData8();
 break;
 case 2:
 *(uint16_t *)storage = tx.getData16();
 break;
 case 4:
 *(uint32_t *)storage = tx.getData32();
 break;
 case 8:
 *(uint64_t *)storage = tx.getData64();
 break;
 default:
 return tx.generateAbort();
 }
 return tx.writeComplete();
 }
 return tx.generateAbort();
 
}
}

#line 179 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__IntelStrataFlashJ3::abstract_port__flashloader__loadFlashFile(FlashLoader* loader)
{
 uint8_t *buffer;
 size_t block_size;
 pv::bus_addr_t device_addr = 0;
 pv::bus_addr_t page_limit = 0;

 while (device_addr < bytes) { 
 buffer = mbs_control.getWriteStorage(device_addr, &page_limit);
 block_size = (size_t)(page_limit - device_addr);

 size_t count = loader->readData(buffer, block_size); 
 device_addr += count;
 if (count < block_size) {
 break; 
 }

 }
 return (uint32_t)device_addr;
 
}
}

#line 199 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/Common/LISA/IntelStrataFlashJ3.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__IntelStrataFlashJ3::abstract_port__flashloader__saveFlashFile(FlashLoader* loader)
{
 const uint8_t *buffer;
 size_t block_size;
 pv::bus_addr_t device_addr = 0;
 pv::bus_addr_t page_limit = 0;

 while (device_addr < bytes) {
 buffer = mbs_control.getReadStorage(device_addr, &page_limit);
 block_size = (size_t)((bytes<page_limit?bytes:page_limit) - device_addr);

 size_t count = loader->writeData(buffer, block_size);
 device_addr += count;
 }
 return (uint32_t)device_addr;
 
}
}

#line 6707 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__IntelStrataFlashJ3
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__IntelStrataFlashJ3::Component__IntelStrataFlashJ3(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,size(GetParameterValue(params, "size", MxS64CONST(0x1000), MxS64CONST(0x4), MxS64CONST(0xffffffff)))


	,cadiParameterProxy_mbs_of_PVBusSlave_to_IntelStrataFlashJ3__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Intel Strata Flash J3 LISA+ model.";
	properties__["documentation_file"] = "";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = IntelStrataFlashJ3_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_mbs__ = params.getParamsFor("mbs");
			params_mbs__["size"] = size;
			add(mbs = PVBusSlave_factory->instantiate("mbs", simulationContext, params_mbs__));
		}
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__IntelStrataFlashJ3::control_port__configure, this);
    bind_method(control_port, init, &Component__IntelStrataFlashJ3::init, this);
    bind_method(control_port, interconnect, &Component__IntelStrataFlashJ3::interconnect, this);
//  bind_method(control_port, postConnect, &Component__IntelStrataFlashJ3::postConnect, this);
    bind_method(control_port, reset, &Component__IntelStrataFlashJ3::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__IntelStrataFlashJ3::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__IntelStrataFlashJ3::disconnect, this);
    bind_method(control_port, terminate, &Component__IntelStrataFlashJ3::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__IntelStrataFlashJ3::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__IntelStrataFlashJ3::refresh, this);
    bind_method(control_port, step, &Component__IntelStrataFlashJ3::step, this);
    bind_method(control_port, update, &Component__IntelStrataFlashJ3::update, this);
    bind_method(control_port, communicate, &Component__IntelStrataFlashJ3::communicate, this);
    bind_method(control_port, getProperty, &Component__IntelStrataFlashJ3::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__IntelStrataFlashJ3::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__IntelStrataFlashJ3::control_port__bypass, this);
    bind_method(control_port, run, &Component__IntelStrataFlashJ3::control_port__run, this);
    bind_method(control_port, stop, &Component__IntelStrataFlashJ3::control_port__stop, this);
    bind_method(control_port, idle, &Component__IntelStrataFlashJ3::control_port__idle, this);
    bind_method(control_port, quit, &Component__IntelStrataFlashJ3::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__IntelStrataFlashJ3::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__IntelStrataFlashJ3::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__IntelStrataFlashJ3::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__IntelStrataFlashJ3::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__IntelStrataFlashJ3::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__IntelStrataFlashJ3::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__IntelStrataFlashJ3::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__IntelStrataFlashJ3::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_mbs__.connectTo(mbs->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(mem_port, read, &Component__IntelStrataFlashJ3::abstract_port__mem_port__read, this);
	bind_method(mem_port, write, &Component__IntelStrataFlashJ3::abstract_port__mem_port__write, this);
	bind_method(mem_port, debugRead, &Component__IntelStrataFlashJ3::abstract_port__mem_port__debugRead, this);
	bind_method(mem_port, debugWrite, &Component__IntelStrataFlashJ3::abstract_port__mem_port__debugWrite, this);
	bind_method(flashloader, loadFlashFile, &Component__IntelStrataFlashJ3::abstract_port__flashloader__loadFlashFile, this);
	bind_method(flashloader, saveFlashFile, &Component__IntelStrataFlashJ3::abstract_port__flashloader__saveFlashFile, this);


    // add abstract ports
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	publishMasterPort("mbs_control", mbs_control);
	mbs_control.SetName__("mbs_control");
	publishSlavePort("mem_port", mem_port);
	mem_port.SetName__("mem_port");
	publishSlavePort("flashloader", flashloader);
	flashloader.SetName__("flashloader");


    // wire up static connection map
	pvbus.connectTo(mbs->findPort("pvbus_s"));
	mbs_control.connectTo(mbs->findPort("control"));
	mbs->findPort("device").connectTo(mem_port);


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__IntelStrataFlashJ3::~Component__IntelStrataFlashJ3()
{
}

void Component__IntelStrataFlashJ3::control_port__configure(const sg::Params& params)
{
	if(controlPort_mbs__.configure.implemented()) controlPort_mbs__.configure(params.getParamsFor("mbs"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__IntelStrataFlashJ3_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__IntelStrataFlashJ3::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_mbs__.populateCADIMap.implemented())
			{
				controlPort_mbs__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("mbs", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_mbs_of_PVBusSlave_to_IntelStrataFlashJ3__ = new CADIParameterProxy(cadi, &parameterFilter_mbs_of_PVBusSlave_to_IntelStrataFlashJ3__);
			}
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__IntelStrataFlashJ3::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__IntelStrataFlashJ3::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__IntelStrataFlashJ3::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__IntelStrataFlashJ3::control_port__bypass(const std::string&)
{
    return "";
}


void Component__IntelStrataFlashJ3::control_port__run()
{
}


void Component__IntelStrataFlashJ3::control_port__stop()
{
}


void Component__IntelStrataFlashJ3::control_port__idle()
{
}


void Component__IntelStrataFlashJ3::control_port__quit()
{
}


void Component__IntelStrataFlashJ3::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__IntelStrataFlashJ3::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__IntelStrataFlashJ3::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__IntelStrataFlashJ3::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__IntelStrataFlashJ3::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__IntelStrataFlashJ3::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_mbs_of_PVBusSlave_to_IntelStrataFlashJ3__;
	cadiParameterProxy_mbs_of_PVBusSlave_to_IntelStrataFlashJ3__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__IntelStrataFlashJ3::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__IntelStrataFlashJ3::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__IntelStrataFlashJ3::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__IntelStrataFlashJ3::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_size: *data = size; break;

        default:
            printf("error: Component__IntelStrataFlashJ3::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__IntelStrataFlashJ3::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__IntelStrataFlashJ3::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__IntelStrataFlashJ3::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_size:
		{
			*(const_cast<uint32_t*>(&size)) = *data;
		}
		break;

        default:
            printf("error: Component__IntelStrataFlashJ3::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__IntelStrataFlashJ3::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__IntelStrataFlashJ3::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__IntelStrataFlashJ3::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__IntelStrataFlashJ3::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__IntelStrataFlashJ3::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__IntelStrataFlashJ3::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__IntelStrataFlashJ3::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__IntelStrataFlashJ3::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__IntelStrataFlashJ3::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__IntelStrataFlashJ3::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__IntelStrataFlashJ3::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "size") id = PARAMETER_ID_size;

    return id;
}

void Component__IntelStrataFlashJ3::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 27 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::interconnect()
{
 FlashLoader loader;
 uint32_t total_count = 0;

 if (fname == "(none)")
 return; 
 if (fname == "") 
 {
 
 message(MSG_WARNING, "%s: FlashLoader: fname parameter is empty. Nothing loaded.\n", getInstancePath().c_str());
 return;
 }
 if (loader.open(fname, OPEN_FOR_READ))
 {
 if (flash_device0.loadFlashFile.implemented()) total_count += flash_device0.loadFlashFile(&loader);
 if (flash_device1.loadFlashFile.implemented()) total_count += flash_device1.loadFlashFile(&loader);
 if (flash_device2.loadFlashFile.implemented()) total_count += flash_device2.loadFlashFile(&loader);
 if (flash_device3.loadFlashFile.implemented()) total_count += flash_device3.loadFlashFile(&loader);

 loader.close();
 message(MSG_INFO, "%s: FlashLoader: Loaded %dMB from file '%s'\n", getInstancePath().c_str(), total_count / (1024*1024), fname.c_str());
 }
 else 
 {
 message(MSG_FATAL_ERROR, "%s: FlashLoader: Error while reading file '%s'!\n", getInstancePath().c_str(), fname.c_str());
 }
 
}
}

#line 56 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::terminate()
{
 FlashLoader loader;
 uint32_t total_count = 0;

 if (fnameWrite == "(none)")
 return; 
 if (fnameWrite == "") 
 {
 
 message(MSG_WARNING, "%s: FlashLoader: fnameWrite parameter is empty. Nothing saved.\n", getInstancePath().c_str());
 return;
 }
 if (loader.open(fnameWrite, OPEN_FOR_WRITE)) 
 {
 if (flash_device0.saveFlashFile.implemented()) total_count += flash_device0.saveFlashFile(&loader);
 if (flash_device1.saveFlashFile.implemented()) total_count += flash_device1.saveFlashFile(&loader);
 if (flash_device2.saveFlashFile.implemented()) total_count += flash_device2.saveFlashFile(&loader);
 if (flash_device3.saveFlashFile.implemented()) total_count += flash_device3.saveFlashFile(&loader);

 loader.close();
 message(MSG_INFO, "%s: FlashLoader: Saved %dMB to file '%s'\n", getInstancePath().c_str(), total_count / (1024*1024), fnameWrite.c_str());
 }
 else
 {
 message(MSG_FATAL_ERROR, "%s: FlashLoader: Error while writing file '%s'!\n", getInstancePath().c_str(), fnameWrite.c_str());
 }
 
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::disconnect()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::update()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::communicate()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::traceEndOfCycle()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::loadApplicationFile(const std::string& filename)
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::init()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::reset(int level)
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__FlashLoader::save(MxODataStream& os)
{;return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__FlashLoader::restore(MxIDataStream& is)
{;return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/FlashLoader.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__FlashLoader::step()
{;
}
}

#line 7417 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__FlashLoader
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__FlashLoader::Component__FlashLoader(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,fname(GetParameterValue(params, "fname", "(none)"))
	,fnameWrite(GetParameterValue(params, "fnameWrite", "(none)"))



{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Other";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "A device that can preload a gzipped image into flash at startup";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = FlashLoader_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__FlashLoader::control_port__configure, this);
    bind_method(control_port, init, &Component__FlashLoader::init, this);
    bind_method(control_port, interconnect, &Component__FlashLoader::interconnect, this);
//  bind_method(control_port, postConnect, &Component__FlashLoader::postConnect, this);
    bind_method(control_port, reset, &Component__FlashLoader::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__FlashLoader::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__FlashLoader::disconnect, this);
    bind_method(control_port, terminate, &Component__FlashLoader::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__FlashLoader::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__FlashLoader::refresh, this);
    bind_method(control_port, step, &Component__FlashLoader::step, this);
    bind_method(control_port, update, &Component__FlashLoader::update, this);
    bind_method(control_port, communicate, &Component__FlashLoader::communicate, this);
    bind_method(control_port, getProperty, &Component__FlashLoader::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__FlashLoader::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__FlashLoader::control_port__bypass, this);
    bind_method(control_port, run, &Component__FlashLoader::control_port__run, this);
    bind_method(control_port, stop, &Component__FlashLoader::control_port__stop, this);
    bind_method(control_port, idle, &Component__FlashLoader::control_port__idle, this);
    bind_method(control_port, quit, &Component__FlashLoader::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__FlashLoader::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__FlashLoader::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__FlashLoader::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__FlashLoader::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__FlashLoader::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__FlashLoader::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__FlashLoader::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__FlashLoader::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports


    // add abstract ports
	publishMasterPort("flash_device0", flash_device0);
	flash_device0.SetName__("flash_device0");
	publishMasterPort("flash_device1", flash_device1);
	flash_device1.SetName__("flash_device1");
	publishMasterPort("flash_device2", flash_device2);
	flash_device2.SetName__("flash_device2");
	publishMasterPort("flash_device3", flash_device3);
	flash_device3.SetName__("flash_device3");


    // wire up static connection map


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__FlashLoader::~Component__FlashLoader()
{
}

void Component__FlashLoader::control_port__configure(const sg::Params& params)
{


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__FlashLoader_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__FlashLoader::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";


    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__FlashLoader::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__FlashLoader::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__FlashLoader::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__FlashLoader::control_port__bypass(const std::string&)
{
    return "";
}


void Component__FlashLoader::control_port__run()
{
}


void Component__FlashLoader::control_port__stop()
{
}


void Component__FlashLoader::control_port__idle()
{
}


void Component__FlashLoader::control_port__quit()
{
}


void Component__FlashLoader::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__FlashLoader::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__FlashLoader::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__FlashLoader::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__FlashLoader::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__FlashLoader::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__FlashLoader::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__FlashLoader::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__FlashLoader::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__FlashLoader::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__FlashLoader::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__FlashLoader::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {
	case PARAMETER_ID_fname:  data = fname; break;
	case PARAMETER_ID_fnameWrite:  data = fnameWrite; break;

        default:
            printf("error: Component__FlashLoader::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__FlashLoader::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__FlashLoader::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__FlashLoader::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {
	case PARAMETER_ID_fname:
		{
			*(const_cast<std::string*>(&fname)) = data;
		}
		break;
	case PARAMETER_ID_fnameWrite:
		{
			*(const_cast<std::string*>(&fnameWrite)) = data;
		}
		break;

        default:
            printf("error: Component__FlashLoader::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__FlashLoader::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__FlashLoader::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__FlashLoader::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__FlashLoader::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__FlashLoader::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__FlashLoader::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__FlashLoader::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__FlashLoader::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__FlashLoader::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "fname") id = PARAMETER_ID_fname;
    if (name == "fnameWrite") id = PARAMETER_ID_fnameWrite;

    return id;
}

void Component__FlashLoader::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 46 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::init()
{
 
}
}

#line 50 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::reset(int level)
{
 clockCLCD[0] = 45000000; 
 clockCLCD[1] = 23750000; 
 clockCLCD[2] = 66670000; 
 
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::interconnect()
{;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::disconnect()
{;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::update()
{;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::communicate()
{;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::traceEndOfCycle()
{;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::loadApplicationFile(const std::string& filename)
{;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::terminate()
{;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEDCC::save(MxODataStream& os)
{;return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEDCC::restore(MxIDataStream& is)
{;return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEDCC::step()
{;
}
}

#line 59 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEDCC::abstract_port__CB__read(const uint8_t func, const uint16_t device, uint32_t* data)
{
 if (!0) ; else printf("VEDCC::read, device: %d, function: %d, data: %d\n", device, func, *data);
 switch (func)
 {
 case SYS_CFG_OSC:
 if (device < 3) 
 {
 *data = clockCLCD[device];
 return true; 
 }
 else
 return false;
 break;
 default:
 return false;
 break;
 }
 
}
}

#line 79 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEDCC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEDCC::abstract_port__CB__write(const uint8_t func, const uint16_t device, const uint32_t data)
{
 if (!0) ; else printf("VEDCC::write, device: %d, function: %d, data: %d\n", device, func, data);
 switch (func)
 {
 case SYS_CFG_OSC:
 if ((device < 3) && OSC[device].set.implemented())
 {
 clockCLCD[device] = data;
 OSC[device].set(clockCLCD[device],1); 
 return true; 
 }
 else
 return false;
 break;
 default:
 return false;
 break;
 }
 
}
}

#line 8094 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__VEDCC
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__VEDCC::Component__VEDCC(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)




{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Other";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Daughterboard Configuration Control (DCC).";
	properties__["documentation_file"] = "../../../Docs/DUI0423G_fast_model_portfolio_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = VEDCC_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__VEDCC::control_port__configure, this);
    bind_method(control_port, init, &Component__VEDCC::init, this);
    bind_method(control_port, interconnect, &Component__VEDCC::interconnect, this);
//  bind_method(control_port, postConnect, &Component__VEDCC::postConnect, this);
    bind_method(control_port, reset, &Component__VEDCC::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__VEDCC::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__VEDCC::disconnect, this);
    bind_method(control_port, terminate, &Component__VEDCC::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__VEDCC::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__VEDCC::refresh, this);
    bind_method(control_port, step, &Component__VEDCC::step, this);
    bind_method(control_port, update, &Component__VEDCC::update, this);
    bind_method(control_port, communicate, &Component__VEDCC::communicate, this);
    bind_method(control_port, getProperty, &Component__VEDCC::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__VEDCC::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__VEDCC::control_port__bypass, this);
    bind_method(control_port, run, &Component__VEDCC::control_port__run, this);
    bind_method(control_port, stop, &Component__VEDCC::control_port__stop, this);
    bind_method(control_port, idle, &Component__VEDCC::control_port__idle, this);
    bind_method(control_port, quit, &Component__VEDCC::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__VEDCC::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__VEDCC::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__VEDCC::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__VEDCC::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__VEDCC::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__VEDCC::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__VEDCC::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__VEDCC::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(CB, read, &Component__VEDCC::abstract_port__CB__read, this);
	bind_method(CB, write, &Component__VEDCC::abstract_port__CB__write, this);


    // add abstract ports
	publishSlavePort("CB", CB);
	CB.SetName__("CB");
	publishMasterPortArray("OSC", OSC, 3);
	{for(int i = 0; i < 3; ++i) OSC[i].SetName__("OSC");}


    // wire up static connection map


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__VEDCC::~Component__VEDCC()
{
}

void Component__VEDCC::control_port__configure(const sg::Params& params)
{


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__VEDCC_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__VEDCC::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";


    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__VEDCC::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__VEDCC::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__VEDCC::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__VEDCC::control_port__bypass(const std::string&)
{
    return "";
}


void Component__VEDCC::control_port__run()
{
}


void Component__VEDCC::control_port__stop()
{
}


void Component__VEDCC::control_port__idle()
{
}


void Component__VEDCC::control_port__quit()
{
}


void Component__VEDCC::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__VEDCC::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__VEDCC::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__VEDCC::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__VEDCC::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__VEDCC::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__VEDCC::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__VEDCC::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__VEDCC::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__VEDCC::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__VEDCC::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEDCC::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VEDCC::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEDCC::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__VEDCC::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEDCC::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VEDCC::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__VEDCC::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__VEDCC::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__VEDCC::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__VEDCC::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__VEDCC::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__VEDCC::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__VEDCC::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__VEDCC::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__VEDCC::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__VEDCC::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::interconnect()
{{if(!controlPort_sp805_wdog__.interconnect.empty()) controlPort_sp805_wdog__.interconnect();if(!controlPort_pl050_kmi1__.interconnect.empty()) controlPort_pl050_kmi1__.interconnect();if(!controlPort_pl050_kmi0__.interconnect.empty()) controlPort_pl050_kmi0__.interconnect();if(!controlPort_Timer_2_3__.interconnect.empty()) controlPort_Timer_2_3__.interconnect();if(!controlPort_Timer_0_1__.interconnect.empty()) controlPort_Timer_0_1__.interconnect();if(!controlPort_sp810_sysctrl__.interconnect.empty()) controlPort_sp810_sysctrl__.interconnect();if(!controlPort_pl111_clcd__.interconnect.empty()) controlPort_pl111_clcd__.interconnect();if(!controlPort_pl031_rtc__.interconnect.empty()) controlPort_pl031_rtc__.interconnect();if(!controlPort_pl011_uart3__.interconnect.empty()) controlPort_pl011_uart3__.interconnect();if(!controlPort_pl011_uart2__.interconnect.empty()) controlPort_pl011_uart2__.interconnect();if(!controlPort_pl011_uart1__.interconnect.empty()) controlPort_pl011_uart1__.interconnect();if(!controlPort_pl011_uart0__.interconnect.empty()) controlPort_pl011_uart0__.interconnect();if(!controlPort_pl180_mci__.interconnect.empty()) controlPort_pl180_mci__.interconnect();if(!controlPort_pl041_aaci__.interconnect.empty()) controlPort_pl041_aaci__.interconnect();if(!controlPort_ve_sysregs__.interconnect.empty()) controlPort_ve_sysregs__.interconnect();if(!controlPort_smsc_91c111__.interconnect.empty()) controlPort_smsc_91c111__.interconnect();if(!controlPort_ps2mouse__.interconnect.empty()) controlPort_ps2mouse__.interconnect();if(!controlPort_ps2keyboard__.interconnect.empty()) controlPort_ps2keyboard__.interconnect();if(!controlPort_mmc__.interconnect.empty()) controlPort_mmc__.interconnect();if(!controlPort_dummy_CF__.interconnect.empty()) controlPort_dummy_CF__.interconnect();if(!controlPort_dummy_usb__.interconnect.empty()) controlPort_dummy_usb__.interconnect();if(!controlPort_dummy_ram__.interconnect.empty()) controlPort_dummy_ram__.interconnect();if(!controlPort_dummy_local_dap_rom__.interconnect.empty()) controlPort_dummy_local_dap_rom__.interconnect();if(!controlPort_psram__.interconnect.empty()) controlPort_psram__.interconnect();if(!controlPort_vram__.interconnect.empty()) controlPort_vram__.interconnect();if(!controlPort_flash1__.interconnect.empty()) controlPort_flash1__.interconnect();if(!controlPort_flash0__.interconnect.empty()) controlPort_flash0__.interconnect();if(!controlPort_flashloader1__.interconnect.empty()) controlPort_flashloader1__.interconnect();if(!controlPort_flashloader0__.interconnect.empty()) controlPort_flashloader0__.interconnect();if(!controlPort_clk__.interconnect.empty()) controlPort_clk__.interconnect();if(!controlPort_clock24MHz__.interconnect.empty()) controlPort_clock24MHz__.interconnect();if(!controlPort_clock100Hz__.interconnect.empty()) controlPort_clock100Hz__.interconnect();if(!controlPort_clockCLCD__.interconnect.empty()) controlPort_clockCLCD__.interconnect();if(!controlPort_clock35MHz__.interconnect.empty()) controlPort_clock35MHz__.interconnect();if(!controlPort_clock50Hz__.interconnect.empty()) controlPort_clock50Hz__.interconnect();if(!controlPort_cs3_decoder__.interconnect.empty()) controlPort_cs3_decoder__.interconnect();if(!controlPort_cs2_decoder__.interconnect.empty()) controlPort_cs2_decoder__.interconnect();if(!controlPort_terminal_0__.interconnect.empty()) controlPort_terminal_0__.interconnect();if(!controlPort_terminal_1__.interconnect.empty()) controlPort_terminal_1__.interconnect();if(!controlPort_terminal_2__.interconnect.empty()) controlPort_terminal_2__.interconnect();if(!controlPort_terminal_3__.interconnect.empty()) controlPort_terminal_3__.interconnect();if(!controlPort_audioout__.interconnect.empty()) controlPort_audioout__.interconnect();if(!controlPort_vis__.interconnect.empty()) controlPort_vis__.interconnect();if(!controlPort_virtualethernetcrossover__.interconnect.empty()) controlPort_virtualethernetcrossover__.interconnect();if(!controlPort_hostbridge__.interconnect.empty()) controlPort_hostbridge__.interconnect();if(!controlPort_vfs2__.interconnect.empty()) controlPort_vfs2__.interconnect();if(!controlPort_virtioblockdevice__.interconnect.empty()) controlPort_virtioblockdevice__.interconnect();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::disconnect()
{{if(!controlPort_sp805_wdog__.disconnect.empty()) controlPort_sp805_wdog__.disconnect();if(!controlPort_pl050_kmi1__.disconnect.empty()) controlPort_pl050_kmi1__.disconnect();if(!controlPort_pl050_kmi0__.disconnect.empty()) controlPort_pl050_kmi0__.disconnect();if(!controlPort_Timer_2_3__.disconnect.empty()) controlPort_Timer_2_3__.disconnect();if(!controlPort_Timer_0_1__.disconnect.empty()) controlPort_Timer_0_1__.disconnect();if(!controlPort_sp810_sysctrl__.disconnect.empty()) controlPort_sp810_sysctrl__.disconnect();if(!controlPort_pl111_clcd__.disconnect.empty()) controlPort_pl111_clcd__.disconnect();if(!controlPort_pl031_rtc__.disconnect.empty()) controlPort_pl031_rtc__.disconnect();if(!controlPort_pl011_uart3__.disconnect.empty()) controlPort_pl011_uart3__.disconnect();if(!controlPort_pl011_uart2__.disconnect.empty()) controlPort_pl011_uart2__.disconnect();if(!controlPort_pl011_uart1__.disconnect.empty()) controlPort_pl011_uart1__.disconnect();if(!controlPort_pl011_uart0__.disconnect.empty()) controlPort_pl011_uart0__.disconnect();if(!controlPort_pl180_mci__.disconnect.empty()) controlPort_pl180_mci__.disconnect();if(!controlPort_pl041_aaci__.disconnect.empty()) controlPort_pl041_aaci__.disconnect();if(!controlPort_ve_sysregs__.disconnect.empty()) controlPort_ve_sysregs__.disconnect();if(!controlPort_smsc_91c111__.disconnect.empty()) controlPort_smsc_91c111__.disconnect();if(!controlPort_ps2mouse__.disconnect.empty()) controlPort_ps2mouse__.disconnect();if(!controlPort_ps2keyboard__.disconnect.empty()) controlPort_ps2keyboard__.disconnect();if(!controlPort_mmc__.disconnect.empty()) controlPort_mmc__.disconnect();if(!controlPort_dummy_CF__.disconnect.empty()) controlPort_dummy_CF__.disconnect();if(!controlPort_dummy_usb__.disconnect.empty()) controlPort_dummy_usb__.disconnect();if(!controlPort_dummy_ram__.disconnect.empty()) controlPort_dummy_ram__.disconnect();if(!controlPort_dummy_local_dap_rom__.disconnect.empty()) controlPort_dummy_local_dap_rom__.disconnect();if(!controlPort_psram__.disconnect.empty()) controlPort_psram__.disconnect();if(!controlPort_vram__.disconnect.empty()) controlPort_vram__.disconnect();if(!controlPort_flash1__.disconnect.empty()) controlPort_flash1__.disconnect();if(!controlPort_flash0__.disconnect.empty()) controlPort_flash0__.disconnect();if(!controlPort_flashloader1__.disconnect.empty()) controlPort_flashloader1__.disconnect();if(!controlPort_flashloader0__.disconnect.empty()) controlPort_flashloader0__.disconnect();if(!controlPort_clk__.disconnect.empty()) controlPort_clk__.disconnect();if(!controlPort_clock24MHz__.disconnect.empty()) controlPort_clock24MHz__.disconnect();if(!controlPort_clock100Hz__.disconnect.empty()) controlPort_clock100Hz__.disconnect();if(!controlPort_clockCLCD__.disconnect.empty()) controlPort_clockCLCD__.disconnect();if(!controlPort_clock35MHz__.disconnect.empty()) controlPort_clock35MHz__.disconnect();if(!controlPort_clock50Hz__.disconnect.empty()) controlPort_clock50Hz__.disconnect();if(!controlPort_cs3_decoder__.disconnect.empty()) controlPort_cs3_decoder__.disconnect();if(!controlPort_cs2_decoder__.disconnect.empty()) controlPort_cs2_decoder__.disconnect();if(!controlPort_terminal_0__.disconnect.empty()) controlPort_terminal_0__.disconnect();if(!controlPort_terminal_1__.disconnect.empty()) controlPort_terminal_1__.disconnect();if(!controlPort_terminal_2__.disconnect.empty()) controlPort_terminal_2__.disconnect();if(!controlPort_terminal_3__.disconnect.empty()) controlPort_terminal_3__.disconnect();if(!controlPort_audioout__.disconnect.empty()) controlPort_audioout__.disconnect();if(!controlPort_vis__.disconnect.empty()) controlPort_vis__.disconnect();if(!controlPort_virtualethernetcrossover__.disconnect.empty()) controlPort_virtualethernetcrossover__.disconnect();if(!controlPort_hostbridge__.disconnect.empty()) controlPort_hostbridge__.disconnect();if(!controlPort_vfs2__.disconnect.empty()) controlPort_vfs2__.disconnect();if(!controlPort_virtioblockdevice__.disconnect.empty()) controlPort_virtioblockdevice__.disconnect();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::update()
{{if(!controlPort_sp805_wdog__.update.empty()) controlPort_sp805_wdog__.update();if(!controlPort_pl050_kmi1__.update.empty()) controlPort_pl050_kmi1__.update();if(!controlPort_pl050_kmi0__.update.empty()) controlPort_pl050_kmi0__.update();if(!controlPort_Timer_2_3__.update.empty()) controlPort_Timer_2_3__.update();if(!controlPort_Timer_0_1__.update.empty()) controlPort_Timer_0_1__.update();if(!controlPort_sp810_sysctrl__.update.empty()) controlPort_sp810_sysctrl__.update();if(!controlPort_pl111_clcd__.update.empty()) controlPort_pl111_clcd__.update();if(!controlPort_pl031_rtc__.update.empty()) controlPort_pl031_rtc__.update();if(!controlPort_pl011_uart3__.update.empty()) controlPort_pl011_uart3__.update();if(!controlPort_pl011_uart2__.update.empty()) controlPort_pl011_uart2__.update();if(!controlPort_pl011_uart1__.update.empty()) controlPort_pl011_uart1__.update();if(!controlPort_pl011_uart0__.update.empty()) controlPort_pl011_uart0__.update();if(!controlPort_pl180_mci__.update.empty()) controlPort_pl180_mci__.update();if(!controlPort_pl041_aaci__.update.empty()) controlPort_pl041_aaci__.update();if(!controlPort_ve_sysregs__.update.empty()) controlPort_ve_sysregs__.update();if(!controlPort_smsc_91c111__.update.empty()) controlPort_smsc_91c111__.update();if(!controlPort_ps2mouse__.update.empty()) controlPort_ps2mouse__.update();if(!controlPort_ps2keyboard__.update.empty()) controlPort_ps2keyboard__.update();if(!controlPort_mmc__.update.empty()) controlPort_mmc__.update();if(!controlPort_dummy_CF__.update.empty()) controlPort_dummy_CF__.update();if(!controlPort_dummy_usb__.update.empty()) controlPort_dummy_usb__.update();if(!controlPort_dummy_ram__.update.empty()) controlPort_dummy_ram__.update();if(!controlPort_dummy_local_dap_rom__.update.empty()) controlPort_dummy_local_dap_rom__.update();if(!controlPort_psram__.update.empty()) controlPort_psram__.update();if(!controlPort_vram__.update.empty()) controlPort_vram__.update();if(!controlPort_flash1__.update.empty()) controlPort_flash1__.update();if(!controlPort_flash0__.update.empty()) controlPort_flash0__.update();if(!controlPort_flashloader1__.update.empty()) controlPort_flashloader1__.update();if(!controlPort_flashloader0__.update.empty()) controlPort_flashloader0__.update();if(!controlPort_clk__.update.empty()) controlPort_clk__.update();if(!controlPort_clock24MHz__.update.empty()) controlPort_clock24MHz__.update();if(!controlPort_clock100Hz__.update.empty()) controlPort_clock100Hz__.update();if(!controlPort_clockCLCD__.update.empty()) controlPort_clockCLCD__.update();if(!controlPort_clock35MHz__.update.empty()) controlPort_clock35MHz__.update();if(!controlPort_clock50Hz__.update.empty()) controlPort_clock50Hz__.update();if(!controlPort_cs3_decoder__.update.empty()) controlPort_cs3_decoder__.update();if(!controlPort_cs2_decoder__.update.empty()) controlPort_cs2_decoder__.update();if(!controlPort_terminal_0__.update.empty()) controlPort_terminal_0__.update();if(!controlPort_terminal_1__.update.empty()) controlPort_terminal_1__.update();if(!controlPort_terminal_2__.update.empty()) controlPort_terminal_2__.update();if(!controlPort_terminal_3__.update.empty()) controlPort_terminal_3__.update();if(!controlPort_audioout__.update.empty()) controlPort_audioout__.update();if(!controlPort_vis__.update.empty()) controlPort_vis__.update();if(!controlPort_virtualethernetcrossover__.update.empty()) controlPort_virtualethernetcrossover__.update();if(!controlPort_hostbridge__.update.empty()) controlPort_hostbridge__.update();if(!controlPort_vfs2__.update.empty()) controlPort_vfs2__.update();if(!controlPort_virtioblockdevice__.update.empty()) controlPort_virtioblockdevice__.update();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::communicate()
{{if(!controlPort_sp805_wdog__.communicate.empty()) controlPort_sp805_wdog__.communicate();if(!controlPort_pl050_kmi1__.communicate.empty()) controlPort_pl050_kmi1__.communicate();if(!controlPort_pl050_kmi0__.communicate.empty()) controlPort_pl050_kmi0__.communicate();if(!controlPort_Timer_2_3__.communicate.empty()) controlPort_Timer_2_3__.communicate();if(!controlPort_Timer_0_1__.communicate.empty()) controlPort_Timer_0_1__.communicate();if(!controlPort_sp810_sysctrl__.communicate.empty()) controlPort_sp810_sysctrl__.communicate();if(!controlPort_pl111_clcd__.communicate.empty()) controlPort_pl111_clcd__.communicate();if(!controlPort_pl031_rtc__.communicate.empty()) controlPort_pl031_rtc__.communicate();if(!controlPort_pl011_uart3__.communicate.empty()) controlPort_pl011_uart3__.communicate();if(!controlPort_pl011_uart2__.communicate.empty()) controlPort_pl011_uart2__.communicate();if(!controlPort_pl011_uart1__.communicate.empty()) controlPort_pl011_uart1__.communicate();if(!controlPort_pl011_uart0__.communicate.empty()) controlPort_pl011_uart0__.communicate();if(!controlPort_pl180_mci__.communicate.empty()) controlPort_pl180_mci__.communicate();if(!controlPort_pl041_aaci__.communicate.empty()) controlPort_pl041_aaci__.communicate();if(!controlPort_ve_sysregs__.communicate.empty()) controlPort_ve_sysregs__.communicate();if(!controlPort_smsc_91c111__.communicate.empty()) controlPort_smsc_91c111__.communicate();if(!controlPort_ps2mouse__.communicate.empty()) controlPort_ps2mouse__.communicate();if(!controlPort_ps2keyboard__.communicate.empty()) controlPort_ps2keyboard__.communicate();if(!controlPort_mmc__.communicate.empty()) controlPort_mmc__.communicate();if(!controlPort_dummy_CF__.communicate.empty()) controlPort_dummy_CF__.communicate();if(!controlPort_dummy_usb__.communicate.empty()) controlPort_dummy_usb__.communicate();if(!controlPort_dummy_ram__.communicate.empty()) controlPort_dummy_ram__.communicate();if(!controlPort_dummy_local_dap_rom__.communicate.empty()) controlPort_dummy_local_dap_rom__.communicate();if(!controlPort_psram__.communicate.empty()) controlPort_psram__.communicate();if(!controlPort_vram__.communicate.empty()) controlPort_vram__.communicate();if(!controlPort_flash1__.communicate.empty()) controlPort_flash1__.communicate();if(!controlPort_flash0__.communicate.empty()) controlPort_flash0__.communicate();if(!controlPort_flashloader1__.communicate.empty()) controlPort_flashloader1__.communicate();if(!controlPort_flashloader0__.communicate.empty()) controlPort_flashloader0__.communicate();if(!controlPort_clk__.communicate.empty()) controlPort_clk__.communicate();if(!controlPort_clock24MHz__.communicate.empty()) controlPort_clock24MHz__.communicate();if(!controlPort_clock100Hz__.communicate.empty()) controlPort_clock100Hz__.communicate();if(!controlPort_clockCLCD__.communicate.empty()) controlPort_clockCLCD__.communicate();if(!controlPort_clock35MHz__.communicate.empty()) controlPort_clock35MHz__.communicate();if(!controlPort_clock50Hz__.communicate.empty()) controlPort_clock50Hz__.communicate();if(!controlPort_cs3_decoder__.communicate.empty()) controlPort_cs3_decoder__.communicate();if(!controlPort_cs2_decoder__.communicate.empty()) controlPort_cs2_decoder__.communicate();if(!controlPort_terminal_0__.communicate.empty()) controlPort_terminal_0__.communicate();if(!controlPort_terminal_1__.communicate.empty()) controlPort_terminal_1__.communicate();if(!controlPort_terminal_2__.communicate.empty()) controlPort_terminal_2__.communicate();if(!controlPort_terminal_3__.communicate.empty()) controlPort_terminal_3__.communicate();if(!controlPort_audioout__.communicate.empty()) controlPort_audioout__.communicate();if(!controlPort_vis__.communicate.empty()) controlPort_vis__.communicate();if(!controlPort_virtualethernetcrossover__.communicate.empty()) controlPort_virtualethernetcrossover__.communicate();if(!controlPort_hostbridge__.communicate.empty()) controlPort_hostbridge__.communicate();if(!controlPort_vfs2__.communicate.empty()) controlPort_vfs2__.communicate();if(!controlPort_virtioblockdevice__.communicate.empty()) controlPort_virtioblockdevice__.communicate();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::traceEndOfCycle()
{{if(!controlPort_sp805_wdog__.traceEndOfCycle.empty()) controlPort_sp805_wdog__.traceEndOfCycle();if(!controlPort_pl050_kmi1__.traceEndOfCycle.empty()) controlPort_pl050_kmi1__.traceEndOfCycle();if(!controlPort_pl050_kmi0__.traceEndOfCycle.empty()) controlPort_pl050_kmi0__.traceEndOfCycle();if(!controlPort_Timer_2_3__.traceEndOfCycle.empty()) controlPort_Timer_2_3__.traceEndOfCycle();if(!controlPort_Timer_0_1__.traceEndOfCycle.empty()) controlPort_Timer_0_1__.traceEndOfCycle();if(!controlPort_sp810_sysctrl__.traceEndOfCycle.empty()) controlPort_sp810_sysctrl__.traceEndOfCycle();if(!controlPort_pl111_clcd__.traceEndOfCycle.empty()) controlPort_pl111_clcd__.traceEndOfCycle();if(!controlPort_pl031_rtc__.traceEndOfCycle.empty()) controlPort_pl031_rtc__.traceEndOfCycle();if(!controlPort_pl011_uart3__.traceEndOfCycle.empty()) controlPort_pl011_uart3__.traceEndOfCycle();if(!controlPort_pl011_uart2__.traceEndOfCycle.empty()) controlPort_pl011_uart2__.traceEndOfCycle();if(!controlPort_pl011_uart1__.traceEndOfCycle.empty()) controlPort_pl011_uart1__.traceEndOfCycle();if(!controlPort_pl011_uart0__.traceEndOfCycle.empty()) controlPort_pl011_uart0__.traceEndOfCycle();if(!controlPort_pl180_mci__.traceEndOfCycle.empty()) controlPort_pl180_mci__.traceEndOfCycle();if(!controlPort_pl041_aaci__.traceEndOfCycle.empty()) controlPort_pl041_aaci__.traceEndOfCycle();if(!controlPort_ve_sysregs__.traceEndOfCycle.empty()) controlPort_ve_sysregs__.traceEndOfCycle();if(!controlPort_smsc_91c111__.traceEndOfCycle.empty()) controlPort_smsc_91c111__.traceEndOfCycle();if(!controlPort_ps2mouse__.traceEndOfCycle.empty()) controlPort_ps2mouse__.traceEndOfCycle();if(!controlPort_ps2keyboard__.traceEndOfCycle.empty()) controlPort_ps2keyboard__.traceEndOfCycle();if(!controlPort_mmc__.traceEndOfCycle.empty()) controlPort_mmc__.traceEndOfCycle();if(!controlPort_dummy_CF__.traceEndOfCycle.empty()) controlPort_dummy_CF__.traceEndOfCycle();if(!controlPort_dummy_usb__.traceEndOfCycle.empty()) controlPort_dummy_usb__.traceEndOfCycle();if(!controlPort_dummy_ram__.traceEndOfCycle.empty()) controlPort_dummy_ram__.traceEndOfCycle();if(!controlPort_dummy_local_dap_rom__.traceEndOfCycle.empty()) controlPort_dummy_local_dap_rom__.traceEndOfCycle();if(!controlPort_psram__.traceEndOfCycle.empty()) controlPort_psram__.traceEndOfCycle();if(!controlPort_vram__.traceEndOfCycle.empty()) controlPort_vram__.traceEndOfCycle();if(!controlPort_flash1__.traceEndOfCycle.empty()) controlPort_flash1__.traceEndOfCycle();if(!controlPort_flash0__.traceEndOfCycle.empty()) controlPort_flash0__.traceEndOfCycle();if(!controlPort_flashloader1__.traceEndOfCycle.empty()) controlPort_flashloader1__.traceEndOfCycle();if(!controlPort_flashloader0__.traceEndOfCycle.empty()) controlPort_flashloader0__.traceEndOfCycle();if(!controlPort_clk__.traceEndOfCycle.empty()) controlPort_clk__.traceEndOfCycle();if(!controlPort_clock24MHz__.traceEndOfCycle.empty()) controlPort_clock24MHz__.traceEndOfCycle();if(!controlPort_clock100Hz__.traceEndOfCycle.empty()) controlPort_clock100Hz__.traceEndOfCycle();if(!controlPort_clockCLCD__.traceEndOfCycle.empty()) controlPort_clockCLCD__.traceEndOfCycle();if(!controlPort_clock35MHz__.traceEndOfCycle.empty()) controlPort_clock35MHz__.traceEndOfCycle();if(!controlPort_clock50Hz__.traceEndOfCycle.empty()) controlPort_clock50Hz__.traceEndOfCycle();if(!controlPort_cs3_decoder__.traceEndOfCycle.empty()) controlPort_cs3_decoder__.traceEndOfCycle();if(!controlPort_cs2_decoder__.traceEndOfCycle.empty()) controlPort_cs2_decoder__.traceEndOfCycle();if(!controlPort_terminal_0__.traceEndOfCycle.empty()) controlPort_terminal_0__.traceEndOfCycle();if(!controlPort_terminal_1__.traceEndOfCycle.empty()) controlPort_terminal_1__.traceEndOfCycle();if(!controlPort_terminal_2__.traceEndOfCycle.empty()) controlPort_terminal_2__.traceEndOfCycle();if(!controlPort_terminal_3__.traceEndOfCycle.empty()) controlPort_terminal_3__.traceEndOfCycle();if(!controlPort_audioout__.traceEndOfCycle.empty()) controlPort_audioout__.traceEndOfCycle();if(!controlPort_vis__.traceEndOfCycle.empty()) controlPort_vis__.traceEndOfCycle();if(!controlPort_virtualethernetcrossover__.traceEndOfCycle.empty()) controlPort_virtualethernetcrossover__.traceEndOfCycle();if(!controlPort_hostbridge__.traceEndOfCycle.empty()) controlPort_hostbridge__.traceEndOfCycle();if(!controlPort_vfs2__.traceEndOfCycle.empty()) controlPort_vfs2__.traceEndOfCycle();if(!controlPort_virtioblockdevice__.traceEndOfCycle.empty()) controlPort_virtioblockdevice__.traceEndOfCycle();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::loadApplicationFile(const std::string& filename)
{{if(!controlPort_sp805_wdog__.loadApplicationFile.empty()) controlPort_sp805_wdog__.loadApplicationFile(filename);if(!controlPort_pl050_kmi1__.loadApplicationFile.empty()) controlPort_pl050_kmi1__.loadApplicationFile(filename);if(!controlPort_pl050_kmi0__.loadApplicationFile.empty()) controlPort_pl050_kmi0__.loadApplicationFile(filename);if(!controlPort_Timer_2_3__.loadApplicationFile.empty()) controlPort_Timer_2_3__.loadApplicationFile(filename);if(!controlPort_Timer_0_1__.loadApplicationFile.empty()) controlPort_Timer_0_1__.loadApplicationFile(filename);if(!controlPort_sp810_sysctrl__.loadApplicationFile.empty()) controlPort_sp810_sysctrl__.loadApplicationFile(filename);if(!controlPort_pl111_clcd__.loadApplicationFile.empty()) controlPort_pl111_clcd__.loadApplicationFile(filename);if(!controlPort_pl031_rtc__.loadApplicationFile.empty()) controlPort_pl031_rtc__.loadApplicationFile(filename);if(!controlPort_pl011_uart3__.loadApplicationFile.empty()) controlPort_pl011_uart3__.loadApplicationFile(filename);if(!controlPort_pl011_uart2__.loadApplicationFile.empty()) controlPort_pl011_uart2__.loadApplicationFile(filename);if(!controlPort_pl011_uart1__.loadApplicationFile.empty()) controlPort_pl011_uart1__.loadApplicationFile(filename);if(!controlPort_pl011_uart0__.loadApplicationFile.empty()) controlPort_pl011_uart0__.loadApplicationFile(filename);if(!controlPort_pl180_mci__.loadApplicationFile.empty()) controlPort_pl180_mci__.loadApplicationFile(filename);if(!controlPort_pl041_aaci__.loadApplicationFile.empty()) controlPort_pl041_aaci__.loadApplicationFile(filename);if(!controlPort_ve_sysregs__.loadApplicationFile.empty()) controlPort_ve_sysregs__.loadApplicationFile(filename);if(!controlPort_smsc_91c111__.loadApplicationFile.empty()) controlPort_smsc_91c111__.loadApplicationFile(filename);if(!controlPort_ps2mouse__.loadApplicationFile.empty()) controlPort_ps2mouse__.loadApplicationFile(filename);if(!controlPort_ps2keyboard__.loadApplicationFile.empty()) controlPort_ps2keyboard__.loadApplicationFile(filename);if(!controlPort_mmc__.loadApplicationFile.empty()) controlPort_mmc__.loadApplicationFile(filename);if(!controlPort_dummy_CF__.loadApplicationFile.empty()) controlPort_dummy_CF__.loadApplicationFile(filename);if(!controlPort_dummy_usb__.loadApplicationFile.empty()) controlPort_dummy_usb__.loadApplicationFile(filename);if(!controlPort_dummy_ram__.loadApplicationFile.empty()) controlPort_dummy_ram__.loadApplicationFile(filename);if(!controlPort_dummy_local_dap_rom__.loadApplicationFile.empty()) controlPort_dummy_local_dap_rom__.loadApplicationFile(filename);if(!controlPort_psram__.loadApplicationFile.empty()) controlPort_psram__.loadApplicationFile(filename);if(!controlPort_vram__.loadApplicationFile.empty()) controlPort_vram__.loadApplicationFile(filename);if(!controlPort_flash1__.loadApplicationFile.empty()) controlPort_flash1__.loadApplicationFile(filename);if(!controlPort_flash0__.loadApplicationFile.empty()) controlPort_flash0__.loadApplicationFile(filename);if(!controlPort_flashloader1__.loadApplicationFile.empty()) controlPort_flashloader1__.loadApplicationFile(filename);if(!controlPort_flashloader0__.loadApplicationFile.empty()) controlPort_flashloader0__.loadApplicationFile(filename);if(!controlPort_clk__.loadApplicationFile.empty()) controlPort_clk__.loadApplicationFile(filename);if(!controlPort_clock24MHz__.loadApplicationFile.empty()) controlPort_clock24MHz__.loadApplicationFile(filename);if(!controlPort_clock100Hz__.loadApplicationFile.empty()) controlPort_clock100Hz__.loadApplicationFile(filename);if(!controlPort_clockCLCD__.loadApplicationFile.empty()) controlPort_clockCLCD__.loadApplicationFile(filename);if(!controlPort_clock35MHz__.loadApplicationFile.empty()) controlPort_clock35MHz__.loadApplicationFile(filename);if(!controlPort_clock50Hz__.loadApplicationFile.empty()) controlPort_clock50Hz__.loadApplicationFile(filename);if(!controlPort_cs3_decoder__.loadApplicationFile.empty()) controlPort_cs3_decoder__.loadApplicationFile(filename);if(!controlPort_cs2_decoder__.loadApplicationFile.empty()) controlPort_cs2_decoder__.loadApplicationFile(filename);if(!controlPort_terminal_0__.loadApplicationFile.empty()) controlPort_terminal_0__.loadApplicationFile(filename);if(!controlPort_terminal_1__.loadApplicationFile.empty()) controlPort_terminal_1__.loadApplicationFile(filename);if(!controlPort_terminal_2__.loadApplicationFile.empty()) controlPort_terminal_2__.loadApplicationFile(filename);if(!controlPort_terminal_3__.loadApplicationFile.empty()) controlPort_terminal_3__.loadApplicationFile(filename);if(!controlPort_audioout__.loadApplicationFile.empty()) controlPort_audioout__.loadApplicationFile(filename);if(!controlPort_vis__.loadApplicationFile.empty()) controlPort_vis__.loadApplicationFile(filename);if(!controlPort_virtualethernetcrossover__.loadApplicationFile.empty()) controlPort_virtualethernetcrossover__.loadApplicationFile(filename);if(!controlPort_hostbridge__.loadApplicationFile.empty()) controlPort_hostbridge__.loadApplicationFile(filename);if(!controlPort_vfs2__.loadApplicationFile.empty()) controlPort_vfs2__.loadApplicationFile(filename);if(!controlPort_virtioblockdevice__.loadApplicationFile.empty()) controlPort_virtioblockdevice__.loadApplicationFile(filename);};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::init()
{{if(!controlPort_sp805_wdog__.init.empty()) controlPort_sp805_wdog__.init();if(!controlPort_pl050_kmi1__.init.empty()) controlPort_pl050_kmi1__.init();if(!controlPort_pl050_kmi0__.init.empty()) controlPort_pl050_kmi0__.init();if(!controlPort_Timer_2_3__.init.empty()) controlPort_Timer_2_3__.init();if(!controlPort_Timer_0_1__.init.empty()) controlPort_Timer_0_1__.init();if(!controlPort_sp810_sysctrl__.init.empty()) controlPort_sp810_sysctrl__.init();if(!controlPort_pl111_clcd__.init.empty()) controlPort_pl111_clcd__.init();if(!controlPort_pl031_rtc__.init.empty()) controlPort_pl031_rtc__.init();if(!controlPort_pl011_uart3__.init.empty()) controlPort_pl011_uart3__.init();if(!controlPort_pl011_uart2__.init.empty()) controlPort_pl011_uart2__.init();if(!controlPort_pl011_uart1__.init.empty()) controlPort_pl011_uart1__.init();if(!controlPort_pl011_uart0__.init.empty()) controlPort_pl011_uart0__.init();if(!controlPort_pl180_mci__.init.empty()) controlPort_pl180_mci__.init();if(!controlPort_pl041_aaci__.init.empty()) controlPort_pl041_aaci__.init();if(!controlPort_ve_sysregs__.init.empty()) controlPort_ve_sysregs__.init();if(!controlPort_smsc_91c111__.init.empty()) controlPort_smsc_91c111__.init();if(!controlPort_ps2mouse__.init.empty()) controlPort_ps2mouse__.init();if(!controlPort_ps2keyboard__.init.empty()) controlPort_ps2keyboard__.init();if(!controlPort_mmc__.init.empty()) controlPort_mmc__.init();if(!controlPort_dummy_CF__.init.empty()) controlPort_dummy_CF__.init();if(!controlPort_dummy_usb__.init.empty()) controlPort_dummy_usb__.init();if(!controlPort_dummy_ram__.init.empty()) controlPort_dummy_ram__.init();if(!controlPort_dummy_local_dap_rom__.init.empty()) controlPort_dummy_local_dap_rom__.init();if(!controlPort_psram__.init.empty()) controlPort_psram__.init();if(!controlPort_vram__.init.empty()) controlPort_vram__.init();if(!controlPort_flash1__.init.empty()) controlPort_flash1__.init();if(!controlPort_flash0__.init.empty()) controlPort_flash0__.init();if(!controlPort_flashloader1__.init.empty()) controlPort_flashloader1__.init();if(!controlPort_flashloader0__.init.empty()) controlPort_flashloader0__.init();if(!controlPort_clk__.init.empty()) controlPort_clk__.init();if(!controlPort_clock24MHz__.init.empty()) controlPort_clock24MHz__.init();if(!controlPort_clock100Hz__.init.empty()) controlPort_clock100Hz__.init();if(!controlPort_clockCLCD__.init.empty()) controlPort_clockCLCD__.init();if(!controlPort_clock35MHz__.init.empty()) controlPort_clock35MHz__.init();if(!controlPort_clock50Hz__.init.empty()) controlPort_clock50Hz__.init();if(!controlPort_cs3_decoder__.init.empty()) controlPort_cs3_decoder__.init();if(!controlPort_cs2_decoder__.init.empty()) controlPort_cs2_decoder__.init();if(!controlPort_terminal_0__.init.empty()) controlPort_terminal_0__.init();if(!controlPort_terminal_1__.init.empty()) controlPort_terminal_1__.init();if(!controlPort_terminal_2__.init.empty()) controlPort_terminal_2__.init();if(!controlPort_terminal_3__.init.empty()) controlPort_terminal_3__.init();if(!controlPort_audioout__.init.empty()) controlPort_audioout__.init();if(!controlPort_vis__.init.empty()) controlPort_vis__.init();if(!controlPort_virtualethernetcrossover__.init.empty()) controlPort_virtualethernetcrossover__.init();if(!controlPort_hostbridge__.init.empty()) controlPort_hostbridge__.init();if(!controlPort_vfs2__.init.empty()) controlPort_vfs2__.init();if(!controlPort_virtioblockdevice__.init.empty()) controlPort_virtioblockdevice__.init();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::terminate()
{{if(!controlPort_sp805_wdog__.terminate.empty()) controlPort_sp805_wdog__.terminate();if(!controlPort_pl050_kmi1__.terminate.empty()) controlPort_pl050_kmi1__.terminate();if(!controlPort_pl050_kmi0__.terminate.empty()) controlPort_pl050_kmi0__.terminate();if(!controlPort_Timer_2_3__.terminate.empty()) controlPort_Timer_2_3__.terminate();if(!controlPort_Timer_0_1__.terminate.empty()) controlPort_Timer_0_1__.terminate();if(!controlPort_sp810_sysctrl__.terminate.empty()) controlPort_sp810_sysctrl__.terminate();if(!controlPort_pl111_clcd__.terminate.empty()) controlPort_pl111_clcd__.terminate();if(!controlPort_pl031_rtc__.terminate.empty()) controlPort_pl031_rtc__.terminate();if(!controlPort_pl011_uart3__.terminate.empty()) controlPort_pl011_uart3__.terminate();if(!controlPort_pl011_uart2__.terminate.empty()) controlPort_pl011_uart2__.terminate();if(!controlPort_pl011_uart1__.terminate.empty()) controlPort_pl011_uart1__.terminate();if(!controlPort_pl011_uart0__.terminate.empty()) controlPort_pl011_uart0__.terminate();if(!controlPort_pl180_mci__.terminate.empty()) controlPort_pl180_mci__.terminate();if(!controlPort_pl041_aaci__.terminate.empty()) controlPort_pl041_aaci__.terminate();if(!controlPort_ve_sysregs__.terminate.empty()) controlPort_ve_sysregs__.terminate();if(!controlPort_smsc_91c111__.terminate.empty()) controlPort_smsc_91c111__.terminate();if(!controlPort_ps2mouse__.terminate.empty()) controlPort_ps2mouse__.terminate();if(!controlPort_ps2keyboard__.terminate.empty()) controlPort_ps2keyboard__.terminate();if(!controlPort_mmc__.terminate.empty()) controlPort_mmc__.terminate();if(!controlPort_dummy_CF__.terminate.empty()) controlPort_dummy_CF__.terminate();if(!controlPort_dummy_usb__.terminate.empty()) controlPort_dummy_usb__.terminate();if(!controlPort_dummy_ram__.terminate.empty()) controlPort_dummy_ram__.terminate();if(!controlPort_dummy_local_dap_rom__.terminate.empty()) controlPort_dummy_local_dap_rom__.terminate();if(!controlPort_psram__.terminate.empty()) controlPort_psram__.terminate();if(!controlPort_vram__.terminate.empty()) controlPort_vram__.terminate();if(!controlPort_flash1__.terminate.empty()) controlPort_flash1__.terminate();if(!controlPort_flash0__.terminate.empty()) controlPort_flash0__.terminate();if(!controlPort_flashloader1__.terminate.empty()) controlPort_flashloader1__.terminate();if(!controlPort_flashloader0__.terminate.empty()) controlPort_flashloader0__.terminate();if(!controlPort_clk__.terminate.empty()) controlPort_clk__.terminate();if(!controlPort_clock24MHz__.terminate.empty()) controlPort_clock24MHz__.terminate();if(!controlPort_clock100Hz__.terminate.empty()) controlPort_clock100Hz__.terminate();if(!controlPort_clockCLCD__.terminate.empty()) controlPort_clockCLCD__.terminate();if(!controlPort_clock35MHz__.terminate.empty()) controlPort_clock35MHz__.terminate();if(!controlPort_clock50Hz__.terminate.empty()) controlPort_clock50Hz__.terminate();if(!controlPort_cs3_decoder__.terminate.empty()) controlPort_cs3_decoder__.terminate();if(!controlPort_cs2_decoder__.terminate.empty()) controlPort_cs2_decoder__.terminate();if(!controlPort_terminal_0__.terminate.empty()) controlPort_terminal_0__.terminate();if(!controlPort_terminal_1__.terminate.empty()) controlPort_terminal_1__.terminate();if(!controlPort_terminal_2__.terminate.empty()) controlPort_terminal_2__.terminate();if(!controlPort_terminal_3__.terminate.empty()) controlPort_terminal_3__.terminate();if(!controlPort_audioout__.terminate.empty()) controlPort_audioout__.terminate();if(!controlPort_vis__.terminate.empty()) controlPort_vis__.terminate();if(!controlPort_virtualethernetcrossover__.terminate.empty()) controlPort_virtualethernetcrossover__.terminate();if(!controlPort_hostbridge__.terminate.empty()) controlPort_hostbridge__.terminate();if(!controlPort_vfs2__.terminate.empty()) controlPort_vfs2__.terminate();if(!controlPort_virtioblockdevice__.terminate.empty()) controlPort_virtioblockdevice__.terminate();};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::reset(int level)
{{if(!controlPort_sp805_wdog__.reset.empty()) controlPort_sp805_wdog__.reset(level);if(!controlPort_pl050_kmi1__.reset.empty()) controlPort_pl050_kmi1__.reset(level);if(!controlPort_pl050_kmi0__.reset.empty()) controlPort_pl050_kmi0__.reset(level);if(!controlPort_Timer_2_3__.reset.empty()) controlPort_Timer_2_3__.reset(level);if(!controlPort_Timer_0_1__.reset.empty()) controlPort_Timer_0_1__.reset(level);if(!controlPort_sp810_sysctrl__.reset.empty()) controlPort_sp810_sysctrl__.reset(level);if(!controlPort_pl111_clcd__.reset.empty()) controlPort_pl111_clcd__.reset(level);if(!controlPort_pl031_rtc__.reset.empty()) controlPort_pl031_rtc__.reset(level);if(!controlPort_pl011_uart3__.reset.empty()) controlPort_pl011_uart3__.reset(level);if(!controlPort_pl011_uart2__.reset.empty()) controlPort_pl011_uart2__.reset(level);if(!controlPort_pl011_uart1__.reset.empty()) controlPort_pl011_uart1__.reset(level);if(!controlPort_pl011_uart0__.reset.empty()) controlPort_pl011_uart0__.reset(level);if(!controlPort_pl180_mci__.reset.empty()) controlPort_pl180_mci__.reset(level);if(!controlPort_pl041_aaci__.reset.empty()) controlPort_pl041_aaci__.reset(level);if(!controlPort_ve_sysregs__.reset.empty()) controlPort_ve_sysregs__.reset(level);if(!controlPort_smsc_91c111__.reset.empty()) controlPort_smsc_91c111__.reset(level);if(!controlPort_ps2mouse__.reset.empty()) controlPort_ps2mouse__.reset(level);if(!controlPort_ps2keyboard__.reset.empty()) controlPort_ps2keyboard__.reset(level);if(!controlPort_mmc__.reset.empty()) controlPort_mmc__.reset(level);if(!controlPort_dummy_CF__.reset.empty()) controlPort_dummy_CF__.reset(level);if(!controlPort_dummy_usb__.reset.empty()) controlPort_dummy_usb__.reset(level);if(!controlPort_dummy_ram__.reset.empty()) controlPort_dummy_ram__.reset(level);if(!controlPort_dummy_local_dap_rom__.reset.empty()) controlPort_dummy_local_dap_rom__.reset(level);if(!controlPort_psram__.reset.empty()) controlPort_psram__.reset(level);if(!controlPort_vram__.reset.empty()) controlPort_vram__.reset(level);if(!controlPort_flash1__.reset.empty()) controlPort_flash1__.reset(level);if(!controlPort_flash0__.reset.empty()) controlPort_flash0__.reset(level);if(!controlPort_flashloader1__.reset.empty()) controlPort_flashloader1__.reset(level);if(!controlPort_flashloader0__.reset.empty()) controlPort_flashloader0__.reset(level);if(!controlPort_clk__.reset.empty()) controlPort_clk__.reset(level);if(!controlPort_clock24MHz__.reset.empty()) controlPort_clock24MHz__.reset(level);if(!controlPort_clock100Hz__.reset.empty()) controlPort_clock100Hz__.reset(level);if(!controlPort_clockCLCD__.reset.empty()) controlPort_clockCLCD__.reset(level);if(!controlPort_clock35MHz__.reset.empty()) controlPort_clock35MHz__.reset(level);if(!controlPort_clock50Hz__.reset.empty()) controlPort_clock50Hz__.reset(level);if(!controlPort_cs3_decoder__.reset.empty()) controlPort_cs3_decoder__.reset(level);if(!controlPort_cs2_decoder__.reset.empty()) controlPort_cs2_decoder__.reset(level);if(!controlPort_terminal_0__.reset.empty()) controlPort_terminal_0__.reset(level);if(!controlPort_terminal_1__.reset.empty()) controlPort_terminal_1__.reset(level);if(!controlPort_terminal_2__.reset.empty()) controlPort_terminal_2__.reset(level);if(!controlPort_terminal_3__.reset.empty()) controlPort_terminal_3__.reset(level);if(!controlPort_audioout__.reset.empty()) controlPort_audioout__.reset(level);if(!controlPort_vis__.reset.empty()) controlPort_vis__.reset(level);if(!controlPort_virtualethernetcrossover__.reset.empty()) controlPort_virtualethernetcrossover__.reset(level);if(!controlPort_hostbridge__.reset.empty()) controlPort_hostbridge__.reset(level);if(!controlPort_vfs2__.reset.empty()) controlPort_vfs2__.reset(level);if(!controlPort_virtioblockdevice__.reset.empty()) controlPort_virtioblockdevice__.reset(level);};
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEMotherBoard::save(MxODataStream& os)
{{if(!controlPort_sp805_wdog__.save.empty()) controlPort_sp805_wdog__.save(os);if(!controlPort_pl050_kmi1__.save.empty()) controlPort_pl050_kmi1__.save(os);if(!controlPort_pl050_kmi0__.save.empty()) controlPort_pl050_kmi0__.save(os);if(!controlPort_Timer_2_3__.save.empty()) controlPort_Timer_2_3__.save(os);if(!controlPort_Timer_0_1__.save.empty()) controlPort_Timer_0_1__.save(os);if(!controlPort_sp810_sysctrl__.save.empty()) controlPort_sp810_sysctrl__.save(os);if(!controlPort_pl111_clcd__.save.empty()) controlPort_pl111_clcd__.save(os);if(!controlPort_pl031_rtc__.save.empty()) controlPort_pl031_rtc__.save(os);if(!controlPort_pl011_uart3__.save.empty()) controlPort_pl011_uart3__.save(os);if(!controlPort_pl011_uart2__.save.empty()) controlPort_pl011_uart2__.save(os);if(!controlPort_pl011_uart1__.save.empty()) controlPort_pl011_uart1__.save(os);if(!controlPort_pl011_uart0__.save.empty()) controlPort_pl011_uart0__.save(os);if(!controlPort_pl180_mci__.save.empty()) controlPort_pl180_mci__.save(os);if(!controlPort_pl041_aaci__.save.empty()) controlPort_pl041_aaci__.save(os);if(!controlPort_ve_sysregs__.save.empty()) controlPort_ve_sysregs__.save(os);if(!controlPort_smsc_91c111__.save.empty()) controlPort_smsc_91c111__.save(os);if(!controlPort_ps2mouse__.save.empty()) controlPort_ps2mouse__.save(os);if(!controlPort_ps2keyboard__.save.empty()) controlPort_ps2keyboard__.save(os);if(!controlPort_mmc__.save.empty()) controlPort_mmc__.save(os);if(!controlPort_dummy_CF__.save.empty()) controlPort_dummy_CF__.save(os);if(!controlPort_dummy_usb__.save.empty()) controlPort_dummy_usb__.save(os);if(!controlPort_dummy_ram__.save.empty()) controlPort_dummy_ram__.save(os);if(!controlPort_dummy_local_dap_rom__.save.empty()) controlPort_dummy_local_dap_rom__.save(os);if(!controlPort_psram__.save.empty()) controlPort_psram__.save(os);if(!controlPort_vram__.save.empty()) controlPort_vram__.save(os);if(!controlPort_flash1__.save.empty()) controlPort_flash1__.save(os);if(!controlPort_flash0__.save.empty()) controlPort_flash0__.save(os);if(!controlPort_flashloader1__.save.empty()) controlPort_flashloader1__.save(os);if(!controlPort_flashloader0__.save.empty()) controlPort_flashloader0__.save(os);if(!controlPort_clk__.save.empty()) controlPort_clk__.save(os);if(!controlPort_clock24MHz__.save.empty()) controlPort_clock24MHz__.save(os);if(!controlPort_clock100Hz__.save.empty()) controlPort_clock100Hz__.save(os);if(!controlPort_clockCLCD__.save.empty()) controlPort_clockCLCD__.save(os);if(!controlPort_clock35MHz__.save.empty()) controlPort_clock35MHz__.save(os);if(!controlPort_clock50Hz__.save.empty()) controlPort_clock50Hz__.save(os);if(!controlPort_cs3_decoder__.save.empty()) controlPort_cs3_decoder__.save(os);if(!controlPort_cs2_decoder__.save.empty()) controlPort_cs2_decoder__.save(os);if(!controlPort_terminal_0__.save.empty()) controlPort_terminal_0__.save(os);if(!controlPort_terminal_1__.save.empty()) controlPort_terminal_1__.save(os);if(!controlPort_terminal_2__.save.empty()) controlPort_terminal_2__.save(os);if(!controlPort_terminal_3__.save.empty()) controlPort_terminal_3__.save(os);if(!controlPort_audioout__.save.empty()) controlPort_audioout__.save(os);if(!controlPort_vis__.save.empty()) controlPort_vis__.save(os);if(!controlPort_virtualethernetcrossover__.save.empty()) controlPort_virtualethernetcrossover__.save(os);if(!controlPort_hostbridge__.save.empty()) controlPort_hostbridge__.save(os);if(!controlPort_vfs2__.save.empty()) controlPort_vfs2__.save(os);if(!controlPort_virtioblockdevice__.save.empty()) controlPort_virtioblockdevice__.save(os);};return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VEMotherBoard::restore(MxIDataStream& is)
{{if(!controlPort_sp805_wdog__.restore.empty()) controlPort_sp805_wdog__.restore(is);if(!controlPort_pl050_kmi1__.restore.empty()) controlPort_pl050_kmi1__.restore(is);if(!controlPort_pl050_kmi0__.restore.empty()) controlPort_pl050_kmi0__.restore(is);if(!controlPort_Timer_2_3__.restore.empty()) controlPort_Timer_2_3__.restore(is);if(!controlPort_Timer_0_1__.restore.empty()) controlPort_Timer_0_1__.restore(is);if(!controlPort_sp810_sysctrl__.restore.empty()) controlPort_sp810_sysctrl__.restore(is);if(!controlPort_pl111_clcd__.restore.empty()) controlPort_pl111_clcd__.restore(is);if(!controlPort_pl031_rtc__.restore.empty()) controlPort_pl031_rtc__.restore(is);if(!controlPort_pl011_uart3__.restore.empty()) controlPort_pl011_uart3__.restore(is);if(!controlPort_pl011_uart2__.restore.empty()) controlPort_pl011_uart2__.restore(is);if(!controlPort_pl011_uart1__.restore.empty()) controlPort_pl011_uart1__.restore(is);if(!controlPort_pl011_uart0__.restore.empty()) controlPort_pl011_uart0__.restore(is);if(!controlPort_pl180_mci__.restore.empty()) controlPort_pl180_mci__.restore(is);if(!controlPort_pl041_aaci__.restore.empty()) controlPort_pl041_aaci__.restore(is);if(!controlPort_ve_sysregs__.restore.empty()) controlPort_ve_sysregs__.restore(is);if(!controlPort_smsc_91c111__.restore.empty()) controlPort_smsc_91c111__.restore(is);if(!controlPort_ps2mouse__.restore.empty()) controlPort_ps2mouse__.restore(is);if(!controlPort_ps2keyboard__.restore.empty()) controlPort_ps2keyboard__.restore(is);if(!controlPort_mmc__.restore.empty()) controlPort_mmc__.restore(is);if(!controlPort_dummy_CF__.restore.empty()) controlPort_dummy_CF__.restore(is);if(!controlPort_dummy_usb__.restore.empty()) controlPort_dummy_usb__.restore(is);if(!controlPort_dummy_ram__.restore.empty()) controlPort_dummy_ram__.restore(is);if(!controlPort_dummy_local_dap_rom__.restore.empty()) controlPort_dummy_local_dap_rom__.restore(is);if(!controlPort_psram__.restore.empty()) controlPort_psram__.restore(is);if(!controlPort_vram__.restore.empty()) controlPort_vram__.restore(is);if(!controlPort_flash1__.restore.empty()) controlPort_flash1__.restore(is);if(!controlPort_flash0__.restore.empty()) controlPort_flash0__.restore(is);if(!controlPort_flashloader1__.restore.empty()) controlPort_flashloader1__.restore(is);if(!controlPort_flashloader0__.restore.empty()) controlPort_flashloader0__.restore(is);if(!controlPort_clk__.restore.empty()) controlPort_clk__.restore(is);if(!controlPort_clock24MHz__.restore.empty()) controlPort_clock24MHz__.restore(is);if(!controlPort_clock100Hz__.restore.empty()) controlPort_clock100Hz__.restore(is);if(!controlPort_clockCLCD__.restore.empty()) controlPort_clockCLCD__.restore(is);if(!controlPort_clock35MHz__.restore.empty()) controlPort_clock35MHz__.restore(is);if(!controlPort_clock50Hz__.restore.empty()) controlPort_clock50Hz__.restore(is);if(!controlPort_cs3_decoder__.restore.empty()) controlPort_cs3_decoder__.restore(is);if(!controlPort_cs2_decoder__.restore.empty()) controlPort_cs2_decoder__.restore(is);if(!controlPort_terminal_0__.restore.empty()) controlPort_terminal_0__.restore(is);if(!controlPort_terminal_1__.restore.empty()) controlPort_terminal_1__.restore(is);if(!controlPort_terminal_2__.restore.empty()) controlPort_terminal_2__.restore(is);if(!controlPort_terminal_3__.restore.empty()) controlPort_terminal_3__.restore(is);if(!controlPort_audioout__.restore.empty()) controlPort_audioout__.restore(is);if(!controlPort_vis__.restore.empty()) controlPort_vis__.restore(is);if(!controlPort_virtualethernetcrossover__.restore.empty()) controlPort_virtualethernetcrossover__.restore(is);if(!controlPort_hostbridge__.restore.empty()) controlPort_hostbridge__.restore(is);if(!controlPort_vfs2__.restore.empty()) controlPort_vfs2__.restore(is);if(!controlPort_virtioblockdevice__.restore.empty()) controlPort_virtioblockdevice__.restore(is);};return true;
}
}

#line 3 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VEMotherBoard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VEMotherBoard::step()
{{if(!controlPort_sp805_wdog__.step.empty()) controlPort_sp805_wdog__.step();if(!controlPort_pl050_kmi1__.step.empty()) controlPort_pl050_kmi1__.step();if(!controlPort_pl050_kmi0__.step.empty()) controlPort_pl050_kmi0__.step();if(!controlPort_Timer_2_3__.step.empty()) controlPort_Timer_2_3__.step();if(!controlPort_Timer_0_1__.step.empty()) controlPort_Timer_0_1__.step();if(!controlPort_sp810_sysctrl__.step.empty()) controlPort_sp810_sysctrl__.step();if(!controlPort_pl111_clcd__.step.empty()) controlPort_pl111_clcd__.step();if(!controlPort_pl031_rtc__.step.empty()) controlPort_pl031_rtc__.step();if(!controlPort_pl011_uart3__.step.empty()) controlPort_pl011_uart3__.step();if(!controlPort_pl011_uart2__.step.empty()) controlPort_pl011_uart2__.step();if(!controlPort_pl011_uart1__.step.empty()) controlPort_pl011_uart1__.step();if(!controlPort_pl011_uart0__.step.empty()) controlPort_pl011_uart0__.step();if(!controlPort_pl180_mci__.step.empty()) controlPort_pl180_mci__.step();if(!controlPort_pl041_aaci__.step.empty()) controlPort_pl041_aaci__.step();if(!controlPort_ve_sysregs__.step.empty()) controlPort_ve_sysregs__.step();if(!controlPort_smsc_91c111__.step.empty()) controlPort_smsc_91c111__.step();if(!controlPort_ps2mouse__.step.empty()) controlPort_ps2mouse__.step();if(!controlPort_ps2keyboard__.step.empty()) controlPort_ps2keyboard__.step();if(!controlPort_mmc__.step.empty()) controlPort_mmc__.step();if(!controlPort_dummy_CF__.step.empty()) controlPort_dummy_CF__.step();if(!controlPort_dummy_usb__.step.empty()) controlPort_dummy_usb__.step();if(!controlPort_dummy_ram__.step.empty()) controlPort_dummy_ram__.step();if(!controlPort_dummy_local_dap_rom__.step.empty()) controlPort_dummy_local_dap_rom__.step();if(!controlPort_psram__.step.empty()) controlPort_psram__.step();if(!controlPort_vram__.step.empty()) controlPort_vram__.step();if(!controlPort_flash1__.step.empty()) controlPort_flash1__.step();if(!controlPort_flash0__.step.empty()) controlPort_flash0__.step();if(!controlPort_flashloader1__.step.empty()) controlPort_flashloader1__.step();if(!controlPort_flashloader0__.step.empty()) controlPort_flashloader0__.step();if(!controlPort_clk__.step.empty()) controlPort_clk__.step();if(!controlPort_clock24MHz__.step.empty()) controlPort_clock24MHz__.step();if(!controlPort_clock100Hz__.step.empty()) controlPort_clock100Hz__.step();if(!controlPort_clockCLCD__.step.empty()) controlPort_clockCLCD__.step();if(!controlPort_clock35MHz__.step.empty()) controlPort_clock35MHz__.step();if(!controlPort_clock50Hz__.step.empty()) controlPort_clock50Hz__.step();if(!controlPort_cs3_decoder__.step.empty()) controlPort_cs3_decoder__.step();if(!controlPort_cs2_decoder__.step.empty()) controlPort_cs2_decoder__.step();if(!controlPort_terminal_0__.step.empty()) controlPort_terminal_0__.step();if(!controlPort_terminal_1__.step.empty()) controlPort_terminal_1__.step();if(!controlPort_terminal_2__.step.empty()) controlPort_terminal_2__.step();if(!controlPort_terminal_3__.step.empty()) controlPort_terminal_3__.step();if(!controlPort_audioout__.step.empty()) controlPort_audioout__.step();if(!controlPort_vis__.step.empty()) controlPort_vis__.step();if(!controlPort_virtualethernetcrossover__.step.empty()) controlPort_virtualethernetcrossover__.step();if(!controlPort_hostbridge__.step.empty()) controlPort_hostbridge__.step();if(!controlPort_vfs2__.step.empty()) controlPort_vfs2__.step();if(!controlPort_virtioblockdevice__.step.empty()) controlPort_virtioblockdevice__.step();};
}
}

#line 8708 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__VEMotherBoard
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__VEMotherBoard::Component__VEMotherBoard(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,proc_id0(GetParameterValue(params, "proc_id0", MxS64CONST(0xc000000), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,proc_id1(GetParameterValue(params, "proc_id1", MxS64CONST(0xff000000), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,number_of_daughter_leds(GetParameterValue(params, "daughter_led_count", MxS64CONST(0x0), MxS64CONST(0x0), MxS64CONST(0x20)))
	,number_of_daughter_switches(GetParameterValue(params, "daughter_user_switch_count", MxS64CONST(0x0), MxS64CONST(0x0), MxS64CONST(0x20)))


	,cadiParameterProxy_ve_sysregs_of_VE_SysRegs_to_VEMotherBoard__(0)
	,cadiParameterProxy_dummy_usb_of_RAMDevice_to_VEMotherBoard__(0)
	,cadiParameterProxy_dummy_ram_of_RAMDevice_to_VEMotherBoard__(0)
	,cadiParameterProxy_dummy_local_dap_rom_of_RAMDevice_to_VEMotherBoard__(0)
	,cadiParameterProxy_psram_of_RAMDevice_to_VEMotherBoard__(0)
	,cadiParameterProxy_vram_of_RAMDevice_to_VEMotherBoard__(0)
	,cadiParameterProxy_flash1_of_IntelStrataFlashJ3_to_VEMotherBoard__(0)
	,cadiParameterProxy_flash0_of_IntelStrataFlashJ3_to_VEMotherBoard__(0)
	,cadiParameterProxy_clock24MHz_of_ClockDivider_to_VEMotherBoard__(0)
	,cadiParameterProxy_clock100Hz_of_ClockDivider_to_VEMotherBoard__(0)
	,cadiParameterProxy_clockCLCD_of_ClockDivider_to_VEMotherBoard__(0)
	,cadiParameterProxy_clock35MHz_of_ClockDivider_to_VEMotherBoard__(0)
	,cadiParameterProxy_clock50Hz_of_ClockDivider_to_VEMotherBoard__(0)
	,cadiParameterProxy_vis_of_VEVisualisation_to_VEMotherBoard__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "System";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Model inspired by the ARM Versatile Express Motherboard";
	properties__["documentation_file"] = "";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = VEMotherBoard_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *VE_SysRegs_factory = VE_SysRegs_GetFactory();
		sg::ComponentFactory *VEVisualisation_factory = VEVisualisation_GetFactory();
		sg::ComponentFactory *VE_CompactFlash_factory = VE_CompactFlash_GetFactory();
		sg::ComponentFactory *ClockDivider_factory = ClockDivider_GetFactory();
		sg::ComponentFactory *MasterClock_factory = MasterClock_GetFactory();
		sg::ComponentFactory *PVBusDecoder_factory = PVBusDecoder_GetFactory();
		sg::ComponentFactory *AudioOut_SDL_factory = AudioOut_SDL_GetFactory();
		sg::ComponentFactory *FlashLoader_factory = FlashLoader_GetFactory();
		sg::ComponentFactory *PL011_Uart_factory = PL011_Uart_GetFactory();
		sg::ComponentFactory *PL050_KMI_factory = PL050_KMI_GetFactory();
		sg::ComponentFactory *PL111_CLCD_factory = PL111_CLCD_GetFactory();
		sg::ComponentFactory *PS2Keyboard_factory = PS2Keyboard_GetFactory();
		sg::ComponentFactory *PS2Mouse_factory = PS2Mouse_GetFactory();
		sg::ComponentFactory *RAMDevice_factory = RAMDevice_GetFactory();
		sg::ComponentFactory *SMSC_91C111_factory = SMSC_91C111_GetFactory();
		sg::ComponentFactory *TelnetTerminal_factory = TelnetTerminal_GetFactory();
		sg::ComponentFactory *PL031_RTC_factory = PL031_RTC_GetFactory();
		sg::ComponentFactory *PL041_AACI_factory = PL041_AACI_GetFactory();
		sg::ComponentFactory *SP804_Timer_factory = SP804_Timer_GetFactory();
		sg::ComponentFactory *SP810_SysCtrl_factory = SP810_SysCtrl_GetFactory();
		sg::ComponentFactory *MMC_factory = MMC_GetFactory();
		sg::ComponentFactory *PL180_MCI_factory = PL180_MCI_GetFactory();
		sg::ComponentFactory *SP805_Watchdog_factory = SP805_Watchdog_GetFactory();
		sg::ComponentFactory *VirtualEthernetCrossover_factory = VirtualEthernetCrossover_GetFactory();
		sg::ComponentFactory *HostBridge_factory = HostBridge_GetFactory();
		sg::ComponentFactory *VirtioBlockDevice_factory = VirtioBlockDevice_GetFactory();
		sg::ComponentFactory *VFS2_factory = VFS2_GetFactory();
		sg::ComponentFactory *IntelStrataFlashJ3_factory = IntelStrataFlashJ3_GetFactory();
		{
			sg::Params params_sp805_wdog__ = params.getParamsFor("sp805_wdog");
			sp805_wdog = dynamic_cast<Component__SP805_Watchdog*>(SP805_Watchdog_factory->instantiate("sp805_wdog", simulationContext, params_sp805_wdog__));
			assert(sp805_wdog);
			add(sp805_wdog);
		}
		{
			sg::Params params_pl050_kmi1__ = params.getParamsFor("pl050_kmi1");
			pl050_kmi1 = dynamic_cast<Component__PL050_KMI*>(PL050_KMI_factory->instantiate("pl050_kmi1", simulationContext, params_pl050_kmi1__));
			assert(pl050_kmi1);
			add(pl050_kmi1);
		}
		{
			sg::Params params_pl050_kmi0__ = params.getParamsFor("pl050_kmi0");
			pl050_kmi0 = dynamic_cast<Component__PL050_KMI*>(PL050_KMI_factory->instantiate("pl050_kmi0", simulationContext, params_pl050_kmi0__));
			assert(pl050_kmi0);
			add(pl050_kmi0);
		}
		{
			sg::Params params_Timer_2_3__ = params.getParamsFor("Timer_2_3");
			Timer_2_3 = dynamic_cast<Component__SP804_Timer*>(SP804_Timer_factory->instantiate("Timer_2_3", simulationContext, params_Timer_2_3__));
			assert(Timer_2_3);
			add(Timer_2_3);
		}
		{
			sg::Params params_Timer_0_1__ = params.getParamsFor("Timer_0_1");
			Timer_0_1 = dynamic_cast<Component__SP804_Timer*>(SP804_Timer_factory->instantiate("Timer_0_1", simulationContext, params_Timer_0_1__));
			assert(Timer_0_1);
			add(Timer_0_1);
		}
		{
			sg::Params params_sp810_sysctrl__ = params.getParamsFor("sp810_sysctrl");
			sp810_sysctrl = dynamic_cast<Component__SP810_SysCtrl*>(SP810_SysCtrl_factory->instantiate("sp810_sysctrl", simulationContext, params_sp810_sysctrl__));
			assert(sp810_sysctrl);
			add(sp810_sysctrl);
		}
		{
			sg::Params params_pl111_clcd__ = params.getParamsFor("pl111_clcd");
			pl111_clcd = dynamic_cast<Component__PL111_CLCD*>(PL111_CLCD_factory->instantiate("pl111_clcd", simulationContext, params_pl111_clcd__));
			assert(pl111_clcd);
			add(pl111_clcd);
		}
		{
			sg::Params params_pl031_rtc__ = params.getParamsFor("pl031_rtc");
			pl031_rtc = dynamic_cast<Component__PL031_RTC*>(PL031_RTC_factory->instantiate("pl031_rtc", simulationContext, params_pl031_rtc__));
			assert(pl031_rtc);
			add(pl031_rtc);
		}
		{
			sg::Params params_pl011_uart3__ = params.getParamsFor("pl011_uart3");
			pl011_uart3 = dynamic_cast<Component__PL011_Uart*>(PL011_Uart_factory->instantiate("pl011_uart3", simulationContext, params_pl011_uart3__));
			assert(pl011_uart3);
			add(pl011_uart3);
		}
		{
			sg::Params params_pl011_uart2__ = params.getParamsFor("pl011_uart2");
			pl011_uart2 = dynamic_cast<Component__PL011_Uart*>(PL011_Uart_factory->instantiate("pl011_uart2", simulationContext, params_pl011_uart2__));
			assert(pl011_uart2);
			add(pl011_uart2);
		}
		{
			sg::Params params_pl011_uart1__ = params.getParamsFor("pl011_uart1");
			pl011_uart1 = dynamic_cast<Component__PL011_Uart*>(PL011_Uart_factory->instantiate("pl011_uart1", simulationContext, params_pl011_uart1__));
			assert(pl011_uart1);
			add(pl011_uart1);
		}
		{
			sg::Params params_pl011_uart0__ = params.getParamsFor("pl011_uart0");
			pl011_uart0 = dynamic_cast<Component__PL011_Uart*>(PL011_Uart_factory->instantiate("pl011_uart0", simulationContext, params_pl011_uart0__));
			assert(pl011_uart0);
			add(pl011_uart0);
		}
		{
			sg::Params params_pl180_mci__ = params.getParamsFor("pl180_mci");
			pl180_mci = dynamic_cast<Component__PL180_MCI*>(PL180_MCI_factory->instantiate("pl180_mci", simulationContext, params_pl180_mci__));
			assert(pl180_mci);
			add(pl180_mci);
		}
		{
			sg::Params params_pl041_aaci__ = params.getParamsFor("pl041_aaci");
			pl041_aaci = dynamic_cast<Component__PL041_AACI*>(PL041_AACI_factory->instantiate("pl041_aaci", simulationContext, params_pl041_aaci__));
			assert(pl041_aaci);
			add(pl041_aaci);
		}
		{
			sg::Params params_ve_sysregs__ = params.getParamsFor("ve_sysregs");
			params_ve_sysregs__["sys_proc_id0"] = proc_id0;
			params_ve_sysregs__["sys_proc_id1"] = proc_id1;
			ve_sysregs = dynamic_cast<Component__VE_SysRegs*>(VE_SysRegs_factory->instantiate("ve_sysregs", simulationContext, params_ve_sysregs__));
			assert(ve_sysregs);
			add(ve_sysregs);
		}
		{
			sg::Params params_smsc_91c111__ = params.getParamsFor("smsc_91c111");
			add(smsc_91c111 = SMSC_91C111_factory->instantiate("smsc_91c111", simulationContext, params_smsc_91c111__));
		}
		{
			sg::Params params_ps2mouse__ = params.getParamsFor("ps2mouse");
			ps2mouse = dynamic_cast<Component__PS2Mouse*>(PS2Mouse_factory->instantiate("ps2mouse", simulationContext, params_ps2mouse__));
			assert(ps2mouse);
			add(ps2mouse);
		}
		{
			sg::Params params_ps2keyboard__ = params.getParamsFor("ps2keyboard");
			ps2keyboard = dynamic_cast<Component__PS2Keyboard*>(PS2Keyboard_factory->instantiate("ps2keyboard", simulationContext, params_ps2keyboard__));
			assert(ps2keyboard);
			add(ps2keyboard);
		}
		{
			sg::Params params_mmc__ = params.getParamsFor("mmc");
			mmc = dynamic_cast<Component__MMC*>(MMC_factory->instantiate("mmc", simulationContext, params_mmc__));
			assert(mmc);
			add(mmc);
		}
		{
			sg::Params params_dummy_CF__ = params.getParamsFor("dummy_CF");
			dummy_CF = dynamic_cast<Component__VE_CompactFlash*>(VE_CompactFlash_factory->instantiate("dummy_CF", simulationContext, params_dummy_CF__));
			assert(dummy_CF);
			add(dummy_CF);
		}
		{
			sg::Params params_dummy_usb__ = params.getParamsFor("dummy_usb");
			params_dummy_usb__["size"] = MxU64CONST(0x0000000000001000);
			dummy_usb = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("dummy_usb", simulationContext, params_dummy_usb__));
			assert(dummy_usb);
			add(dummy_usb);
		}
		{
			sg::Params params_dummy_ram__ = params.getParamsFor("dummy_ram");
			params_dummy_ram__["size"] = MxU64CONST(0x0000000000001000);
			dummy_ram = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("dummy_ram", simulationContext, params_dummy_ram__));
			assert(dummy_ram);
			add(dummy_ram);
		}
		{
			sg::Params params_dummy_local_dap_rom__ = params.getParamsFor("dummy_local_dap_rom");
			params_dummy_local_dap_rom__["size"] = MxU64CONST(0x0000000000010000);
			dummy_local_dap_rom = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("dummy_local_dap_rom", simulationContext, params_dummy_local_dap_rom__));
			assert(dummy_local_dap_rom);
			add(dummy_local_dap_rom);
		}
		{
			sg::Params params_psram__ = params.getParamsFor("psram");
			params_psram__["size"] = MxU64CONST(0x0000000000800000);
			psram = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("psram", simulationContext, params_psram__));
			assert(psram);
			add(psram);
		}
		{
			sg::Params params_vram__ = params.getParamsFor("vram");
			params_vram__["size"] = MxU64CONST(0x0000000000800000);
			vram = dynamic_cast<Component__RAMDevice*>(RAMDevice_factory->instantiate("vram", simulationContext, params_vram__));
			assert(vram);
			add(vram);
		}
		{
			sg::Params params_flash1__ = params.getParamsFor("flash1");
			params_flash1__["size"] = MxU64CONST(0x0000000004000000);
			flash1 = dynamic_cast<Component__IntelStrataFlashJ3*>(IntelStrataFlashJ3_factory->instantiate("flash1", simulationContext, params_flash1__));
			assert(flash1);
			add(flash1);
		}
		{
			sg::Params params_flash0__ = params.getParamsFor("flash0");
			params_flash0__["size"] = MxU64CONST(0x0000000004000000);
			flash0 = dynamic_cast<Component__IntelStrataFlashJ3*>(IntelStrataFlashJ3_factory->instantiate("flash0", simulationContext, params_flash0__));
			assert(flash0);
			add(flash0);
		}
		{
			sg::Params params_flashloader1__ = params.getParamsFor("flashloader1");
			flashloader1 = dynamic_cast<Component__FlashLoader*>(FlashLoader_factory->instantiate("flashloader1", simulationContext, params_flashloader1__));
			assert(flashloader1);
			add(flashloader1);
		}
		{
			sg::Params params_flashloader0__ = params.getParamsFor("flashloader0");
			flashloader0 = dynamic_cast<Component__FlashLoader*>(FlashLoader_factory->instantiate("flashloader0", simulationContext, params_flashloader0__));
			assert(flashloader0);
			add(flashloader0);
		}
		{
			sg::Params params_clk__ = params.getParamsFor("clk");
			add(clk = MasterClock_factory->instantiate("clk", simulationContext, params_clk__));
		}
		{
			sg::Params params_clock24MHz__ = params.getParamsFor("clock24MHz");
			params_clock24MHz__["mul"] = MxU64CONST(0x00000000016E3600);
			add(clock24MHz = ClockDivider_factory->instantiate("clock24MHz", simulationContext, params_clock24MHz__));
		}
		{
			sg::Params params_clock100Hz__ = params.getParamsFor("clock100Hz");
			params_clock100Hz__["mul"] = MxU64CONST(0x0000000000000064);
			add(clock100Hz = ClockDivider_factory->instantiate("clock100Hz", simulationContext, params_clock100Hz__));
		}
		{
			sg::Params params_clockCLCD__ = params.getParamsFor("clockCLCD");
			params_clockCLCD__["mul"] = MxU64CONST(0x00000000016A6570);
			add(clockCLCD = ClockDivider_factory->instantiate("clockCLCD", simulationContext, params_clockCLCD__));
		}
		{
			sg::Params params_clock35MHz__ = params.getParamsFor("clock35MHz");
			params_clock35MHz__["mul"] = MxU64CONST(0x0000000002160EC0);
			add(clock35MHz = ClockDivider_factory->instantiate("clock35MHz", simulationContext, params_clock35MHz__));
		}
		{
			sg::Params params_clock50Hz__ = params.getParamsFor("clock50Hz");
			params_clock50Hz__["mul"] = MxU64CONST(0x0000000000000032);
			add(clock50Hz = ClockDivider_factory->instantiate("clock50Hz", simulationContext, params_clock50Hz__));
		}
		{
			sg::Params params_cs3_decoder__ = params.getParamsFor("cs3_decoder");
			add(cs3_decoder = PVBusDecoder_factory->instantiate("cs3_decoder", simulationContext, params_cs3_decoder__));
		}
		{
			sg::Params params_cs2_decoder__ = params.getParamsFor("cs2_decoder");
			add(cs2_decoder = PVBusDecoder_factory->instantiate("cs2_decoder", simulationContext, params_cs2_decoder__));
		}
		{
			sg::Params params_terminal_0__ = params.getParamsFor("terminal_0");
			add(terminal_0 = TelnetTerminal_factory->instantiate("terminal_0", simulationContext, params_terminal_0__));
		}
		{
			sg::Params params_terminal_1__ = params.getParamsFor("terminal_1");
			add(terminal_1 = TelnetTerminal_factory->instantiate("terminal_1", simulationContext, params_terminal_1__));
		}
		{
			sg::Params params_terminal_2__ = params.getParamsFor("terminal_2");
			add(terminal_2 = TelnetTerminal_factory->instantiate("terminal_2", simulationContext, params_terminal_2__));
		}
		{
			sg::Params params_terminal_3__ = params.getParamsFor("terminal_3");
			add(terminal_3 = TelnetTerminal_factory->instantiate("terminal_3", simulationContext, params_terminal_3__));
		}
		{
			sg::Params params_audioout__ = params.getParamsFor("audioout");
			audioout = dynamic_cast<Component__AudioOut_SDL*>(AudioOut_SDL_factory->instantiate("audioout", simulationContext, params_audioout__));
			assert(audioout);
			add(audioout);
		}
		{
			sg::Params params_vis__ = params.getParamsFor("vis");
			params_vis__["daughter_led_count"] = number_of_daughter_leds;
			params_vis__["daughter_user_switch_count"] = number_of_daughter_switches;
			vis = dynamic_cast<Component__VEVisualisation*>(VEVisualisation_factory->instantiate("vis", simulationContext, params_vis__));
			assert(vis);
			add(vis);
		}
		{
			sg::Params params_virtualethernetcrossover__ = params.getParamsFor("virtualethernetcrossover");
			virtualethernetcrossover = dynamic_cast<Component__VirtualEthernetCrossover*>(VirtualEthernetCrossover_factory->instantiate("virtualethernetcrossover", simulationContext, params_virtualethernetcrossover__));
			assert(virtualethernetcrossover);
			add(virtualethernetcrossover);
		}
		{
			sg::Params params_hostbridge__ = params.getParamsFor("hostbridge");
			hostbridge = dynamic_cast<Component__HostBridge*>(HostBridge_factory->instantiate("hostbridge", simulationContext, params_hostbridge__));
			assert(hostbridge);
			add(hostbridge);
		}
		{
			sg::Params params_vfs2__ = params.getParamsFor("vfs2");
			vfs2 = dynamic_cast<Component__VFS2*>(VFS2_factory->instantiate("vfs2", simulationContext, params_vfs2__));
			assert(vfs2);
			add(vfs2);
		}
		{
			sg::Params params_virtioblockdevice__ = params.getParamsFor("virtioblockdevice");
			add(virtioblockdevice = VirtioBlockDevice_factory->instantiate("virtioblockdevice", simulationContext, params_virtioblockdevice__));
		}
		VE_SysRegs_factory->dereference();
		VEVisualisation_factory->dereference();
		VE_CompactFlash_factory->dereference();
		ClockDivider_factory->dereference();
		MasterClock_factory->dereference();
		PVBusDecoder_factory->dereference();
		AudioOut_SDL_factory->dereference();
		FlashLoader_factory->dereference();
		PL011_Uart_factory->dereference();
		PL050_KMI_factory->dereference();
		PL111_CLCD_factory->dereference();
		PS2Keyboard_factory->dereference();
		PS2Mouse_factory->dereference();
		RAMDevice_factory->dereference();
		SMSC_91C111_factory->dereference();
		TelnetTerminal_factory->dereference();
		PL031_RTC_factory->dereference();
		PL041_AACI_factory->dereference();
		SP804_Timer_factory->dereference();
		SP810_SysCtrl_factory->dereference();
		MMC_factory->dereference();
		PL180_MCI_factory->dereference();
		SP805_Watchdog_factory->dereference();
		VirtualEthernetCrossover_factory->dereference();
		HostBridge_factory->dereference();
		VirtioBlockDevice_factory->dereference();
		VFS2_factory->dereference();
		IntelStrataFlashJ3_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__VEMotherBoard::control_port__configure, this);
    bind_method(control_port, init, &Component__VEMotherBoard::init, this);
    bind_method(control_port, interconnect, &Component__VEMotherBoard::interconnect, this);
//  bind_method(control_port, postConnect, &Component__VEMotherBoard::postConnect, this);
    bind_method(control_port, reset, &Component__VEMotherBoard::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__VEMotherBoard::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__VEMotherBoard::disconnect, this);
    bind_method(control_port, terminate, &Component__VEMotherBoard::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__VEMotherBoard::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__VEMotherBoard::refresh, this);
    bind_method(control_port, step, &Component__VEMotherBoard::step, this);
    bind_method(control_port, update, &Component__VEMotherBoard::update, this);
    bind_method(control_port, communicate, &Component__VEMotherBoard::communicate, this);
    bind_method(control_port, getProperty, &Component__VEMotherBoard::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__VEMotherBoard::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__VEMotherBoard::control_port__bypass, this);
    bind_method(control_port, run, &Component__VEMotherBoard::control_port__run, this);
    bind_method(control_port, stop, &Component__VEMotherBoard::control_port__stop, this);
    bind_method(control_port, idle, &Component__VEMotherBoard::control_port__idle, this);
    bind_method(control_port, quit, &Component__VEMotherBoard::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__VEMotherBoard::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__VEMotherBoard::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__VEMotherBoard::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__VEMotherBoard::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__VEMotherBoard::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__VEMotherBoard::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__VEMotherBoard::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__VEMotherBoard::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_sp805_wdog__.connectTo(sp805_wdog->findPort("$control"));
	controlPort_pl050_kmi1__.connectTo(pl050_kmi1->findPort("$control"));
	controlPort_pl050_kmi0__.connectTo(pl050_kmi0->findPort("$control"));
	controlPort_Timer_2_3__.connectTo(Timer_2_3->findPort("$control"));
	controlPort_Timer_0_1__.connectTo(Timer_0_1->findPort("$control"));
	controlPort_sp810_sysctrl__.connectTo(sp810_sysctrl->findPort("$control"));
	controlPort_pl111_clcd__.connectTo(pl111_clcd->findPort("$control"));
	controlPort_pl031_rtc__.connectTo(pl031_rtc->findPort("$control"));
	controlPort_pl011_uart3__.connectTo(pl011_uart3->findPort("$control"));
	controlPort_pl011_uart2__.connectTo(pl011_uart2->findPort("$control"));
	controlPort_pl011_uart1__.connectTo(pl011_uart1->findPort("$control"));
	controlPort_pl011_uart0__.connectTo(pl011_uart0->findPort("$control"));
	controlPort_pl180_mci__.connectTo(pl180_mci->findPort("$control"));
	controlPort_pl041_aaci__.connectTo(pl041_aaci->findPort("$control"));
	controlPort_ve_sysregs__.connectTo(ve_sysregs->findPort("$control"));
	controlPort_smsc_91c111__.connectTo(smsc_91c111->findPort("$control"));
	controlPort_ps2mouse__.connectTo(ps2mouse->findPort("$control"));
	controlPort_ps2keyboard__.connectTo(ps2keyboard->findPort("$control"));
	controlPort_mmc__.connectTo(mmc->findPort("$control"));
	controlPort_dummy_CF__.connectTo(dummy_CF->findPort("$control"));
	controlPort_dummy_usb__.connectTo(dummy_usb->findPort("$control"));
	controlPort_dummy_ram__.connectTo(dummy_ram->findPort("$control"));
	controlPort_dummy_local_dap_rom__.connectTo(dummy_local_dap_rom->findPort("$control"));
	controlPort_psram__.connectTo(psram->findPort("$control"));
	controlPort_vram__.connectTo(vram->findPort("$control"));
	controlPort_flash1__.connectTo(flash1->findPort("$control"));
	controlPort_flash0__.connectTo(flash0->findPort("$control"));
	controlPort_flashloader1__.connectTo(flashloader1->findPort("$control"));
	controlPort_flashloader0__.connectTo(flashloader0->findPort("$control"));
	controlPort_clk__.connectTo(clk->findPort("$control"));
	controlPort_clock24MHz__.connectTo(clock24MHz->findPort("$control"));
	controlPort_clock100Hz__.connectTo(clock100Hz->findPort("$control"));
	controlPort_clockCLCD__.connectTo(clockCLCD->findPort("$control"));
	controlPort_clock35MHz__.connectTo(clock35MHz->findPort("$control"));
	controlPort_clock50Hz__.connectTo(clock50Hz->findPort("$control"));
	controlPort_cs3_decoder__.connectTo(cs3_decoder->findPort("$control"));
	controlPort_cs2_decoder__.connectTo(cs2_decoder->findPort("$control"));
	controlPort_terminal_0__.connectTo(terminal_0->findPort("$control"));
	controlPort_terminal_1__.connectTo(terminal_1->findPort("$control"));
	controlPort_terminal_2__.connectTo(terminal_2->findPort("$control"));
	controlPort_terminal_3__.connectTo(terminal_3->findPort("$control"));
	controlPort_audioout__.connectTo(audioout->findPort("$control"));
	controlPort_vis__.connectTo(vis->findPort("$control"));
	controlPort_virtualethernetcrossover__.connectTo(virtualethernetcrossover->findPort("$control"));
	controlPort_hostbridge__.connectTo(hostbridge->findPort("$control"));
	controlPort_vfs2__.connectTo(vfs2->findPort("$control"));
	controlPort_virtioblockdevice__.connectTo(virtioblockdevice->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports


    // add abstract ports
	publishMasterPort("masterclk", masterclk);
	masterclk.SetName__("masterclk");
	publishMasterPortArray("interrupts", interrupts, 48);
	{for(int i = 0; i < 48; ++i) interrupts[i].SetName__("interrupts");}
	publishMasterPortArray("CB", CB, 2);
	{for(int i = 0; i < 2; ++i) CB[i].SetName__("CB");}
	publishMasterPort("clcd_pvbus", clcd_pvbus);
	clcd_pvbus.SetName__("clcd_pvbus");
	publishMasterPort("virtio_m", virtio_m);
	virtio_m.SetName__("virtio_m");
	publishSlavePort("mmb_db1", mmb_db1);
	mmb_db1.SetName__("mmb_db1");
	publishSlavePortArray("smb_cs", smb_cs, 8);
	{for(int i = 0; i < 8; ++i) smb_cs[i].SetName__("smb_cs");}
	publishSlavePortArray("cluster0_ticks", cluster0_ticks, 4);
	{for(int i = 0; i < 4; ++i) cluster0_ticks[i].SetName__("cluster0_ticks");}
	publishSlavePortArray("cluster1_ticks", cluster1_ticks, 4);
	{for(int i = 0; i < 4; ++i) cluster1_ticks[i].SetName__("cluster1_ticks");}
	publishSlavePort("daughter_leds", daughter_leds);
	daughter_leds.SetName__("daughter_leds");
	publishSlavePort("daughter_switches", daughter_switches);
	daughter_switches.SetName__("daughter_switches");


    // wire up static connection map
	clk->findPort("clk_out").connectTo(pl031_rtc->findPort("clock"));
	clk->findPort("clk_out").connectTo(clock24MHz->findPort("clk_in"));
	clk->findPort("clk_out").connectTo(clock35MHz->findPort("clk_in"));
	clk->findPort("clk_out").connectTo(clockCLCD->findPort("clk_in"));
	clk->findPort("clk_out").connectTo(clock100Hz->findPort("clk_in"));
	clk->findPort("clk_out").connectTo(clock50Hz->findPort("clk_in"));
	clk->findPort("clk_out").connectTo(masterclk);
	clock24MHz->findPort("clk_out").connectTo(ve_sysregs->findPort("clock_24Mhz"));
	clock35MHz->findPort("clk_out").connectTo(Timer_0_1->findPort("clock"));
	clock35MHz->findPort("clk_out").connectTo(Timer_2_3->findPort("clock"));
	clock24MHz->findPort("clk_out").connectTo(pl011_uart0->findPort("clk_in_ref"));
	clock24MHz->findPort("clk_out").connectTo(pl011_uart1->findPort("clk_in_ref"));
	clock24MHz->findPort("clk_out").connectTo(pl011_uart2->findPort("clk_in_ref"));
	clock24MHz->findPort("clk_out").connectTo(pl011_uart3->findPort("clk_in_ref"));
	clock24MHz->findPort("clk_out").connectTo(ps2keyboard->findPort("clk_in"));
	clock24MHz->findPort("clk_out").connectTo(ps2mouse->findPort("clk_in"));
	clock24MHz->findPort("clk_out").connectTo(mmc->findPort("clk_in"));
	clock24MHz->findPort("clk_out").connectTo(pl041_aaci->findPort("clk_in_ref"));
	clock24MHz->findPort("clk_out").connectTo(smsc_91c111->findPort("clock"));
	clock24MHz->findPort("clk_out").connectTo(sp805_wdog->findPort("clk_in"));
	ve_sysregs->findPort("clock_CLCD").connectTo(clockCLCD->findPort("rate"));
	clockCLCD->findPort("clk_out").connectTo(pl111_clcd->findPort("clk_in"));
	clock100Hz->findPort("clk_out").connectTo(ve_sysregs->findPort("clock_100Hz"));
	sp810_sysctrl->findPort("timer_clk_en", 0).connectTo(Timer_0_1->findPort("timer_en", 0));
	sp810_sysctrl->findPort("timer_clk_en", 1).connectTo(Timer_0_1->findPort("timer_en", 1));
	sp810_sysctrl->findPort("timer_clk_en", 2).connectTo(Timer_2_3->findPort("timer_en", 0));
	sp810_sysctrl->findPort("timer_clk_en", 3).connectTo(Timer_2_3->findPort("timer_en", 1));
	clock50Hz->findPort("clk_out").connectTo(vis->findPort("clock_50Hz"));
	sp805_wdog->findPort("irq_out").connectTo(interrupts[0]);
	Timer_0_1->findPort("irq_out0").connectTo(interrupts[2]);
	Timer_0_1->findPort("irq_out1").connectTo(interrupts[2]);
	Timer_2_3->findPort("irq_out0").connectTo(interrupts[3]);
	Timer_2_3->findPort("irq_out1").connectTo(interrupts[3]);
	pl031_rtc->findPort("intr").connectTo(interrupts[4]);
	pl011_uart0->findPort("intr").connectTo(interrupts[5]);
	pl011_uart1->findPort("intr").connectTo(interrupts[6]);
	pl011_uart2->findPort("intr").connectTo(interrupts[7]);
	pl011_uart3->findPort("intr").connectTo(interrupts[8]);
	pl180_mci->findPort("MCIINTR", 0).connectTo(interrupts[9]);
	pl180_mci->findPort("MCIINTR", 1).connectTo(interrupts[10]);
	pl041_aaci->findPort("irq").connectTo(interrupts[11]);
	pl050_kmi0->findPort("intr").connectTo(interrupts[12]);
	pl050_kmi1->findPort("intr").connectTo(interrupts[13]);
	pl111_clcd->findPort("intr").connectTo(interrupts[14]);
	smsc_91c111->findPort("intr").connectTo(interrupts[15]);
	vfs2->findPort("intr").connectTo(interrupts[41]);
	virtioblockdevice->findPort("intr").connectTo(interrupts[42]);
	for (MxU32 i__ = 0; i__ < 4; ++i__)
	{
	cluster0_ticks[i__].connectTo(vis->findPort("cluster0_ticks", i__));

	}
	for (MxU32 i__ = 0; i__ < 4; ++i__)
	{
	cluster1_ticks[i__].connectTo(vis->findPort("cluster1_ticks", i__));

	}
	daughter_leds.connectTo(vis->findPort("daughter_leds"));
	daughter_switches.connectTo(vis->findPort("daughter_user_switches"));
	ve_sysregs->findPort("user_switches").connectTo(vis->findPort("user_switches"));
	ve_sysregs->findPort("leds").connectTo(vis->findPort("leds"));
	ve_sysregs->findPort("lcd").connectTo(vis->findPort("lcd"));
	for (MxU32 i__ = 0; i__ < 2; ++i__)
	{
	ve_sysregs->findPort("cb", i__).connectTo(CB[i__]);

	}
	pl041_aaci->findPort("audio").connectTo(audioout->findPort("audio"));
	pl180_mci->findPort("mmc_m").connectTo(mmc->findPort("mmc"));
	mmc->findPort("card_present").connectTo(ve_sysregs->findPort("mmc_card_present"));
	vis->findPort("keyboard").connectTo(ps2keyboard->findPort("keyboard"));
	vis->findPort("mouse").connectTo(ps2mouse->findPort("mouse"));
	ps2keyboard->findPort("ps2").connectTo(pl050_kmi0->findPort("ps2device"));
	ps2mouse->findPort("ps2").connectTo(pl050_kmi1->findPort("ps2device"));
	hostbridge->findPort("eth").connectTo(virtualethernetcrossover->findPort("devb"));
	smsc_91c111->findPort("eth").connectTo(virtualethernetcrossover->findPort("deva"));
	pl011_uart0->findPort("serial_out").connectTo(terminal_0->findPort("serial"));
	pl011_uart1->findPort("serial_out").connectTo(terminal_1->findPort("serial"));
	pl011_uart2->findPort("serial_out").connectTo(terminal_2->findPort("serial"));
	pl011_uart3->findPort("serial_out").connectTo(terminal_3->findPort("serial"));
	flashloader1->findPort("flash_device0").connectTo(flash1->findPort("flashloader"));
	flashloader0->findPort("flash_device0").connectTo(flash0->findPort("flashloader"));
	pl111_clcd->findPort("display").connectTo(ve_sysregs->findPort("mmb", 0));
	mmb_db1.connectTo(ve_sysregs->findPort("mmb", 1));
	smb_cs[0].connectTo(flash0->findPort("pvbus"));
	smb_cs[1].connectTo(psram->findPort("pvbus"));
	smb_cs[2].connectTo(cs2_decoder->findPort("pvbus_s"));
	smb_cs[3].connectTo(cs3_decoder->findPort("pvbus_s"));
	smb_cs[4].connectTo(flash1->findPort("pvbus"));
	smb_cs[5].connectTo(dummy_ram->findPort("pvbus"));
	smb_cs[6].connectTo(dummy_ram->findPort("pvbus"));
	smb_cs[7].connectTo(dummy_ram->findPort("pvbus"));
	virtioblockdevice->findPort("virtio_m").connectTo(virtio_m);
	pl111_clcd->findPort("pvbus_m").connectTo(clcd_pvbus);
	FVP_VE_Cortex_A15x1__Builtin__AddressablePortProtocol tmp__; // temporary addressable port control port
	tmp__.setName("tmp_addressmap_control");
	tmp__.setParent(this);	tmp__.connectTo(cs2_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00000000), MxU64CONST(0x01FFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x01FFFFFF))->connectTo(vram->findPort("pvbus"));
	tmp__.disconnectFrom(cs2_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs2_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x02000000), MxU64CONST(0x02FFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x00FFFFFF))->connectTo(smsc_91c111->findPort("pvbus"));
	tmp__.disconnectFrom(cs2_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs2_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x03000000), MxU64CONST(0x03FFFFFF), MxU64CONST(0x00000000), MxU64CONST(0x00FFFFFF))->connectTo(dummy_usb->findPort("pvbus"));
	tmp__.disconnectFrom(cs2_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(dummy_local_dap_rom->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00010000), MxU64CONST(0x0001FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(ve_sysregs->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00020000), MxU64CONST(0x0002FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(sp810_sysctrl->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00040000), MxU64CONST(0x0004FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl041_aaci->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00050000), MxU64CONST(0x0005FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl180_mci->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00060000), MxU64CONST(0x0006FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl050_kmi0->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00070000), MxU64CONST(0x0007FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl050_kmi1->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00090000), MxU64CONST(0x0009FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl011_uart0->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x000A0000), MxU64CONST(0x000AFFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl011_uart1->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x000B0000), MxU64CONST(0x000BFFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl011_uart2->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x000C0000), MxU64CONST(0x000CFFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl011_uart3->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x000D0000), MxU64CONST(0x000DFFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(vfs2->findPort("pvbus_s"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x000F0000), MxU64CONST(0x000FFFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(sp805_wdog->findPort("pvbus_s"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00110000), MxU64CONST(0x0011FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(Timer_0_1->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00120000), MxU64CONST(0x0012FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(Timer_2_3->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00130000), MxU64CONST(0x0013FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(virtioblockdevice->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x00170000), MxU64CONST(0x0017FFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl031_rtc->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x001A0000), MxU64CONST(0x001AFFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(dummy_CF->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.connectTo(cs3_decoder->findPort("pvbus_m_range"));
	tmp__.mapRange(MxU64CONST(0x001F0000), MxU64CONST(0x001FFFFF), MxU64CONST(0x00000000), MxU64CONST(0x0000FFFF))->connectTo(pl111_clcd->findPort("pvbus"));
	tmp__.disconnectFrom(cs3_decoder->findPort("pvbus_m_range"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__VEMotherBoard::~Component__VEMotherBoard()
{
}

void Component__VEMotherBoard::control_port__configure(const sg::Params& params)
{
	if(controlPort_sp805_wdog__.configure.implemented()) controlPort_sp805_wdog__.configure(params.getParamsFor("sp805_wdog"));
	if(controlPort_pl050_kmi1__.configure.implemented()) controlPort_pl050_kmi1__.configure(params.getParamsFor("pl050_kmi1"));
	if(controlPort_pl050_kmi0__.configure.implemented()) controlPort_pl050_kmi0__.configure(params.getParamsFor("pl050_kmi0"));
	if(controlPort_Timer_2_3__.configure.implemented()) controlPort_Timer_2_3__.configure(params.getParamsFor("Timer_2_3"));
	if(controlPort_Timer_0_1__.configure.implemented()) controlPort_Timer_0_1__.configure(params.getParamsFor("Timer_0_1"));
	if(controlPort_sp810_sysctrl__.configure.implemented()) controlPort_sp810_sysctrl__.configure(params.getParamsFor("sp810_sysctrl"));
	if(controlPort_pl111_clcd__.configure.implemented()) controlPort_pl111_clcd__.configure(params.getParamsFor("pl111_clcd"));
	if(controlPort_pl031_rtc__.configure.implemented()) controlPort_pl031_rtc__.configure(params.getParamsFor("pl031_rtc"));
	if(controlPort_pl011_uart3__.configure.implemented()) controlPort_pl011_uart3__.configure(params.getParamsFor("pl011_uart3"));
	if(controlPort_pl011_uart2__.configure.implemented()) controlPort_pl011_uart2__.configure(params.getParamsFor("pl011_uart2"));
	if(controlPort_pl011_uart1__.configure.implemented()) controlPort_pl011_uart1__.configure(params.getParamsFor("pl011_uart1"));
	if(controlPort_pl011_uart0__.configure.implemented()) controlPort_pl011_uart0__.configure(params.getParamsFor("pl011_uart0"));
	if(controlPort_pl180_mci__.configure.implemented()) controlPort_pl180_mci__.configure(params.getParamsFor("pl180_mci"));
	if(controlPort_pl041_aaci__.configure.implemented()) controlPort_pl041_aaci__.configure(params.getParamsFor("pl041_aaci"));
	if(controlPort_ve_sysregs__.configure.implemented()) controlPort_ve_sysregs__.configure(params.getParamsFor("ve_sysregs"));
	if(controlPort_smsc_91c111__.configure.implemented()) controlPort_smsc_91c111__.configure(params.getParamsFor("smsc_91c111"));
	if(controlPort_ps2mouse__.configure.implemented()) controlPort_ps2mouse__.configure(params.getParamsFor("ps2mouse"));
	if(controlPort_ps2keyboard__.configure.implemented()) controlPort_ps2keyboard__.configure(params.getParamsFor("ps2keyboard"));
	if(controlPort_mmc__.configure.implemented()) controlPort_mmc__.configure(params.getParamsFor("mmc"));
	if(controlPort_dummy_CF__.configure.implemented()) controlPort_dummy_CF__.configure(params.getParamsFor("dummy_CF"));
	if(controlPort_dummy_usb__.configure.implemented()) controlPort_dummy_usb__.configure(params.getParamsFor("dummy_usb"));
	if(controlPort_dummy_ram__.configure.implemented()) controlPort_dummy_ram__.configure(params.getParamsFor("dummy_ram"));
	if(controlPort_dummy_local_dap_rom__.configure.implemented()) controlPort_dummy_local_dap_rom__.configure(params.getParamsFor("dummy_local_dap_rom"));
	if(controlPort_psram__.configure.implemented()) controlPort_psram__.configure(params.getParamsFor("psram"));
	if(controlPort_vram__.configure.implemented()) controlPort_vram__.configure(params.getParamsFor("vram"));
	if(controlPort_flash1__.configure.implemented()) controlPort_flash1__.configure(params.getParamsFor("flash1"));
	if(controlPort_flash0__.configure.implemented()) controlPort_flash0__.configure(params.getParamsFor("flash0"));
	if(controlPort_flashloader1__.configure.implemented()) controlPort_flashloader1__.configure(params.getParamsFor("flashloader1"));
	if(controlPort_flashloader0__.configure.implemented()) controlPort_flashloader0__.configure(params.getParamsFor("flashloader0"));
	if(controlPort_clk__.configure.implemented()) controlPort_clk__.configure(params.getParamsFor("clk"));
	if(controlPort_clock24MHz__.configure.implemented()) controlPort_clock24MHz__.configure(params.getParamsFor("clock24MHz"));
	if(controlPort_clock100Hz__.configure.implemented()) controlPort_clock100Hz__.configure(params.getParamsFor("clock100Hz"));
	if(controlPort_clockCLCD__.configure.implemented()) controlPort_clockCLCD__.configure(params.getParamsFor("clockCLCD"));
	if(controlPort_clock35MHz__.configure.implemented()) controlPort_clock35MHz__.configure(params.getParamsFor("clock35MHz"));
	if(controlPort_clock50Hz__.configure.implemented()) controlPort_clock50Hz__.configure(params.getParamsFor("clock50Hz"));
	if(controlPort_cs3_decoder__.configure.implemented()) controlPort_cs3_decoder__.configure(params.getParamsFor("cs3_decoder"));
	if(controlPort_cs2_decoder__.configure.implemented()) controlPort_cs2_decoder__.configure(params.getParamsFor("cs2_decoder"));
	if(controlPort_terminal_0__.configure.implemented()) controlPort_terminal_0__.configure(params.getParamsFor("terminal_0"));
	if(controlPort_terminal_1__.configure.implemented()) controlPort_terminal_1__.configure(params.getParamsFor("terminal_1"));
	if(controlPort_terminal_2__.configure.implemented()) controlPort_terminal_2__.configure(params.getParamsFor("terminal_2"));
	if(controlPort_terminal_3__.configure.implemented()) controlPort_terminal_3__.configure(params.getParamsFor("terminal_3"));
	if(controlPort_audioout__.configure.implemented()) controlPort_audioout__.configure(params.getParamsFor("audioout"));
	if(controlPort_vis__.configure.implemented()) controlPort_vis__.configure(params.getParamsFor("vis"));
	if(controlPort_virtualethernetcrossover__.configure.implemented()) controlPort_virtualethernetcrossover__.configure(params.getParamsFor("virtualethernetcrossover"));
	if(controlPort_hostbridge__.configure.implemented()) controlPort_hostbridge__.configure(params.getParamsFor("hostbridge"));
	if(controlPort_vfs2__.configure.implemented()) controlPort_vfs2__.configure(params.getParamsFor("vfs2"));
	if(controlPort_virtioblockdevice__.configure.implemented()) controlPort_virtioblockdevice__.configure(params.getParamsFor("virtioblockdevice"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__VEMotherBoard_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__VEMotherBoard::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_sp805_wdog__.populateCADIMap.implemented())
			{
				controlPort_sp805_wdog__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl050_kmi1__.populateCADIMap.implemented())
			{
				controlPort_pl050_kmi1__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl050_kmi0__.populateCADIMap.implemented())
			{
				controlPort_pl050_kmi0__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_Timer_2_3__.populateCADIMap.implemented())
			{
				controlPort_Timer_2_3__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_Timer_0_1__.populateCADIMap.implemented())
			{
				controlPort_Timer_0_1__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_sp810_sysctrl__.populateCADIMap.implemented())
			{
				controlPort_sp810_sysctrl__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl111_clcd__.populateCADIMap.implemented())
			{
				controlPort_pl111_clcd__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl031_rtc__.populateCADIMap.implemented())
			{
				controlPort_pl031_rtc__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl011_uart3__.populateCADIMap.implemented())
			{
				controlPort_pl011_uart3__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl011_uart2__.populateCADIMap.implemented())
			{
				controlPort_pl011_uart2__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl011_uart1__.populateCADIMap.implemented())
			{
				controlPort_pl011_uart1__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl011_uart0__.populateCADIMap.implemented())
			{
				controlPort_pl011_uart0__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl180_mci__.populateCADIMap.implemented())
			{
				controlPort_pl180_mci__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl041_aaci__.populateCADIMap.implemented())
			{
				controlPort_pl041_aaci__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_ve_sysregs__.populateCADIMap.implemented())
			{
				controlPort_ve_sysregs__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("ve_sysregs", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_ve_sysregs_of_VE_SysRegs_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_ve_sysregs_of_VE_SysRegs_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_smsc_91c111__.populateCADIMap.implemented())
			{
				controlPort_smsc_91c111__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_ps2mouse__.populateCADIMap.implemented())
			{
				controlPort_ps2mouse__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_ps2keyboard__.populateCADIMap.implemented())
			{
				controlPort_ps2keyboard__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_mmc__.populateCADIMap.implemented())
			{
				controlPort_mmc__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dummy_CF__.populateCADIMap.implemented())
			{
				controlPort_dummy_CF__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dummy_usb__.populateCADIMap.implemented())
			{
				controlPort_dummy_usb__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("dummy_usb", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_dummy_usb_of_RAMDevice_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_dummy_usb_of_RAMDevice_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dummy_ram__.populateCADIMap.implemented())
			{
				controlPort_dummy_ram__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("dummy_ram", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_dummy_ram_of_RAMDevice_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_dummy_ram_of_RAMDevice_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_dummy_local_dap_rom__.populateCADIMap.implemented())
			{
				controlPort_dummy_local_dap_rom__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("dummy_local_dap_rom", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_dummy_local_dap_rom_of_RAMDevice_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_dummy_local_dap_rom_of_RAMDevice_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_psram__.populateCADIMap.implemented())
			{
				controlPort_psram__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("psram", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_psram_of_RAMDevice_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_psram_of_RAMDevice_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_vram__.populateCADIMap.implemented())
			{
				controlPort_vram__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("vram", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_vram_of_RAMDevice_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_vram_of_RAMDevice_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_flash1__.populateCADIMap.implemented())
			{
				controlPort_flash1__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("flash1", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_flash1_of_IntelStrataFlashJ3_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_flash1_of_IntelStrataFlashJ3_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_flash0__.populateCADIMap.implemented())
			{
				controlPort_flash0__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("flash0", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_flash0_of_IntelStrataFlashJ3_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_flash0_of_IntelStrataFlashJ3_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_flashloader1__.populateCADIMap.implemented())
			{
				controlPort_flashloader1__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_flashloader0__.populateCADIMap.implemented())
			{
				controlPort_flashloader0__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clk__.populateCADIMap.implemented())
			{
				controlPort_clk__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clock24MHz__.populateCADIMap.implemented())
			{
				controlPort_clock24MHz__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("clock24MHz", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_clock24MHz_of_ClockDivider_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_clock24MHz_of_ClockDivider_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clock100Hz__.populateCADIMap.implemented())
			{
				controlPort_clock100Hz__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("clock100Hz", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_clock100Hz_of_ClockDivider_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_clock100Hz_of_ClockDivider_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clockCLCD__.populateCADIMap.implemented())
			{
				controlPort_clockCLCD__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("clockCLCD", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_clockCLCD_of_ClockDivider_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_clockCLCD_of_ClockDivider_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clock35MHz__.populateCADIMap.implemented())
			{
				controlPort_clock35MHz__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("clock35MHz", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_clock35MHz_of_ClockDivider_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_clock35MHz_of_ClockDivider_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clock50Hz__.populateCADIMap.implemented())
			{
				controlPort_clock50Hz__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("clock50Hz", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_clock50Hz_of_ClockDivider_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_clock50Hz_of_ClockDivider_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_cs3_decoder__.populateCADIMap.implemented())
			{
				controlPort_cs3_decoder__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_cs2_decoder__.populateCADIMap.implemented())
			{
				controlPort_cs2_decoder__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_terminal_0__.populateCADIMap.implemented())
			{
				controlPort_terminal_0__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_terminal_1__.populateCADIMap.implemented())
			{
				controlPort_terminal_1__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_terminal_2__.populateCADIMap.implemented())
			{
				controlPort_terminal_2__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_terminal_3__.populateCADIMap.implemented())
			{
				controlPort_terminal_3__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_audioout__.populateCADIMap.implemented())
			{
				controlPort_audioout__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_vis__.populateCADIMap.implemented())
			{
				controlPort_vis__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("vis", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_vis_of_VEVisualisation_to_VEMotherBoard__ = new CADIParameterProxy(cadi, &parameterFilter_vis_of_VEVisualisation_to_VEMotherBoard__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_virtualethernetcrossover__.populateCADIMap.implemented())
			{
				controlPort_virtualethernetcrossover__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_hostbridge__.populateCADIMap.implemented())
			{
				controlPort_hostbridge__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_vfs2__.populateCADIMap.implemented())
			{
				controlPort_vfs2__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_virtioblockdevice__.populateCADIMap.implemented())
			{
				controlPort_virtioblockdevice__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__VEMotherBoard::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__VEMotherBoard::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__VEMotherBoard::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__VEMotherBoard::control_port__bypass(const std::string&)
{
    return "";
}


void Component__VEMotherBoard::control_port__run()
{
}


void Component__VEMotherBoard::control_port__stop()
{
}


void Component__VEMotherBoard::control_port__idle()
{
}


void Component__VEMotherBoard::control_port__quit()
{
}


void Component__VEMotherBoard::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__VEMotherBoard::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__VEMotherBoard::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__VEMotherBoard::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__VEMotherBoard::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__VEMotherBoard::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_ve_sysregs_of_VE_SysRegs_to_VEMotherBoard__;
	cadiParameterProxy_ve_sysregs_of_VE_SysRegs_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_dummy_usb_of_RAMDevice_to_VEMotherBoard__;
	cadiParameterProxy_dummy_usb_of_RAMDevice_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_dummy_ram_of_RAMDevice_to_VEMotherBoard__;
	cadiParameterProxy_dummy_ram_of_RAMDevice_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_dummy_local_dap_rom_of_RAMDevice_to_VEMotherBoard__;
	cadiParameterProxy_dummy_local_dap_rom_of_RAMDevice_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_psram_of_RAMDevice_to_VEMotherBoard__;
	cadiParameterProxy_psram_of_RAMDevice_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_vram_of_RAMDevice_to_VEMotherBoard__;
	cadiParameterProxy_vram_of_RAMDevice_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_flash1_of_IntelStrataFlashJ3_to_VEMotherBoard__;
	cadiParameterProxy_flash1_of_IntelStrataFlashJ3_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_flash0_of_IntelStrataFlashJ3_to_VEMotherBoard__;
	cadiParameterProxy_flash0_of_IntelStrataFlashJ3_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_clock24MHz_of_ClockDivider_to_VEMotherBoard__;
	cadiParameterProxy_clock24MHz_of_ClockDivider_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_clock100Hz_of_ClockDivider_to_VEMotherBoard__;
	cadiParameterProxy_clock100Hz_of_ClockDivider_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_clockCLCD_of_ClockDivider_to_VEMotherBoard__;
	cadiParameterProxy_clockCLCD_of_ClockDivider_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_clock35MHz_of_ClockDivider_to_VEMotherBoard__;
	cadiParameterProxy_clock35MHz_of_ClockDivider_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_clock50Hz_of_ClockDivider_to_VEMotherBoard__;
	cadiParameterProxy_clock50Hz_of_ClockDivider_to_VEMotherBoard__ = 0;
	delete cadiParameterProxy_vis_of_VEVisualisation_to_VEMotherBoard__;
	cadiParameterProxy_vis_of_VEVisualisation_to_VEMotherBoard__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__VEMotherBoard::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__VEMotherBoard::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__VEMotherBoard::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__VEMotherBoard::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_proc_id0: *data = proc_id0; break;
	case PARAMETER_ID_proc_id1: *data = proc_id1; break;
	case PARAMETER_ID_number_of_daughter_leds: *data = number_of_daughter_leds; break;
	case PARAMETER_ID_number_of_daughter_switches: *data = number_of_daughter_switches; break;

        default:
            printf("error: Component__VEMotherBoard::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEMotherBoard::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VEMotherBoard::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEMotherBoard::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_proc_id0:
		{
			*(const_cast<uint32_t*>(&proc_id0)) = *data;
		}
		break;
	case PARAMETER_ID_proc_id1:
		{
			*(const_cast<uint32_t*>(&proc_id1)) = *data;
		}
		break;
	case PARAMETER_ID_number_of_daughter_leds:
		{
			*(const_cast<uint32_t*>(&number_of_daughter_leds)) = *data;
		}
		break;
	case PARAMETER_ID_number_of_daughter_switches:
		{
			*(const_cast<uint32_t*>(&number_of_daughter_switches)) = *data;
		}
		break;

        default:
            printf("error: Component__VEMotherBoard::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VEMotherBoard::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VEMotherBoard::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__VEMotherBoard::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__VEMotherBoard::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__VEMotherBoard::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__VEMotherBoard::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__VEMotherBoard::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__VEMotherBoard::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__VEMotherBoard::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__VEMotherBoard::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__VEMotherBoard::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "proc_id0") id = PARAMETER_ID_proc_id0;
    if (name == "proc_id1") id = PARAMETER_ID_proc_id1;
    if (name == "daughter_led_count") id = PARAMETER_ID_number_of_daughter_leds;
    if (name == "daughter_user_switch_count") id = PARAMETER_ID_number_of_daughter_switches;

    return id;
}

void Component__VEMotherBoard::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 116 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__SP804_Timer::registerRead(pv::bus_addr_t device_addr)
{
 uint32_t ret;
 switch (device_addr) 
 { 
 
 case 0x000: ret=counter0->getLoadRegister(); 
 break;
 case 0x004: ret=counter0->getValueRegister(); 
 break;
 case 0x008: ret=counter0->getControlRegister(); 
 break;
 case 0x00c: ret=0xff; 
 break;
 case 0x010: ret=counter0->getRawIntStatus(); 
 break;
 case 0x014: ret=counter0->getMaskedIntStatus(); 
 break;
 case 0x018: ret=counter0->getBGLoadRegister(); 
 break;
 
 
 case 0x020: ret=counter1->getLoadRegister(); 
 break;
 case 0x024: ret=counter1->getValueRegister(); 
 break;
 case 0x028: ret=counter1->getControlRegister(); 
 break;
 case 0x02c: ret=0xff; 
 break;
 case 0x030: ret=counter1->getRawIntStatus(); 
 break;
 case 0x034: ret=counter1->getMaskedIntStatus(); 
 break;
 case 0x038: ret=counter1->getBGLoadRegister(); 
 break;
 
 
 case 0xfe0: 
 ret=0x00000004;
 break;
 case 0xfe4: 
 ret=0x00000018;
 break;
 case 0xfe8: 
 ret=0x00000014; 
 break;
 case 0xfec: 
 ret=0x00000000; 
 break;
 case 0xff0: 
 ret=0x0000000d;
 break;
 case 0xff4: 
 ret=0x000000f0;
 break;
 case 0xff8: 
 ret=0x00000005;
 break;
 case 0xffc: 
 ret=0x000000b1;
 break;
 
 default: ret=0x00; 
 break;
 }

 if (!0) ; else printf("%s: Rd 0x%08x <- 0x%04x\n",
 getInstanceName().c_str(),
 ret, (uint32_t)device_addr);
 return ret;
 
}
}

#line 189 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::registerWrite(pv::bus_addr_t device_addr, uint32_t data)
{
 if (!0) ; else printf("%s: Wr 0x%08x -> 0x%04x\n",
 getInstanceName().c_str(),
 data, (uint32_t)device_addr);

 switch (device_addr) 
 {
 
 
 case 0x000: 
 counter0->setLoadRegister(data);
 return;
 case 0x004: 
 return; 
 case 0x008: 
 counter0->setControlRegister(data);
 return;
 case 0x00c: 
 counter0->clearInt();
 return;
 case 0x010: 
 return;
 case 0x014: 
 return;
 case 0x018: 
 counter0->setBGLoadRegister(data);
 return;
 
 
 case 0x020: 
 counter1->setLoadRegister(data);
 return;
 case 0x024: 
 return;
 case 0x028: 
 counter1->setControlRegister(data);
 return;
 case 0x02c: 
 counter1->clearInt();
 return;
 case 0x030: 
 return;
 case 0x034: 
 return;
 case 0x038: 
 counter1->setBGLoadRegister(data);
 return;
 
 default: return;
 }
 
}
}

#line 244 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__SP804_Timer::debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects)
{
 *datap = registerRead(reg_id);

 return ACCESS_FUNC_OK;
 
}
}

#line 251 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__SP804_Timer::debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects)
{
 registerWrite(reg_id, (uint32_t)*datap);

 return ACCESS_FUNC_OK;
 
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::interconnect()
{{if(!controlPort_clk_div1__.interconnect.empty()) controlPort_clk_div1__.interconnect();if(!controlPort_clk_div0__.interconnect.empty()) controlPort_clk_div0__.interconnect();if(!controlPort_busslave__.interconnect.empty()) controlPort_busslave__.interconnect();if(!controlPort_counter0__.interconnect.empty()) controlPort_counter0__.interconnect();if(!controlPort_counter1__.interconnect.empty()) controlPort_counter1__.interconnect();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::disconnect()
{{if(!controlPort_clk_div1__.disconnect.empty()) controlPort_clk_div1__.disconnect();if(!controlPort_clk_div0__.disconnect.empty()) controlPort_clk_div0__.disconnect();if(!controlPort_busslave__.disconnect.empty()) controlPort_busslave__.disconnect();if(!controlPort_counter0__.disconnect.empty()) controlPort_counter0__.disconnect();if(!controlPort_counter1__.disconnect.empty()) controlPort_counter1__.disconnect();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::update()
{{if(!controlPort_clk_div1__.update.empty()) controlPort_clk_div1__.update();if(!controlPort_clk_div0__.update.empty()) controlPort_clk_div0__.update();if(!controlPort_busslave__.update.empty()) controlPort_busslave__.update();if(!controlPort_counter0__.update.empty()) controlPort_counter0__.update();if(!controlPort_counter1__.update.empty()) controlPort_counter1__.update();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::communicate()
{{if(!controlPort_clk_div1__.communicate.empty()) controlPort_clk_div1__.communicate();if(!controlPort_clk_div0__.communicate.empty()) controlPort_clk_div0__.communicate();if(!controlPort_busslave__.communicate.empty()) controlPort_busslave__.communicate();if(!controlPort_counter0__.communicate.empty()) controlPort_counter0__.communicate();if(!controlPort_counter1__.communicate.empty()) controlPort_counter1__.communicate();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::traceEndOfCycle()
{{if(!controlPort_clk_div1__.traceEndOfCycle.empty()) controlPort_clk_div1__.traceEndOfCycle();if(!controlPort_clk_div0__.traceEndOfCycle.empty()) controlPort_clk_div0__.traceEndOfCycle();if(!controlPort_busslave__.traceEndOfCycle.empty()) controlPort_busslave__.traceEndOfCycle();if(!controlPort_counter0__.traceEndOfCycle.empty()) controlPort_counter0__.traceEndOfCycle();if(!controlPort_counter1__.traceEndOfCycle.empty()) controlPort_counter1__.traceEndOfCycle();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::loadApplicationFile(const std::string& filename)
{{if(!controlPort_clk_div1__.loadApplicationFile.empty()) controlPort_clk_div1__.loadApplicationFile(filename);if(!controlPort_clk_div0__.loadApplicationFile.empty()) controlPort_clk_div0__.loadApplicationFile(filename);if(!controlPort_busslave__.loadApplicationFile.empty()) controlPort_busslave__.loadApplicationFile(filename);if(!controlPort_counter0__.loadApplicationFile.empty()) controlPort_counter0__.loadApplicationFile(filename);if(!controlPort_counter1__.loadApplicationFile.empty()) controlPort_counter1__.loadApplicationFile(filename);};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::init()
{{if(!controlPort_clk_div1__.init.empty()) controlPort_clk_div1__.init();if(!controlPort_clk_div0__.init.empty()) controlPort_clk_div0__.init();if(!controlPort_busslave__.init.empty()) controlPort_busslave__.init();if(!controlPort_counter0__.init.empty()) controlPort_counter0__.init();if(!controlPort_counter1__.init.empty()) controlPort_counter1__.init();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::terminate()
{{if(!controlPort_clk_div1__.terminate.empty()) controlPort_clk_div1__.terminate();if(!controlPort_clk_div0__.terminate.empty()) controlPort_clk_div0__.terminate();if(!controlPort_busslave__.terminate.empty()) controlPort_busslave__.terminate();if(!controlPort_counter0__.terminate.empty()) controlPort_counter0__.terminate();if(!controlPort_counter1__.terminate.empty()) controlPort_counter1__.terminate();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::reset(int level)
{{if(!controlPort_clk_div1__.reset.empty()) controlPort_clk_div1__.reset(level);if(!controlPort_clk_div0__.reset.empty()) controlPort_clk_div0__.reset(level);if(!controlPort_busslave__.reset.empty()) controlPort_busslave__.reset(level);if(!controlPort_counter0__.reset.empty()) controlPort_counter0__.reset(level);if(!controlPort_counter1__.reset.empty()) controlPort_counter1__.reset(level);};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__SP804_Timer::save(MxODataStream& os)
{{if(!controlPort_clk_div1__.save.empty()) controlPort_clk_div1__.save(os);if(!controlPort_clk_div0__.save.empty()) controlPort_clk_div0__.save(os);if(!controlPort_busslave__.save.empty()) controlPort_busslave__.save(os);if(!controlPort_counter0__.save.empty()) controlPort_counter0__.save(os);if(!controlPort_counter1__.save.empty()) controlPort_counter1__.save(os);};return true;
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__SP804_Timer::restore(MxIDataStream& is)
{{if(!controlPort_clk_div1__.restore.empty()) controlPort_clk_div1__.restore(is);if(!controlPort_clk_div0__.restore.empty()) controlPort_clk_div0__.restore(is);if(!controlPort_busslave__.restore.empty()) controlPort_busslave__.restore(is);if(!controlPort_counter0__.restore.empty()) controlPort_counter0__.restore(is);if(!controlPort_counter1__.restore.empty()) controlPort_counter1__.restore(is);};return true;
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__SP804_Timer::step()
{{if(!controlPort_clk_div1__.step.empty()) controlPort_clk_div1__.step();if(!controlPort_clk_div0__.step.empty()) controlPort_clk_div0__.step();if(!controlPort_busslave__.step.empty()) controlPort_busslave__.step();if(!controlPort_counter0__.step.empty()) controlPort_counter0__.step();if(!controlPort_counter1__.step.empty()) controlPort_counter1__.step();};
}
}

#line 72 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__SP804_Timer::abstract_port__device__read(pv::ReadTransaction tx)
{
 if (tx.getAccessWidth() > pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();

 
 return tx.setReturnData32(registerRead(tx.getAddress() & ~3));
 
}
}

#line 81 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__SP804_Timer::abstract_port__device__write(pv::WriteTransaction tx)
{
 if (tx.getAccessWidth() != pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 registerWrite(tx.getAddress(),
 tx.getData32());
 return tx.writeComplete();
 
}
}

#line 89 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__SP804_Timer::abstract_port__device__debugRead(pv::ReadTransaction tx)
{
 return device.read(tx);
 
}
}

#line 94 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/SP804_Timer.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__SP804_Timer::abstract_port__device__debugWrite(pv::WriteTransaction tx)
{
 return device.write(tx);
 
}
}

#line 10638 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__SP804_Timer
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__SP804_Timer::Component__SP804_Timer(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)



	,cadiParameterProxy_busslave_of_PVBusSlave_to_SP804_Timer__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "ARM Dual-Timer Module(SP804)";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = SP804_Timer_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockDivider_factory = ClockDivider_GetFactory();
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		sg::ComponentFactory *CounterModule_factory = CounterModule_GetFactory();
		{
			sg::Params params_clk_div1__ = params.getParamsFor("clk_div1");
			add(clk_div1 = ClockDivider_factory->instantiate("clk_div1", simulationContext, params_clk_div1__));
		}
		{
			sg::Params params_clk_div0__ = params.getParamsFor("clk_div0");
			add(clk_div0 = ClockDivider_factory->instantiate("clk_div0", simulationContext, params_clk_div0__));
		}
		{
			sg::Params params_busslave__ = params.getParamsFor("busslave");
			params_busslave__["size"] = MxU64CONST(0x0000000000001000);
			add(busslave = PVBusSlave_factory->instantiate("busslave", simulationContext, params_busslave__));
		}
		{
			sg::Params params_counter0__ = params.getParamsFor("counter0");
			counter0 = dynamic_cast<Component__CounterModule*>(CounterModule_factory->instantiate("counter0", simulationContext, params_counter0__));
			assert(counter0);
			add(counter0);
		}
		{
			sg::Params params_counter1__ = params.getParamsFor("counter1");
			counter1 = dynamic_cast<Component__CounterModule*>(CounterModule_factory->instantiate("counter1", simulationContext, params_counter1__));
			assert(counter1);
			add(counter1);
		}
		ClockDivider_factory->dereference();
		PVBusSlave_factory->dereference();
		CounterModule_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__SP804_Timer::control_port__configure, this);
    bind_method(control_port, init, &Component__SP804_Timer::init, this);
    bind_method(control_port, interconnect, &Component__SP804_Timer::interconnect, this);
//  bind_method(control_port, postConnect, &Component__SP804_Timer::postConnect, this);
    bind_method(control_port, reset, &Component__SP804_Timer::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__SP804_Timer::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__SP804_Timer::disconnect, this);
    bind_method(control_port, terminate, &Component__SP804_Timer::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__SP804_Timer::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__SP804_Timer::refresh, this);
    bind_method(control_port, step, &Component__SP804_Timer::step, this);
    bind_method(control_port, update, &Component__SP804_Timer::update, this);
    bind_method(control_port, communicate, &Component__SP804_Timer::communicate, this);
    bind_method(control_port, getProperty, &Component__SP804_Timer::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__SP804_Timer::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__SP804_Timer::control_port__bypass, this);
    bind_method(control_port, run, &Component__SP804_Timer::control_port__run, this);
    bind_method(control_port, stop, &Component__SP804_Timer::control_port__stop, this);
    bind_method(control_port, idle, &Component__SP804_Timer::control_port__idle, this);
    bind_method(control_port, quit, &Component__SP804_Timer::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__SP804_Timer::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__SP804_Timer::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__SP804_Timer::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__SP804_Timer::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__SP804_Timer::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__SP804_Timer::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__SP804_Timer::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__SP804_Timer::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_clk_div1__.connectTo(clk_div1->findPort("$control"));
	controlPort_clk_div0__.connectTo(clk_div0->findPort("$control"));
	controlPort_busslave__.connectTo(busslave->findPort("$control"));
	controlPort_counter0__.connectTo(counter0->findPort("$control"));
	controlPort_counter1__.connectTo(counter1->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(device, read, &Component__SP804_Timer::abstract_port__device__read, this);
	bind_method(device, write, &Component__SP804_Timer::abstract_port__device__write, this);
	bind_method(device, debugRead, &Component__SP804_Timer::abstract_port__device__debugRead, this);
	bind_method(device, debugWrite, &Component__SP804_Timer::abstract_port__device__debugWrite, this);


    // add abstract ports
	publishMasterPort("irq_out0", irq_out0);
	irq_out0.SetName__("irq_out0");
	publishMasterPort("irq_out1", irq_out1);
	irq_out1.SetName__("irq_out1");
	publishSlavePort("clock", clock);
	clock.SetName__("clock");
	publishSlavePortArray("timer_en", timer_en, 2);
	{for(int i = 0; i < 2; ++i) timer_en[i].SetName__("timer_en");}
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	device.SetName__("device");


    // wire up static connection map
	pvbus.connectTo(busslave->findPort("pvbus_s"));
	busslave->findPort("device").connectTo(device);
	counter0->findPort("intr_out").connectTo(irq_out0);
	counter1->findPort("intr_out").connectTo(irq_out1);
	clock.connectTo(clk_div1->findPort("clk_in"));
	clock.connectTo(clk_div0->findPort("clk_in"));
	clk_div0->findPort("clk_out").connectTo(counter0->findPort("clk_in"));
	clk_div1->findPort("clk_out").connectTo(counter1->findPort("clk_in"));
	timer_en[0].connectTo(clk_div0->findPort("rate"));
	timer_en[1].connectTo(clk_div1->findPort("rate"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__SP804_Timer::~Component__SP804_Timer()
{
}

void Component__SP804_Timer::control_port__configure(const sg::Params& params)
{
	if(controlPort_clk_div1__.configure.implemented()) controlPort_clk_div1__.configure(params.getParamsFor("clk_div1"));
	if(controlPort_clk_div0__.configure.implemented()) controlPort_clk_div0__.configure(params.getParamsFor("clk_div0"));
	if(controlPort_busslave__.configure.implemented()) controlPort_busslave__.configure(params.getParamsFor("busslave"));
	if(controlPort_counter0__.configure.implemented()) controlPort_counter0__.configure(params.getParamsFor("counter0"));
	if(controlPort_counter1__.configure.implemented()) controlPort_counter1__.configure(params.getParamsFor("counter1"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__SP804_Timer_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__SP804_Timer::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clk_div1__.populateCADIMap.implemented())
			{
				controlPort_clk_div1__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clk_div0__.populateCADIMap.implemented())
			{
				controlPort_clk_div0__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busslave__.populateCADIMap.implemented())
			{
				controlPort_busslave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("busslave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_busslave_of_PVBusSlave_to_SP804_Timer__ = new CADIParameterProxy(cadi, &parameterFilter_busslave_of_PVBusSlave_to_SP804_Timer__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_counter0__.populateCADIMap.implemented())
			{
				controlPort_counter0__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_counter1__.populateCADIMap.implemented())
			{
				controlPort_counter1__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__SP804_Timer::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__SP804_Timer::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__SP804_Timer::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__SP804_Timer::control_port__bypass(const std::string&)
{
    return "";
}


void Component__SP804_Timer::control_port__run()
{
}


void Component__SP804_Timer::control_port__stop()
{
}


void Component__SP804_Timer::control_port__idle()
{
}


void Component__SP804_Timer::control_port__quit()
{
}


void Component__SP804_Timer::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__SP804_Timer::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__SP804_Timer::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__SP804_Timer::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__SP804_Timer::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__SP804_Timer::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_busslave_of_PVBusSlave_to_SP804_Timer__;
	cadiParameterProxy_busslave_of_PVBusSlave_to_SP804_Timer__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__SP804_Timer::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__SP804_Timer::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__SP804_Timer::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__SP804_Timer::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__SP804_Timer::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__SP804_Timer::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__SP804_Timer::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__SP804_Timer::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__SP804_Timer::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__SP804_Timer::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__SP804_Timer::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__SP804_Timer::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__SP804_Timer::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__SP804_Timer::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__SP804_Timer::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__SP804_Timer::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__SP804_Timer::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__SP804_Timer::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__SP804_Timer::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__SP804_Timer::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__SP804_Timer::reset_resources__()
{
    // resource initialization code
	Timer1Load = 0; // reset register
	Timer1Value = 0; // reset register
	Timer1Control = 0; // reset register
	Timer1IntClr = 0; // reset register
	Timer1RIS = 0; // reset register
	Timer1MIS = 0; // reset register
	Timer1BGLoad = 0; // reset register
	Timer2Load = 0; // reset register
	Timer2Value = 0; // reset register
	Timer2Control = 0; // reset register
	Timer2IntClr = 0; // reset register
	Timer2RIS = 0; // reset register
	Timer2MIS = 0; // reset register
	Timer2BGLoad = 0; // reset register

}


} // FVP_VE_Cortex_A15x1_NMS
#line 82 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::reset(int level)
{
 {if(!controlPort_timer__.reset.empty()) controlPort_timer__.reset(level);};
 reload_time = 0;
 enabled = false;
 mode = MODE_FREE_RUNNING;
 ie = true;
 prescale = 0;
 timersize = 0;
 oneshot = false;
 rawinterrupt = false;
 shift = 0;
 load = 0x0;
 clocktick_counter = 0xFFFFFFFFULL;
 if (intr_out.setValue.implemented()) {
 intr_out.setValue(sg::Signal::Clear); 
 }
 
}
}

#line 104 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::setLoadRegister(uint32_t newLoadValue)
{
 load = newLoadValue;
 initTimer();
 
}
}

#line 109 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__CounterModule::getLoadRegister()
{
 return load;
 
}
}

#line 113 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__CounterModule::getControlRegister()
{
 return ( (enabled << 7)
 | ((mode == MODE_PERIODIC_RELOAD) << 6)
 | ( ie << 5)
 | ( 0 << 4)
 | ( prescale << 2)
 | ( timersize << 1)
 | ( oneshot << 0) );
 
}
}

#line 123 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::setControlRegister(uint32_t controlValue)
{
 enabled = (controlValue >> 7) & 1;
 mode = ((controlValue >> 6) & 1)? MODE_PERIODIC_RELOAD : MODE_FREE_RUNNING;
 ie = (controlValue >> 5) & 1;
 prescale = (controlValue >> 2) & 3;
 timersize = (controlValue >> 1) & 1;
 oneshot = (controlValue >> 0) & 1;

 switch (prescale) {
 case 0: shift = 0; break; 
 case 1: shift = 4; break; 
 case 2: shift = 8; break; 
 default:
 shift = 8;
 break;
 }

 initTimer();
 
}
}

#line 148 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__CounterModule::getValueRegister()
{
 uint32_t clocks_remaining = timer_control.remaining(); 
 return (uint32_t)((clocktick_counter + clocks_remaining) >> shift);
 
}
}

#line 153 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__CounterModule::getBGLoadRegister()
{
 return load;
 
}
}

#line 157 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::setBGLoadRegister(uint32_t loadValue)
{
 load = loadValue;
 
}
}

#line 164 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__CounterModule::calculateRescheduleTicks()
{
 if (clocktick_counter > 0xffffffff ) {
 return 0xffffffff;
 } else {
 return (uint32_t)clocktick_counter;
 }
 
}
}

#line 174 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::initTimer()
{

 if( load == 0){
 load = load - 1;
 }

 clocktick_counter = ((uint64_t)load) << shift; 

 uint32_t reschedule_ticks = calculateRescheduleTicks();
 if (enabled) {
 clocktick_counter -= reschedule_ticks; 
 timer_control.set(reschedule_ticks);
 } else {
 timer_control.cancel();
 }
 
}
}

#line 192 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__CounterModule::getRawIntStatus()
{
 return rawinterrupt ? 1 : 0;
 
}
}

#line 196 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__CounterModule::getMaskedIntStatus()
{
 return (rawinterrupt && ie) ? 1 : 0;
 
}
}

#line 200 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::clearInt()
{
 rawinterrupt = false;
 if (intr_out.setValue.implemented()) {
 intr_out.setValue(sg::Signal::Clear);
 }
 
}
}

#line 208 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::setInt()
{
 rawinterrupt = true;
 if (ie && intr_out.setValue.implemented()) {
 intr_out.setValue(sg::Signal::Set);
 }
 
}
}

#line 218 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__CounterModule::handleTimerSignal()
{
 
 uint32_t reschedule_ticks = 0x0;

 
 if (clocktick_counter == 0) {
 setInt(); 

 if(oneshot == true) 
 return 0;

 getClockTickCounterValue(); 
 }


 
 
 
 
 reschedule_ticks = calculateRescheduleTicks();

 clocktick_counter -= reschedule_ticks;
 return reschedule_ticks;
 
}
}

#line 245 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::getClockTickCounterValue()
{
 if (mode == MODE_PERIODIC_RELOAD) {
 clocktick_counter = ((uint64_t)load) << shift;
 } else {
 if (timersize == 0) {
 clocktick_counter = (0xFFFF << shift);
 } else {
 clocktick_counter = (0xFFFFFFFFULL << shift);
 }
 }
 
}
}

#line 259 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__CounterModule::registerRead(pv::bus_addr_t addr)
{
 switch (addr & 0xff) {
 case 0x00: return getLoadRegister();
 case 0x04: return getValueRegister();
 case 0x08: return getControlRegister();
 case 0x0c: return 0; 
 case 0x10: return getRawIntStatus();
 case 0x14: return getMaskedIntStatus();
 case 0x18: return getBGLoadRegister();
 default: return 0; 
 }
 
}
}

#line 274 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::registerWrite(pv::bus_addr_t addr, uint32_t data)
{
 switch (addr & 0xff) {
 case 0x00: setLoadRegister(data); break;
 case 0x04: return; 
 case 0x08: setControlRegister(data); break;
 case 0x0c: clearInt();
 case 0x10: return; 
 case 0x14: return; 
 case 0x18: setBGLoadRegister(data); break;
 default: return; 
 }
 
}
}

#line 289 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::init()
{
 clocktick_counter = 0xFFFFFFFFULL;
 ie = 1;
 {if(!controlPort_timer__.init.empty()) controlPort_timer__.init();};
 
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::interconnect()
{{if(!controlPort_timer__.interconnect.empty()) controlPort_timer__.interconnect();};
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::disconnect()
{{if(!controlPort_timer__.disconnect.empty()) controlPort_timer__.disconnect();};
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::update()
{{if(!controlPort_timer__.update.empty()) controlPort_timer__.update();};
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::communicate()
{{if(!controlPort_timer__.communicate.empty()) controlPort_timer__.communicate();};
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::traceEndOfCycle()
{{if(!controlPort_timer__.traceEndOfCycle.empty()) controlPort_timer__.traceEndOfCycle();};
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::loadApplicationFile(const std::string& filename)
{{if(!controlPort_timer__.loadApplicationFile.empty()) controlPort_timer__.loadApplicationFile(filename);};
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::terminate()
{{if(!controlPort_timer__.terminate.empty()) controlPort_timer__.terminate();};
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__CounterModule::save(MxODataStream& os)
{{if(!controlPort_timer__.save.empty()) controlPort_timer__.save(os);};return true;
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__CounterModule::restore(MxIDataStream& is)
{{if(!controlPort_timer__.restore.empty()) controlPort_timer__.restore(is);};return true;
}
}

#line 20 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__CounterModule::step()
{{if(!controlPort_timer__.step.empty()) controlPort_timer__.step();};
}
}

#line 76 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/CounterModule.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__CounterModule::abstract_port__timer_callback_handler__signal()
{
 return handleTimerSignal();
 
}
}

#line 11641 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__CounterModule
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__CounterModule::Component__CounterModule(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)




{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Other";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Internal component used by SP804 Timer module";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "1";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = CounterModule_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		{
			sg::Params params_timer__ = params.getParamsFor("timer");
			add(timer = ClockTimer_factory->instantiate("timer", simulationContext, params_timer__));
		}
		ClockTimer_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__CounterModule::control_port__configure, this);
    bind_method(control_port, init, &Component__CounterModule::init, this);
    bind_method(control_port, interconnect, &Component__CounterModule::interconnect, this);
//  bind_method(control_port, postConnect, &Component__CounterModule::postConnect, this);
    bind_method(control_port, reset, &Component__CounterModule::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__CounterModule::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__CounterModule::disconnect, this);
    bind_method(control_port, terminate, &Component__CounterModule::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__CounterModule::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__CounterModule::refresh, this);
    bind_method(control_port, step, &Component__CounterModule::step, this);
    bind_method(control_port, update, &Component__CounterModule::update, this);
    bind_method(control_port, communicate, &Component__CounterModule::communicate, this);
    bind_method(control_port, getProperty, &Component__CounterModule::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__CounterModule::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__CounterModule::control_port__bypass, this);
    bind_method(control_port, run, &Component__CounterModule::control_port__run, this);
    bind_method(control_port, stop, &Component__CounterModule::control_port__stop, this);
    bind_method(control_port, idle, &Component__CounterModule::control_port__idle, this);
    bind_method(control_port, quit, &Component__CounterModule::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__CounterModule::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__CounterModule::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__CounterModule::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__CounterModule::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__CounterModule::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__CounterModule::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__CounterModule::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__CounterModule::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_timer__.connectTo(timer->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(timer_callback_handler, signal, &Component__CounterModule::abstract_port__timer_callback_handler__signal, this);


    // add abstract ports
	publishMasterPort("intr_out", intr_out);
	intr_out.SetName__("intr_out");
	publishSlavePort("clk_in", clk_in);
	clk_in.SetName__("clk_in");
	publishMasterPort("timer_control", timer_control);
	timer_control.SetName__("timer_control");
	publishSlavePort("timer_callback_handler", timer_callback_handler);
	timer_callback_handler.SetName__("timer_callback_handler");


    // wire up static connection map
	clk_in.connectTo(timer->findPort("clk_in"));
	timer_control.connectTo(timer->findPort("timer_control"));
	timer->findPort("timer_callback").connectTo(timer_callback_handler);


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__CounterModule::~Component__CounterModule()
{
}

void Component__CounterModule::control_port__configure(const sg::Params& params)
{
	if(controlPort_timer__.configure.implemented()) controlPort_timer__.configure(params.getParamsFor("timer"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__CounterModule_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__CounterModule::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_timer__.populateCADIMap.implemented())
			{
				controlPort_timer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__CounterModule::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__CounterModule::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__CounterModule::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__CounterModule::control_port__bypass(const std::string&)
{
    return "";
}


void Component__CounterModule::control_port__run()
{
}


void Component__CounterModule::control_port__stop()
{
}


void Component__CounterModule::control_port__idle()
{
}


void Component__CounterModule::control_port__quit()
{
}


void Component__CounterModule::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__CounterModule::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__CounterModule::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__CounterModule::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__CounterModule::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__CounterModule::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__CounterModule::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__CounterModule::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__CounterModule::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__CounterModule::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__CounterModule::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__CounterModule::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__CounterModule::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__CounterModule::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__CounterModule::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__CounterModule::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__CounterModule::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__CounterModule::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__CounterModule::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__CounterModule::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__CounterModule::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__CounterModule::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__CounterModule::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__CounterModule::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__CounterModule::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__CounterModule::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__CounterModule::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 22 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::init()
{
 audioBuf = NULL;
 
}
}

#line 27 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::terminate()
{
 if(audioBuf != NULL)
 {
 delete audioBuf;
 }
 
}
}

#line 36 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::reset(int level)
{
 
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::interconnect()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::disconnect()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::update()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::communicate()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::traceEndOfCycle()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::loadApplicationFile(const std::string& filename)
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__AudioOut_SDL::save(MxODataStream& os)
{;return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__AudioOut_SDL::restore(MxIDataStream& is)
{;return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::step()
{;
}
}

#line 48 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { PVAudioBuffer* 
Component__AudioOut_SDL::abstract_port__audio__getPVAudioBuffer(uint32_t depth)
{
 audioBuf = new PVSdlAudioBuffer(depth);

 return audioBuf;
 
}
}

#line 55 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/AudioOut_SDL.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__AudioOut_SDL::abstract_port__audio__releasePVAudioBuffer(PVAudioBuffer* buf)
{
 if(audioBuf != NULL)
 {
 delete audioBuf;
 audioBuf = NULL;
 }
 
}
}

#line 12300 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__AudioOut_SDL
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__AudioOut_SDL::Component__AudioOut_SDL(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)




{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Other";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "SDL based Audio Output for PL041_AACI.";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = AudioOut_SDL_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__AudioOut_SDL::control_port__configure, this);
    bind_method(control_port, init, &Component__AudioOut_SDL::init, this);
    bind_method(control_port, interconnect, &Component__AudioOut_SDL::interconnect, this);
//  bind_method(control_port, postConnect, &Component__AudioOut_SDL::postConnect, this);
    bind_method(control_port, reset, &Component__AudioOut_SDL::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__AudioOut_SDL::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__AudioOut_SDL::disconnect, this);
    bind_method(control_port, terminate, &Component__AudioOut_SDL::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__AudioOut_SDL::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__AudioOut_SDL::refresh, this);
    bind_method(control_port, step, &Component__AudioOut_SDL::step, this);
    bind_method(control_port, update, &Component__AudioOut_SDL::update, this);
    bind_method(control_port, communicate, &Component__AudioOut_SDL::communicate, this);
    bind_method(control_port, getProperty, &Component__AudioOut_SDL::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__AudioOut_SDL::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__AudioOut_SDL::control_port__bypass, this);
    bind_method(control_port, run, &Component__AudioOut_SDL::control_port__run, this);
    bind_method(control_port, stop, &Component__AudioOut_SDL::control_port__stop, this);
    bind_method(control_port, idle, &Component__AudioOut_SDL::control_port__idle, this);
    bind_method(control_port, quit, &Component__AudioOut_SDL::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__AudioOut_SDL::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__AudioOut_SDL::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__AudioOut_SDL::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__AudioOut_SDL::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__AudioOut_SDL::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__AudioOut_SDL::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__AudioOut_SDL::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__AudioOut_SDL::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(audio, getPVAudioBuffer, &Component__AudioOut_SDL::abstract_port__audio__getPVAudioBuffer, this);
	bind_method(audio, releasePVAudioBuffer, &Component__AudioOut_SDL::abstract_port__audio__releasePVAudioBuffer, this);


    // add abstract ports
	publishSlavePort("audio", audio);
	audio.SetName__("audio");


    // wire up static connection map


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__AudioOut_SDL::~Component__AudioOut_SDL()
{
}

void Component__AudioOut_SDL::control_port__configure(const sg::Params& params)
{


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__AudioOut_SDL_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__AudioOut_SDL::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";


    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__AudioOut_SDL::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__AudioOut_SDL::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__AudioOut_SDL::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__AudioOut_SDL::control_port__bypass(const std::string&)
{
    return "";
}


void Component__AudioOut_SDL::control_port__run()
{
}


void Component__AudioOut_SDL::control_port__stop()
{
}


void Component__AudioOut_SDL::control_port__idle()
{
}


void Component__AudioOut_SDL::control_port__quit()
{
}


void Component__AudioOut_SDL::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__AudioOut_SDL::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__AudioOut_SDL::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__AudioOut_SDL::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__AudioOut_SDL::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__AudioOut_SDL::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__AudioOut_SDL::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__AudioOut_SDL::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__AudioOut_SDL::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__AudioOut_SDL::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__AudioOut_SDL::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__AudioOut_SDL::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__AudioOut_SDL::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__AudioOut_SDL::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__AudioOut_SDL::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__AudioOut_SDL::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__AudioOut_SDL::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__AudioOut_SDL::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__AudioOut_SDL::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__AudioOut_SDL::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__AudioOut_SDL::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__AudioOut_SDL::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__AudioOut_SDL::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__AudioOut_SDL::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__AudioOut_SDL::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__AudioOut_SDL::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__AudioOut_SDL::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::interconnect()
{{if(!controlPort_bus_slave__.interconnect.empty()) controlPort_bus_slave__.interconnect();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::disconnect()
{{if(!controlPort_bus_slave__.disconnect.empty()) controlPort_bus_slave__.disconnect();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::update()
{{if(!controlPort_bus_slave__.update.empty()) controlPort_bus_slave__.update();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::communicate()
{{if(!controlPort_bus_slave__.communicate.empty()) controlPort_bus_slave__.communicate();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::traceEndOfCycle()
{{if(!controlPort_bus_slave__.traceEndOfCycle.empty()) controlPort_bus_slave__.traceEndOfCycle();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::loadApplicationFile(const std::string& filename)
{{if(!controlPort_bus_slave__.loadApplicationFile.empty()) controlPort_bus_slave__.loadApplicationFile(filename);};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::init()
{{if(!controlPort_bus_slave__.init.empty()) controlPort_bus_slave__.init();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::terminate()
{{if(!controlPort_bus_slave__.terminate.empty()) controlPort_bus_slave__.terminate();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::reset(int level)
{{if(!controlPort_bus_slave__.reset.empty()) controlPort_bus_slave__.reset(level);};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VE_CompactFlash::save(MxODataStream& os)
{{if(!controlPort_bus_slave__.save.empty()) controlPort_bus_slave__.save(os);};return true;
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__VE_CompactFlash::restore(MxIDataStream& is)
{{if(!controlPort_bus_slave__.restore.empty()) controlPort_bus_slave__.restore(is);};return true;
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__VE_CompactFlash::step()
{{if(!controlPort_bus_slave__.step.empty()) controlPort_bus_slave__.step();};
}
}

#line 33 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__VE_CompactFlash::abstract_port__device__read(pv::ReadTransaction tx)
{
 return tx.setReturnData32(0xffffffff);
 
}
}

#line 38 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__VE_CompactFlash::abstract_port__device__write(pv::WriteTransaction tx)
{
 return tx.writeComplete();
 
}
}

#line 43 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__VE_CompactFlash::abstract_port__device__debugRead(pv::ReadTransaction tx)
{
 return device.read(tx);
 
}
}

#line 48 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/examples/FVP_VE/LISA/VE_CompactFlash.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__VE_CompactFlash::abstract_port__device__debugWrite(pv::WriteTransaction tx)
{
 return device.write(tx);
 
}
}

#line 12948 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__VE_CompactFlash
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__VE_CompactFlash::Component__VE_CompactFlash(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)



	,cadiParameterProxy_bus_slave_of_PVBusSlave_to_VE_CompactFlash__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "";
	properties__["documentation_file"] = "";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = VE_CompactFlash_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_bus_slave__ = params.getParamsFor("bus_slave");
			params_bus_slave__["size"] = MxU64CONST(0x0000000000001000);
			add(bus_slave = PVBusSlave_factory->instantiate("bus_slave", simulationContext, params_bus_slave__));
		}
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__VE_CompactFlash::control_port__configure, this);
    bind_method(control_port, init, &Component__VE_CompactFlash::init, this);
    bind_method(control_port, interconnect, &Component__VE_CompactFlash::interconnect, this);
//  bind_method(control_port, postConnect, &Component__VE_CompactFlash::postConnect, this);
    bind_method(control_port, reset, &Component__VE_CompactFlash::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__VE_CompactFlash::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__VE_CompactFlash::disconnect, this);
    bind_method(control_port, terminate, &Component__VE_CompactFlash::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__VE_CompactFlash::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__VE_CompactFlash::refresh, this);
    bind_method(control_port, step, &Component__VE_CompactFlash::step, this);
    bind_method(control_port, update, &Component__VE_CompactFlash::update, this);
    bind_method(control_port, communicate, &Component__VE_CompactFlash::communicate, this);
    bind_method(control_port, getProperty, &Component__VE_CompactFlash::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__VE_CompactFlash::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__VE_CompactFlash::control_port__bypass, this);
    bind_method(control_port, run, &Component__VE_CompactFlash::control_port__run, this);
    bind_method(control_port, stop, &Component__VE_CompactFlash::control_port__stop, this);
    bind_method(control_port, idle, &Component__VE_CompactFlash::control_port__idle, this);
    bind_method(control_port, quit, &Component__VE_CompactFlash::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__VE_CompactFlash::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__VE_CompactFlash::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__VE_CompactFlash::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__VE_CompactFlash::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__VE_CompactFlash::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__VE_CompactFlash::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__VE_CompactFlash::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__VE_CompactFlash::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_bus_slave__.connectTo(bus_slave->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(device, read, &Component__VE_CompactFlash::abstract_port__device__read, this);
	bind_method(device, write, &Component__VE_CompactFlash::abstract_port__device__write, this);
	bind_method(device, debugRead, &Component__VE_CompactFlash::abstract_port__device__debugRead, this);
	bind_method(device, debugWrite, &Component__VE_CompactFlash::abstract_port__device__debugWrite, this);


    // add abstract ports
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	device.SetName__("device");


    // wire up static connection map
	pvbus.connectTo(bus_slave->findPort("pvbus_s"));
	bus_slave->findPort("device").connectTo(device);


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__VE_CompactFlash::~Component__VE_CompactFlash()
{
}

void Component__VE_CompactFlash::control_port__configure(const sg::Params& params)
{
	if(controlPort_bus_slave__.configure.implemented()) controlPort_bus_slave__.configure(params.getParamsFor("bus_slave"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__VE_CompactFlash_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__VE_CompactFlash::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_bus_slave__.populateCADIMap.implemented())
			{
				controlPort_bus_slave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("bus_slave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_bus_slave_of_PVBusSlave_to_VE_CompactFlash__ = new CADIParameterProxy(cadi, &parameterFilter_bus_slave_of_PVBusSlave_to_VE_CompactFlash__);
			}
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__VE_CompactFlash::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__VE_CompactFlash::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__VE_CompactFlash::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__VE_CompactFlash::control_port__bypass(const std::string&)
{
    return "";
}


void Component__VE_CompactFlash::control_port__run()
{
}


void Component__VE_CompactFlash::control_port__stop()
{
}


void Component__VE_CompactFlash::control_port__idle()
{
}


void Component__VE_CompactFlash::control_port__quit()
{
}


void Component__VE_CompactFlash::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__VE_CompactFlash::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__VE_CompactFlash::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__VE_CompactFlash::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__VE_CompactFlash::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__VE_CompactFlash::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_bus_slave_of_PVBusSlave_to_VE_CompactFlash__;
	cadiParameterProxy_bus_slave_of_PVBusSlave_to_VE_CompactFlash__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__VE_CompactFlash::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__VE_CompactFlash::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__VE_CompactFlash::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__VE_CompactFlash::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__VE_CompactFlash::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VE_CompactFlash::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VE_CompactFlash::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VE_CompactFlash::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__VE_CompactFlash::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__VE_CompactFlash::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__VE_CompactFlash::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__VE_CompactFlash::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__VE_CompactFlash::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__VE_CompactFlash::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__VE_CompactFlash::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__VE_CompactFlash::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__VE_CompactFlash::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__VE_CompactFlash::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__VE_CompactFlash::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__VE_CompactFlash::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__VE_CompactFlash::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 37 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::init()
{
 if (userNetworking) {
 vt = sg::createVEPUserNetDevice(getSimulationContext(), userNetSubnet, userNetPorts, eth.getAbstractInterface()); 
 } else {
 vt = sg::createVEPTunDevice(getSimulationContext(), interfaceName, eth.getAbstractInterface()); 
 }
 if(!vt->init()) {
 
 delete vt;
 vt = NULL;
 }
 
}
}

#line 50 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::terminate()
{
 if(vt != NULL)
 delete vt;
 
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::interconnect()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::disconnect()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::update()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::communicate()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::traceEndOfCycle()
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::loadApplicationFile(const std::string& filename)
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::reset(int level)
{;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__HostBridge::save(MxODataStream& os)
{;return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__HostBridge::restore(MxIDataStream& is)
{;return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::step()
{;
}
}

#line 58 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/HostBridge.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__HostBridge::abstract_port__eth__sendToMaster(EthernetFrame* frame)
{
 if(vt != NULL) {
 if(!vt->doWrite(frame->buf, frame->buflen)) {
 if (!0) ; else fprintf(stderr, "Write ethernet frame to TAP device failed\n");
 }
 } 
 
}
}

#line 13617 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__HostBridge
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__HostBridge::Component__HostBridge(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,interfaceName(GetParameterValue(params, "interfaceName", "ARM0"))
	,userNetworking(!!GetParameterValue(params, "userNetworking", MxS64CONST(0x0), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,userNetSubnet(GetParameterValue(params, "userNetSubnet", "172.20.51.0/24"))
	,userNetPorts(GetParameterValue(params, "userNetPorts", ""))



{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Host Socket Interface Component";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = HostBridge_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__HostBridge::control_port__configure, this);
    bind_method(control_port, init, &Component__HostBridge::init, this);
    bind_method(control_port, interconnect, &Component__HostBridge::interconnect, this);
//  bind_method(control_port, postConnect, &Component__HostBridge::postConnect, this);
    bind_method(control_port, reset, &Component__HostBridge::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__HostBridge::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__HostBridge::disconnect, this);
    bind_method(control_port, terminate, &Component__HostBridge::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__HostBridge::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__HostBridge::refresh, this);
    bind_method(control_port, step, &Component__HostBridge::step, this);
    bind_method(control_port, update, &Component__HostBridge::update, this);
    bind_method(control_port, communicate, &Component__HostBridge::communicate, this);
    bind_method(control_port, getProperty, &Component__HostBridge::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__HostBridge::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__HostBridge::control_port__bypass, this);
    bind_method(control_port, run, &Component__HostBridge::control_port__run, this);
    bind_method(control_port, stop, &Component__HostBridge::control_port__stop, this);
    bind_method(control_port, idle, &Component__HostBridge::control_port__idle, this);
    bind_method(control_port, quit, &Component__HostBridge::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__HostBridge::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__HostBridge::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__HostBridge::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__HostBridge::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__HostBridge::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__HostBridge::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__HostBridge::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__HostBridge::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(eth, sendToMaster, &Component__HostBridge::abstract_port__eth__sendToMaster, this);


    // add abstract ports
	publishMasterPort("eth", eth);
	eth.SetName__("eth");


    // wire up static connection map


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__HostBridge::~Component__HostBridge()
{
}

void Component__HostBridge::control_port__configure(const sg::Params& params)
{


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__HostBridge_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__HostBridge::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";


    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__HostBridge::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__HostBridge::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__HostBridge::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__HostBridge::control_port__bypass(const std::string&)
{
    return "";
}


void Component__HostBridge::control_port__run()
{
}


void Component__HostBridge::control_port__stop()
{
}


void Component__HostBridge::control_port__idle()
{
}


void Component__HostBridge::control_port__quit()
{
}


void Component__HostBridge::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__HostBridge::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__HostBridge::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__HostBridge::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__HostBridge::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__HostBridge::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__HostBridge::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__HostBridge::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__HostBridge::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__HostBridge::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_userNetworking: *data = userNetworking; break;

        default:
            printf("error: Component__HostBridge::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__HostBridge::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {
	case PARAMETER_ID_interfaceName:  data = interfaceName; break;
	case PARAMETER_ID_userNetSubnet:  data = userNetSubnet; break;
	case PARAMETER_ID_userNetPorts:  data = userNetPorts; break;

        default:
            printf("error: Component__HostBridge::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__HostBridge::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_userNetworking:
		{
			*(const_cast<bool*>(&userNetworking)) = !!*data;
		}
		break;

        default:
            printf("error: Component__HostBridge::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__HostBridge::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {
	case PARAMETER_ID_interfaceName:
		{
			*(const_cast<std::string*>(&interfaceName)) = data;
		}
		break;
	case PARAMETER_ID_userNetSubnet:
		{
			*(const_cast<std::string*>(&userNetSubnet)) = data;
		}
		break;
	case PARAMETER_ID_userNetPorts:
		{
			*(const_cast<std::string*>(&userNetPorts)) = data;
		}
		break;

        default:
            printf("error: Component__HostBridge::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__HostBridge::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__HostBridge::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__HostBridge::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__HostBridge::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__HostBridge::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__HostBridge::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__HostBridge::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__HostBridge::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__HostBridge::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "interfaceName") id = PARAMETER_ID_interfaceName;
    if (name == "userNetworking") id = PARAMETER_ID_userNetworking;
    if (name == "userNetSubnet") id = PARAMETER_ID_userNetSubnet;
    if (name == "userNetPorts") id = PARAMETER_ID_userNetPorts;

    return id;
}

void Component__HostBridge::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 337 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::CheckForBackingStoreError()
{
 int32_t err = mmc_store->getLastError();
 if (err)
 {
 message((err > 0) ? MSG_INFO : MSG_WARNING
 , "%s: %s\n", getInstanceName().c_str(), mmc_store->getLastErrorMessage());
 }

}
}

#line 349 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::init()
{
 {if(!controlPort_timer__.init.empty()) controlPort_timer__.init();};
 mmc_store = new BackingStore(p_mmc_file.c_str(), getInstanceName().c_str());
 if (!mmc_store)
 {
 message(MSG_WARNING, "%s: MMC backingstore could not be instantiated.\n"
 , getInstanceName().c_str());
 }
 else
 {
 CheckForBackingStoreError();
 }

 if (!get_capacity(NULL, NULL))
 {
 
 delete mmc_store;
 mmc_store = NULL;
 }
 common_reset();
 
 if (card_present.setValue.implemented())
 card_present.setValue(mmc_store ? sg::Signal::Set : sg::Signal::Clear);

 if (is_write_protected())
 {
 message(MSG_INFO, "%s: write protected card.\n", getInstanceName().c_str());
 }

}
}

#line 380 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::terminate()
{
 if (mmc_store)
 {
 delete mmc_store;
 }
 {if(!controlPort_timer__.terminate.empty()) controlPort_timer__.terminate();};

}
}

#line 390 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::reset(int level)
{
 {if(!controlPort_timer__.reset.empty()) controlPort_timer__.reset(level);};
 common_reset();

}
}

#line 396 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::common_reset()
{
 cstate = MMCS_IDLE;
 OCR_REG = 0x00ffff80 ; 

 BLOCKLEN_REG = DEFAULT_BLOCKLEN;
 BLOCK_COUNT_REG = DEFAULT_BLOCKCOUNT;

 uint32_t cxd[4];
 init_csd_r(&cxd[0]);
 update_csd(&cxd[0]);

 init_cid_r(&cxd[0]);
 update_cid(&cxd[0]);

 reset_transfer();
 if (!0) ; else printf("%s:%d %s() reset_transfer() due to common_reset\n"
 , __FILE__, __LINE__, __FUNCTION__);

}
}

#line 416 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::reset_transfer()
{
 if (!0) ; else printf("%s:%d %s() \n", __FILE__, __LINE__, __FUNCTION__);
 multiple_blocks = 0;
 data_pointer = NULL;
 block_address = 0;

 stop_timer();

}
}

#line 513 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::advance_writeToCard_state()
{
 
 assert(multiple_blocks);

 block_address += BLOCKLEN_REG;
 if (!0) ; else printf("%s:%d %s() multiple_blocks=%d block_address=0x%08X\n"
 , __FILE__, __LINE__, __FUNCTION__, multiple_blocks, block_address);

 
 if (check_address(block_address))
 {
 multiple_blocks--;
 
 dumpBlock(block_address, BLOCKLEN_REG, data_pointer);

 
 mmc_store->accessBlock(block_address, BLOCKLEN_REG, &data_pointer);
 if (!0) ; else printf("%s:%d %s() next block at %p multiple_blocks=%d now\n"
 , __FILE__, __LINE__, __FUNCTION__, data_pointer, multiple_blocks);
 
 mmc.Tx(data_pointer, BLOCKLEN_REG);
 }
 else
 {
 message(MSG_WARNING, "%s: Forcing state back from RECEIVE -> TRANSFER (addr=0x%08x).\n"
 , getInstanceName().c_str(), block_address);
 stop_timer();
 cstate = MMCS_TRANSFER;
 }

}
}

#line 545 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::flushWriteBlock()
{
 if (!0) ; else printf("%s:%d %s() flushing block at %p multiple_blocks=%d now (actually doing nothing except dump)\n"
 , __FILE__, __LINE__, __FUNCTION__, data_pointer, multiple_blocks);
 dumpBlock(block_address, BLOCKLEN_REG, data_pointer);

}
}

#line 552 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::dumpBlock(uint32_t adr, uint32_t len, uint8_t* p)
{
 uint32_t bytesPerLine = 32;
 uint32_t lines;
 uint32_t i, l;
 lines = len / bytesPerLine; 

 for (l = 0; l < lines; l++)
 {
 if (!0) ; else printf("%08X : ", adr + l * bytesPerLine);
 for (i = 0; i < bytesPerLine; i++)
 {
 if (!0) ; else printf("%02X ", p[l*bytesPerLine + i]);
 }
 if (!0) ; else printf("\n");
 }

}
}

#line 570 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::advance_readFromCard_state()
{
 
 
 
 mmc_store->accessBlock(block_address, BLOCKLEN_REG, &data_pointer);
 CheckForBackingStoreError();
 if (!0) ; else printf("%s:%d %s() multiple_blocks=%d block_address=0x%08X, calling Rx() now\n"
 , __FILE__, __LINE__, __FUNCTION__
 , multiple_blocks, block_address);
 
 dumpBlock(block_address, BLOCKLEN_REG, data_pointer);
 
 mmc.Rx(data_pointer, BLOCKLEN_REG); 

}
}

#line 586 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__MMC::check_address(uint32_t blk_addr)
{
 if (!mmc_store)
 {
 STATUS_REG |= (1 << 31);
 if (!0) ; else printf("%s: The card was not initialized - returning OUT_OF_RANGE.\n"
 , getInstanceName().c_str());
 return false;
 }

 if (blk_addr & (BLOCKLEN_REG-1))
 {
 STATUS_REG |= (1 << 30);
 if (!0) ; else printf("%s: arg(0x%08x) isn't aligned to a block (0x0%x)\n"
 , getInstanceName().c_str(), block_address, BLOCKLEN_REG);
 return false;
 }

 if ((blk_addr + BLOCKLEN_REG) > mmc_capacity)
 {
 STATUS_REG |= (1 << 31);
 if (!0) ; else printf("%s: arg(0x%08x) ends past the end of the card (%"PRId64")\n"
 , getInstanceName().c_str(), block_address, mmc_capacity);
 return false;
 }
 return true;

}
}

#line 647 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { mmc_resp_t 
Component__MMC::doCommand(mmc_cmd_t cmd, uint32_t arg, void* resp)
{
 old_state = cstate; 

 switch (cmd)
 {
 
 case MMC_GO_IDLE_STATE: 
 {
 reset_transfer(); 
 cstate = MMCS_IDLE;
 return MMC_RNONE;
 }
 case MMC_SEND_OP_COND: 
 {
 cstate_change(MMCS_IDLE, MMCS_READY, cmd, true);
 
 
 
 
 arg &= ~(1<<31); 
 ((mmc_ocr_resp_t *)resp)[0] = (OCR_REG) |
 (is_ready() << 31);
 return MMC_R32;
 }
 case MMC_ALL_SEND_CID: 
 {
 cstate_change(MMCS_READY, MMCS_ID, cmd, true);
 
 mmc_cxd_resp_t *cid_resp = (mmc_cxd_resp_t *)resp;
 cid_resp->cxd[0] = CID_REG0;
 cid_resp->cxd[1] = CID_REG1;
 cid_resp->cxd[2] = CID_REG2;
 cid_resp->cxd[3] = CID_REG3;
 return MMC_R128;
 }
 case MMC_SET_RELATIVE_ADDR: 
 {
 RCA_REG = (arg >> 16);
 
 cstate_change(MMCS_ID, MMCS_STANDBY, cmd, true);
 mmc_update_status((mmc_status_t *)resp);

 
 *((uint32_t *)resp) = RCA_REG << 16;
 return MMC_R32;
 }
 case MMC_SET_DSR: 
 {
 DSR_REG = arg >> 16;
 return MMC_RNONE;
 }
 case MMC_SWITCH: 
 {
 
 
 
 
 

 
 return MMC_R32;
 }
 case MMC_SELDESL_CARD: 
 {
 
 

 if ((arg >> 16) == RCA_REG)
 {
 if (!0) ; else printf("%s: Card SELECTED: returning status\n",
 getInstanceName().c_str());
 
 cstate_change(MMCS_STANDBY,
 MMCS_TRANSFER, cmd, true);
 
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }

 if (!0) ; else printf("%s: Card deselected: no need to return status\n",
 getInstanceName().c_str());
 
 cstate_change(MMCS_TRANSFER,
 MMCS_STANDBY, cmd, true);
 
 return MMC_RNONE;
 }
 case MMC_SEND_EXT_CSD: 
 {
 
 
 
 
 if (!0) ; else printf("%s: SEND_EXT_CSD unimplemented by this card.\n",
 getInstanceName().c_str());
 STATUS_REG |= (1 << 22);
 return MMC_RERROR;
 }
 case MMC_SEND_CSD: 
 { 
 cstate_change(MMCS_STANDBY, MMCS_STANDBY, cmd, true);

 mmc_cxd_resp_t *csd_resp = (mmc_cxd_resp_t *)resp;
 csd_resp->cxd[0] = CSD_REG0;
 csd_resp->cxd[1] = CSD_REG1;
 csd_resp->cxd[2] = CSD_REG2;
 csd_resp->cxd[3] = CSD_REG3;
 return MMC_R128;
 }
 case MMC_SEND_CID: 
 { 
 cstate_change(MMCS_STANDBY, MMCS_STANDBY, cmd, true);
 mmc_cxd_resp_t *cid_resp = (mmc_cxd_resp_t *)resp;
 cid_resp->cxd[0] = CID_REG0;
 cid_resp->cxd[1] = CID_REG1;
 cid_resp->cxd[2] = CID_REG2;
 cid_resp->cxd[3] = CID_REG3;
 return MMC_R128;
 }
 case MMC_STOP_TRANSMISSION: 
 {
 
 
 if (!0) ; else printf("%s:%d %s() MMC_STOP_TRANSMISSION\n", __FILE__, __LINE__, __FUNCTION__);

 stop_timer();

 multiple_blocks = 0;
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }
 case MMC_SEND_STATUS: 
 {
 if ((arg >> 16) == RCA_REG)
 {
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }
 if (!0) ; else printf("%s: SEND_STATUS(%04x) didn't match RCA(%04x)\n",
 getInstanceName().c_str(), (arg >> 16), RCA_REG);
 return MMC_RNONE;
 }
 case MMC_BUSTEST_R: 
 case MMC_BUSTEST_W: 
 {
 STATUS_REG |= (1 << 22);
 if (!0) ; else printf("%s: BUSTEST commands unimplemented\n",
 getInstanceName().c_str());
 return MMC_RNONE;
 }
 case MMC_GO_INACTIVE_STATE: 
 {
 
 
 cstate = MMCS_DISABLED;
 return MMC_RNONE;
 }
 
 case MMC_SET_BLOCKLEN: 
 {
 
 
 if ((arg & 0xffff) != BLOCKLEN_REG)
 {
 if (!0) ; else printf("%s: 0x%04x didn't match our BLOCKLEN (0x%04x)\n",
 getInstanceName().c_str(), (arg & 0xffff), BLOCKLEN_REG);

 STATUS_REG |= (1 << 29);
 }
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }
 case MMC_READ_SINGLE_BLOCK: 
 {
 reset_transfer();
 multiple_blocks = 0;
 return(start_rblock(cmd, arg, resp));
 }
 case MMC_READ_MULTIPLE_BLOCK: 
 {
 reset_transfer();
 multiple_blocks = BLOCK_COUNT_REG;

 if (!0) ; else printf("%s:%d %s() multiple_blocks=%d\n"
 , __FILE__, __LINE__, __FUNCTION__, multiple_blocks);
 return(start_rblock(cmd, arg, resp));
 }
 
 case MMC_READ_DAT_UNTIL_STOP: 
 case MMC_WRITE_DAT_UNTIL_STOP: 
 {
 if (!0) ; else printf("%s: Streaming commands not supported\n",
 getInstanceName().c_str());
 STATUS_REG |= (1 << 22);
 return MMC_RNONE;
 }
 
 case MMC_SET_BLOCK_COUNT: 
 {
 if (!0) ; else printf("%s: SET_BLOCK_COUNT command (%d, 0x%08x)\n",
 getInstanceName().c_str(), cmd, arg);
 
 arg &= 0xffff;
 
 BLOCK_COUNT_REG = arg > 0 ? arg - 1 : 0;
 if (!0) ; else printf("%s:%d %s() BLOCK_COUNT_REG=%d\n", __FILE__, __LINE__, __FUNCTION__, BLOCK_COUNT_REG);
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }
 case MMC_WRITE_BLOCK: 
 {
 reset_transfer();
 multiple_blocks = 0;
 return(start_wblock(cmd, arg, resp));
 }
 case MMC_WRITE_MULTIPLE_BLOCK: 
 {
 reset_transfer();
 multiple_blocks = BLOCK_COUNT_REG;
 if (!0) ; else printf("%s:%d %s() multiple_blocks=%d\n", __FILE__, __LINE__, __FUNCTION__, multiple_blocks);
 return(start_wblock(cmd, arg, resp));
 }
 case MMC_PROGRAM_CID: 
 {
 }
 case MMC_PROGRAM_CSD: 
 {
 }

 
 case MMC_SET_WRITE_PROT: 
 case MMC_CLR_WRITE_PROT: 
 case MMC_SEND_WRITE_PROT: 
 {
 if (!0) ; else printf("%s: WRITE_PROT commands not supported (%d, 0x%08x)\n",
 getInstanceName().c_str(), cmd, arg);
 STATUS_REG |= (1 << 22);
 return MMC_RNONE;
 }

 
 
 
 case MMC_ERASE_GROUP_START: 
 {
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }
 case MMC_ERASE_GROUP_END: 
 {
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }
 case MMC_ERASE: 
 {
 if (is_write_protected())
 {
 if (!0) ; else printf("%s: write protected card\n",
 getInstanceName().c_str());
 STATUS_REG |= (1 << 15);
 }
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }
 
 case MMC_FAST_IO: 
 case MMC_GO_IRQ_STATE: 
 {
 if (!0) ; else printf("%s: IO command not supported (%d, 0x%08x)\n",
 getInstanceName().c_str(), cmd, arg);
 STATUS_REG |= (1 << 22);
 return MMC_RERROR;
 }
 
 case MMC_LOCK_UNLOCK: 
 {
 
 return MMC_R32;
 }
 
 case MMC_APP_CMD: 
 
 *((uint32_t *)resp) = 0;
 return MMC_R32;
 case MMC_GEN_CMD: 
 {
 if (!0) ; else printf("%s: Application specific command not supported (%d, 0x%08x)\n",
 getInstanceName().c_str(), cmd, arg);
 STATUS_REG |= (1 << 22);
 return MMC_RERROR;
 }
 case MMC_CMD41: 
 
 *((uint32_t *)resp) = 0x80000000;
 return MMC_R32;

 case MMC_CMD5: 
 case MMC_CMD21: 
 case MMC_CMD22:
 case MMC_CMD31: 
 case MMC_CMD43: 
 case MMC_CMD44:
 case MMC_CMD45:
 case MMC_CMD46:
 case MMC_CMD47:
 case MMC_CMD48:
 case MMC_CMD49:
 case MMC_CMD50:
 case MMC_CMD51:
 case MMC_CMD52:
 case MMC_CMD53:
 case MMC_CMD54:
 case MMC_CMD57: 
 case MMC_CMD58:
 case MMC_CMD59:
 if (!0) ; else printf("%s: reserved MMC command %d (0x%08x)\n",
 getInstanceName().c_str(), cmd, arg);
 STATUS_REG |= (1 << 22);
 return MMC_RERROR;
 case MMC_CMD32: 
 case MMC_CMD33:
 
 return MMC_R32; 
 case MMC_CMD34:
 case MMC_CMD37:
 if (!0) ; else printf("%s: MMC class 5 command %d (0x%08x)"
 " reserved for compatibility\n",
 getInstanceName().c_str(), cmd, arg);
 STATUS_REG |= (1 << 22);
 return MMC_RERROR;
 case MMC_CMD60: 
 case MMC_CMD61:
 case MMC_CMD62:
 case MMC_CMD63:
 if (!0) ; else printf("%s: MMC command %d is reserved for manufacturer (0x%08x)\n",
 getInstanceName().c_str(), cmd, arg);
 STATUS_REG |= (1 << 22);
 return MMC_RERROR;
 default:
 if (!0) ; else printf("%s: unhandled MMC command %d (0x%08x)\n",
 getInstanceName().c_str(), cmd, arg);
 STATUS_REG |= (1 << 22);
 return MMC_RERROR;

 }
 return MMC_RNONE;

}
}

#line 999 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::start_timer(uint32_t delay)
{
 assert(!__MMC_internal_1.isSet());
 if (!0) ; else printf("%s:%d %s() start_timer \n", __FILE__, __LINE__, __FUNCTION__);
 if (p_fast_access)
 __MMC_internal_2.signal();
 else
 __MMC_internal_1.set(delay);

}
}

#line 1009 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::stop_timer()
{
 if (!0) ; else printf("%s:%d %s() stop_timer \n", __FILE__, __LINE__, __FUNCTION__);
 if ((cstate == MMCS_RECEIVE) && __MMC_internal_1.isSet())
 {
 flushWriteBlock();
 }
 __MMC_internal_1.cancel();

}
}

#line 1019 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::assert_timer_is_stopped()
{
 assert(!__MMC_internal_1.isSet());

}
}

#line 1024 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { mmc_resp_t 
Component__MMC::start_rblock(mmc_cmd_t cmd, uint32_t arg, void* resp)
{
 if (!0) ; else printf("%s:%d %s() enter block_address=0x%08X\n", __FILE__, __LINE__, __FUNCTION__, arg);
 if (!cstate_change(MMCS_TRANSFER, MMCS_DATA, cmd, false))
 {
 STATUS_REG |= (1 << 22);
 return MMC_RNONE;
 }

 
 
 block_address = arg;

 
 
 
 if (mmc_capacity > 0x80000000)
 {
 block_address *= BLOCKLEN_REG;
 }

 if (!check_address(block_address))
 { 
 cstate_change(MMCS_DATA, MMCS_TRANSFER, cmd, true);
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }
 start_timer(BLOCKLEN_REG*8);

 if (!0) ; else printf("%s:%d %s() start_rblock(): Set time to expire in %d ticks.\n"
 , __FILE__, __LINE__, __FUNCTION__, BLOCKLEN_REG*8);
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;

}
}

#line 1059 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { mmc_resp_t 
Component__MMC::start_wblock(mmc_cmd_t cmd, uint32_t arg, void* resp)
{
 if (is_write_protected())
 {
 if (!0) ; else printf("%s: start_wblock(): write protected card\n",
 getInstanceName().c_str());
 STATUS_REG |= (1 << 26);
 return MMC_RNONE;
 }

 if (!cstate_change(MMCS_TRANSFER, MMCS_RECEIVE, cmd, false))
 {
 STATUS_REG |= (1 << 22);
 return MMC_RNONE;
 }

 block_address = arg;
 
 
 
 if (mmc_capacity > 0x80000000)
 {
 block_address *= BLOCKLEN_REG;
 }
 if (!check_address(block_address))
 { 
 cstate_change(MMCS_RECEIVE, MMCS_TRANSFER, cmd, true);
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;
 }
 

 
 mmc_store->accessBlock(block_address, BLOCKLEN_REG, &data_pointer);
 CheckForBackingStoreError();

 if (!0) ; else printf("%s:%d %s() multiple_blocks=%d calling tx()\n", __FILE__, __LINE__, __FUNCTION__, multiple_blocks);
 
 mmc.Tx(data_pointer, BLOCKLEN_REG);

 
 mmc_update_status((mmc_status_t *)resp);
 return MMC_R32;

}
}

#line 1106 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::stuff_bits(uint32_t& w, uint32_t off, uint32_t s, uint32_t val)
{
 w |= (val << (s-off));

}
}

#line 1115 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::init_csd_r(uint32_t* w)
{

 uint32_t m, e;
 get_capacity(&m, &e);

 w[0] = w[1] = w[2] = w[3] = 0;

 stuff_bits( w[0], 96, 126, 1);
 stuff_bits( w[0], 96, 122, 3);
 stuff_bits( w[0], 96, 115, 0x0f);
 stuff_bits( w[0], 96, 112, 0x00);
 stuff_bits( w[0], 96, 104, 1);
 stuff_bits( w[0], 96, 99 , 1 );
 stuff_bits( w[0], 96, 96 , 1 );

 stuff_bits( w[1], 64, 84, ((1<<0) | (1<<2) | (1<<4) | (1<<5)));
 stuff_bits( w[1], 64, 80, (11) );
 stuff_bits( w[1], 64, 79, 0 );
 stuff_bits( w[1], 64, 78, 0 );
 stuff_bits( w[1], 64, 77, 0 );
 stuff_bits( w[1], 64, 64, (m >> 2) & 0x3ff );

 stuff_bits( w[2], 32, 62, (m & 3) );
 stuff_bits( w[2], 32, 47, e );

 stuff_bits( w[3], 0, 26, 2 );
 stuff_bits( w[3], 0, 22, (11) );
 stuff_bits( w[3], 0, 21, 0 );

 bool wp = false;

 if (mmc_store)
 {
 wp = mmc_store->isReadOnly();
 }
 stuff_bits( w[3], 0, 13, wp);

}
}

#line 1154 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::init_cid_r(uint32_t* r)
{
 const char *c = p_prodName.c_str();

 r[0]=r[1]=r[2]=r[3]=0;

 stuff_bits( r[0], 96, 120, p_manid & 0xff);
 stuff_bits( r[0], 96, 104, p_OEMid & 0xffff);
 stuff_bits( r[0], 96, 96, c[0]);
 stuff_bits( r[1], 64, 88, c[1]);
 stuff_bits( r[1], 64, 80, c[2]);
 stuff_bits( r[1], 64, 72, c[3]);
 stuff_bits( r[1], 64, 64, c[4]);
 stuff_bits( r[2], 32, 56, c[5]);
 stuff_bits( r[2], 32, 48, p_prodRev & 0xff);
 stuff_bits( r[2], 32, 32, (p_sernum >> 16) & 0xffff);
 stuff_bits( r[3], 0, 16, p_sernum & 0xffff);
 stuff_bits( r[3], 0, 12, 1);
 stuff_bits( r[3], 0, 8, 2008-1997);

}
}

#line 1175 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::update_csd(uint32_t* data)
{
 CSD_REG0 = data[0];
 CSD_REG1 = data[1];
 CSD_REG2 = data[2];
 CSD_REG3 = data[3];

}
}

#line 1183 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::update_cid(uint32_t* data)
{
 CID_REG0 = data[0];
 CID_REG1 = data[1];
 CID_REG2 = data[2];
 CID_REG3 = data[3];

}
}

#line 1192 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { int 
Component__MMC::nlz(uint32_t x)
{
 int n;

 if (x == 0)
 return 32;

 n = 1;

 if ((x >> 16) == 0) { n = n + 16; x = x << 16; }
 if ((x >> 24) == 0) { n = n + 8; x = x << 8; }
 if ((x >> 28) == 0) { n = n + 4; x = x << 4; }
 if ((x >> 30) == 0) { n = n + 2; x = x << 2; }

 n = n - (x >> 31);

 return n;

}
}

#line 1213 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__MMC::get_capacity(uint32_t* mp, uint32_t* ep)
{
 uint64_t capacity = 0;

 if (mmc_store)
 capacity = (uint64_t)mmc_store->size();

 
 const uint64_t our_min_size = (1 << (11)) * (1 << 2);
 if (capacity < our_min_size)
 {
 if (!0) ; else printf("%s: Backing store (%"PRIu64") is too small (min. %"PRIu64").\n",
 getInstanceName().c_str(), capacity, our_min_size);
 mmc_capacity = 0;
 return false;
 }

 
 const uint64_t our_max_size = 0x80000000;
 if (capacity > our_max_size)
 {
 message(MSG_ERROR, "%s: File too big: capacity(%"PRIu64" > %"PRIu64")\n",
 getInstanceName().c_str(), capacity, our_max_size);
 mmc_capacity = 0;
 return false;
 }

 uint32_t blocks = capacity >> (11);

 

 uint32_t m = blocks - 1;
 while (m >= (1 << 12)) 
 m >>= 1;

 
 
 

 
 

 int32_t e = 31 - nlz(blocks / (m + 1) - 1) + 1 - 2;

 
 
 if (e < 0) {
 m >>= -e;
 e = 0;
 }

 mmc_capacity = (m + 1) << (e + 2 + (11));

 if (mmc_capacity != capacity)
 message(MSG_ERROR, "%s: Backing store size (%"PRIu64") adjusted to %"PRIu64"!\n",
 getInstanceName().c_str(), capacity, mmc_capacity);

 if (mp)
 *mp = m;
 if (ep)
 *ep = e;

 if (!0) ; else printf("%s: Capacity = %"PRIu64" bytes (e=%u, m=%u)\n",
 getInstanceName().c_str(), mmc_capacity, e, m);

 return true;

}
}

#line 1284 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__MMC::is_write_protected()
{
 bool write_protect = (CSD_REG3 & (1 << 13)) || (CSD_REG3 & (1 << 12));

 if (mmc_store)
 {
 write_protect |= mmc_store->isReadOnly();
 }
 if (!0) ; else printf("%s: write_protect = %s\n",
 getInstanceName().c_str(),
 (write_protect? "true": "false"));
 return (write_protect);

}
}

#line 1304 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__MMC::cstate_change(card_state_t old, card_state_t n, mmc_cmd_t cmd, bool allow_anyway)
{
 if ((cstate & old) == 0)
 {
 if (allow_anyway)
 {
 if (!0) ; else printf("%s: [%s] Illegal transition to %s from %s (not %s)."
 " Never mind!\n", getInstanceName().c_str(),
 MMCcmdName(cmd), MMCstateName(n),
 MMCstateName(cstate), MMCstateName(old));
 cstate = n;
 return true;
 }
 
 message(MSG_WARNING, "%s: [%s] Illegal transition to %s from %s (not %s)."
 " Blocking!\n", getInstanceName().c_str(),
 MMCcmdName(cmd), MMCstateName(n),
 MMCstateName(cstate), MMCstateName(old));
 return false;
 }
 
 if (!0) ; else printf("%s: [%s] State change to %s from %s.\n",
 getInstanceName().c_str(), MMCcmdName(cmd),
 MMCstateName(n), MMCstateName(cstate));
 cstate = n;
 return true;

}
}

#line 1332 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__MMC::is_ready()
{
 if (cstate == MMCS_READY)
 return 1;
 return 0;

}
}

#line 1340 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::mmc_update_status(mmc_status_t* st)
{

 
 STATUS_REG |= (1 << 8);

 *st = STATUS_REG | (((uint32_t)old_state) << (9));

 STATUS_REG &= ~(((1 << 5) | (1 << 13) | (1 << 15) | (1 << 16) | (1 << 17) | (1 << 18) | (1 << 19) | (1 << 20) | (1 << 21) | (1 << 24) | (1 << 26) | (1 << 27) | (1 << 28) | (1 << 29) | (1 << 30) | (1 << 31))); 

 
 
 
 STATUS_REG &= ~((1 << 22));

}
}

#line 1356 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { const char* 
Component__MMC::MMCcmdName(mmc_cmd_t cmd)
{
 static const char *strs[64] = {
 "MMC_GO_IDLE_STATE       ", "MMC_SEND_OP_COND        ", "MMC_ALL_SEND_CID        ",
 "MMC_SET_RELATIVE_ADDR   ", "MMC_SET_DSR             ", "MMC_CMD5                ",
 "MMC_SWITCH              ", "MMC_SELDESL_CARD        ", "MMC_SEND_EXT_CSD        ",
 "MMC_SEND_CSD            ", "MMC_SEND_CID            ", "MMC_READ_DAT_UNTIL_STOP ",
 "MMC_STOP_TRANSMISSION   ", 
 "MMC_SEND_STATUS         ", "MMC_BUSTEST_R           ",
 "MMC_GO_INACTIVE_STATE   ",
 "MMC_SET_BLOCKLEN        ", "MMC_READ_SINGLE_BLOCK   ", "MMC_READ_MULTIPLE_BLOCK ",
 "MMC_BUSTEST_W           ", 
 "MMC_WRITE_DAT_UNTIL_STOP", "MMC_CMD21               ", "MMC_CMD22               ",
 "MMC_SET_BLOCK_COUNT     ", "MMC_WRITE_BLOCK         ", "MMC_WRITE_MULTIPLE_BLOCK",
 "MMC_PROGRAM_CID         ", "MMC_PROGRAM_CSD         ",
 "MMC_SET_WRITE_PROT      ", "MMC_CLR_WRITE_PROT      ", "MMC_SEND_WRITE_PROT     ",
 "MMC_CMD31               ",
 "MMC_CMD32               ", "MMC_CMD33               ", "MMC_CMD34               ",
 "MMC_ERASE_GROUP_START   ", "MMC_ERASE_GROUP_END     ", "MMC_CMD37               ",
 "MMC_ERASE               ",
 "MMC_FAST_IO             ", "MMC_GO_IRQ_STATE        ", "MMC_CMD41               ",
 "MMC_LOCK_UNLOCK         ", "MMC_CMD43               ", "MMC_CMD44               ",
 "MMC_CMD45               ", "MMC_CMD46               ", "MMC_CMD47               ",
 "MMC_CMD48               ", "MMC_CMD49               ", "MMC_CMD50               ",
 "MMC_CMD51               ", "MMC_CMD52               ", "MMC_CMD53               ",
 "MMC_CMD54               ",
 "MMC_APP_CMD             ", "MMC_GEN_CMD             ", "MMC_CMD57               ",
 "MMC_CMD58               ", "MMC_CMD59               ", "MMC_CMD60               ",
 "MMC_CMD61               ", "MMC_CMD62               ", "MMC_CMD63               "
 };

 return strs[cmd];

}
}

#line 1390 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { const char* 
Component__MMC::MMCstateName(card_state_t st)
{
 static char buf[40];

 switch (st) {
 case MMCS_IDLE: return "IDLE";
 case MMCS_READY: return "READY";
 case MMCS_ID: return "ID";
 case MMCS_STANDBY: return "STANDBY";
 case MMCS_TRANSFER: return "TRANSFER";
 case MMCS_DATA: return "DATA";
 case MMCS_RECEIVE: return "RECEIVE";
 case MMCS_PROGRAM: return "PROGRAM";
 case MMCS_DISABLED: return "DISABLED";
 default:
 sprintf(buf,"UNKNOWN (0x%x)", (uint32_t)st);
 return(buf);
 }

}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::interconnect()
{{if(!controlPort_timer__.interconnect.empty()) controlPort_timer__.interconnect();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::disconnect()
{{if(!controlPort_timer__.disconnect.empty()) controlPort_timer__.disconnect();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::update()
{{if(!controlPort_timer__.update.empty()) controlPort_timer__.update();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::communicate()
{{if(!controlPort_timer__.communicate.empty()) controlPort_timer__.communicate();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::traceEndOfCycle()
{{if(!controlPort_timer__.traceEndOfCycle.empty()) controlPort_timer__.traceEndOfCycle();};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::loadApplicationFile(const std::string& filename)
{{if(!controlPort_timer__.loadApplicationFile.empty()) controlPort_timer__.loadApplicationFile(filename);};
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__MMC::save(MxODataStream& os)
{{if(!controlPort_timer__.save.empty()) controlPort_timer__.save(os);};return true;
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__MMC::restore(MxIDataStream& is)
{{if(!controlPort_timer__.restore.empty()) controlPort_timer__.restore(is);};return true;
}
}

#line 10 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::step()
{{if(!controlPort_timer__.step.empty()) controlPort_timer__.step();};
}
}

#line 429 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { mmc_resp_t 
Component__MMC::abstract_port__mmc__cmd(mmc_cmd_t cmd, uint32_t arg, void* resp)
{
 if (mmc_capacity != 0) {
 return (doCommand(cmd, arg, resp));
 } else {
 if (!0) ; else printf("%s: Returning command error, as mmc_capacity = 0.\n"
 , getInstanceName().c_str());
 return MMC_RERROR;
 }
 
}
}

#line 440 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { const char* 
Component__MMC::abstract_port__mmc__cmd_name(mmc_cmd_t cmd)
{
 return(MMCcmdName(cmd));
 
}
}

#line 445 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::abstract_port__mmc__Rx_rdy()
{
 if (!0) ; else printf("%s:%d %s() \n", __FILE__, __LINE__, __FUNCTION__);
 if (cstate != MMCS_DATA)
 {
 return;
 }

 if (multiple_blocks)
 {
 if (!0) ; else printf("%s:%d %s() starting timer in order to read next data block\n", __FILE__, __LINE__, __FUNCTION__);
 multiple_blocks--;
 block_address += BLOCKLEN_REG;
 if (!0) ; else printf("%s:%d %s() multiple_blocks=%d block_address=0x%08X\n"
 , __FILE__, __LINE__, __FUNCTION__, multiple_blocks, block_address);
 if (check_address(block_address))
 {
 start_timer(BLOCKLEN_REG*8);
 }
 else
 {
 message(MSG_WARNING, "%s: Forcing state back from DATA -> TRANSFER (addr=0x%08x).\n"
 , getInstanceName().c_str(), block_address);
 cstate = MMCS_TRANSFER;
 }
 }
 else
 {
 if (!0) ; else printf("%s: DATA -> TRANSFER at end of last block (addr=0x%08x).\n"
 , getInstanceName().c_str(), block_address);
 cstate = MMCS_TRANSFER;
 }
 
}
}

#line 479 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__MMC::abstract_port__mmc__Tx_done()
{
 if (cstate != MMCS_RECEIVE)
 {
 return;
 }

 
 if (multiple_blocks)
 {
 if (!0) ; else printf("%s:%d %s() starting timer in order to write back data block\n", __FILE__, __LINE__, __FUNCTION__);
 start_timer(BLOCKLEN_REG*8);
 }
 else
 {
 if (!0) ; else printf("%s: RECEIVE -> TRANSFER at end of last block (addr=0x%08x).\n"
 , getInstanceName().c_str(), block_address);
 assert_timer_is_stopped();
 cstate = MMCS_TRANSFER;
 }
 
}
}

#line 505 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { sg::Signal::State 
Component__MMC::abstract_port__card_present__getValue()
{
 return mmc_store ? sg::Signal::Set : sg::Signal::Clear;
 
}
}

#line 621 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/MMC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__MMC::abstract_port__timer_callback_handler__signal()
{
 if (cstate == MMCS_DATA)
 {
 if (!0) ; else printf("%s:%d %s() read timer alarm\n", __FILE__, __LINE__, __FUNCTION__);
 
 advance_readFromCard_state();
 return 0;
 }
 else if (cstate == MMCS_RECEIVE)
 {
 
 if (!0) ; else printf("%s:%d %s() write timer alarm\n", __FILE__, __LINE__, __FUNCTION__);
 advance_writeToCard_state();
 return 0;
 }

 
 if (!0) ; else printf("%s: In timer handler, unexpected state %s\n",
 getInstanceName().c_str(), MMCstateName(cstate));
 return 0; 
 
}
}

#line 15402 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__MMC
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__MMC::Component__MMC(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,p_mmc_file(GetParameterValue(params, "p_mmc_file", "mmc.dat"))
	,p_prodName(GetParameterValue(params, "p_prodName", "ARMmmc"))
	,p_prodRev(GetParameterValue(params, "p_prodRev", MxS64CONST(0x1), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,p_manid(GetParameterValue(params, "p_manid", MxS64CONST(0x2), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,p_OEMid(GetParameterValue(params, "p_OEMid", MxS64CONST(0x0), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,p_sernum(GetParameterValue(params, "p_sernum", MxS64CONST(0xca4d0001), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,p_fast_access(!!GetParameterValue(params, "p_fast_access", MxS64CONST(0x1), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))



{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Generic Multimedia Card";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = MMC_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		{
			sg::Params params_timer__ = params.getParamsFor("timer");
			add(timer = ClockTimer_factory->instantiate("timer", simulationContext, params_timer__));
		}
		ClockTimer_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__MMC::control_port__configure, this);
    bind_method(control_port, init, &Component__MMC::init, this);
    bind_method(control_port, interconnect, &Component__MMC::interconnect, this);
//  bind_method(control_port, postConnect, &Component__MMC::postConnect, this);
    bind_method(control_port, reset, &Component__MMC::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__MMC::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__MMC::disconnect, this);
    bind_method(control_port, terminate, &Component__MMC::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__MMC::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__MMC::refresh, this);
    bind_method(control_port, step, &Component__MMC::step, this);
    bind_method(control_port, update, &Component__MMC::update, this);
    bind_method(control_port, communicate, &Component__MMC::communicate, this);
    bind_method(control_port, getProperty, &Component__MMC::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__MMC::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__MMC::control_port__bypass, this);
    bind_method(control_port, run, &Component__MMC::control_port__run, this);
    bind_method(control_port, stop, &Component__MMC::control_port__stop, this);
    bind_method(control_port, idle, &Component__MMC::control_port__idle, this);
    bind_method(control_port, quit, &Component__MMC::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__MMC::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__MMC::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__MMC::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__MMC::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__MMC::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__MMC::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__MMC::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__MMC::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_timer__.connectTo(timer->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(mmc, cmd, &Component__MMC::abstract_port__mmc__cmd, this);
	bind_method(mmc, cmd_name, &Component__MMC::abstract_port__mmc__cmd_name, this);
	bind_method(mmc, Rx_rdy, &Component__MMC::abstract_port__mmc__Rx_rdy, this);
	bind_method(mmc, Tx_done, &Component__MMC::abstract_port__mmc__Tx_done, this);
	bind_method(card_present, getValue, &Component__MMC::abstract_port__card_present__getValue, this);
	bind_method(timer_callback_handler, signal, &Component__MMC::abstract_port__timer_callback_handler__signal, this);


    // add abstract ports
	publishSlavePort("mmc", mmc);
	mmc.SetName__("mmc");
	publishMasterPort("card_present", card_present);
	card_present.SetName__("card_present");
	publishSlavePort("clk_in", clk_in);
	clk_in.SetName__("clk_in");
	timer_callback_handler.SetName__("timer_callback_handler");
	__MMC_internal_1.SetName__("__MMC_internal_1");
	__MMC_internal_2.SetName__("__MMC_internal_2");


    // wire up static connection map
	clk_in.connectTo(timer->findPort("clk_in"));
	timer->findPort("timer_callback").connectTo(timer_callback_handler);
	__MMC_internal_1.connectTo(timer->findPort("timer_control"));
	__MMC_internal_2.connectTo(timer->findPort("timer_callback"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__MMC::~Component__MMC()
{
}

void Component__MMC::control_port__configure(const sg::Params& params)
{
	if(controlPort_timer__.configure.implemented()) controlPort_timer__.configure(params.getParamsFor("timer"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__MMC_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__MMC::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_timer__.populateCADIMap.implemented())
			{
				controlPort_timer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__MMC::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__MMC::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__MMC::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__MMC::control_port__bypass(const std::string&)
{
    return "";
}


void Component__MMC::control_port__run()
{
}


void Component__MMC::control_port__stop()
{
}


void Component__MMC::control_port__idle()
{
}


void Component__MMC::control_port__quit()
{
}


void Component__MMC::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__MMC::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__MMC::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__MMC::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__MMC::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__MMC::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__MMC::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__MMC::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__MMC::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__MMC::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_p_prodRev: *data = p_prodRev; break;
	case PARAMETER_ID_p_manid: *data = p_manid; break;
	case PARAMETER_ID_p_OEMid: *data = p_OEMid; break;
	case PARAMETER_ID_p_sernum: *data = p_sernum; break;
	case PARAMETER_ID_p_fast_access: *data = p_fast_access; break;

        default:
            printf("error: Component__MMC::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__MMC::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {
	case PARAMETER_ID_p_mmc_file:  data = p_mmc_file; break;
	case PARAMETER_ID_p_prodName:  data = p_prodName; break;

        default:
            printf("error: Component__MMC::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__MMC::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_p_prodRev:
		{
			*(const_cast<int32_t*>(&p_prodRev)) = *data;
		}
		break;
	case PARAMETER_ID_p_manid:
		{
			*(const_cast<int32_t*>(&p_manid)) = *data;
		}
		break;
	case PARAMETER_ID_p_OEMid:
		{
			*(const_cast<int32_t*>(&p_OEMid)) = *data;
		}
		break;
	case PARAMETER_ID_p_sernum:
		{
			*(const_cast<int32_t*>(&p_sernum)) = *data;
		}
		break;
	case PARAMETER_ID_p_fast_access:
		{
			*(const_cast<bool*>(&p_fast_access)) = !!*data;
		}
		break;

        default:
            printf("error: Component__MMC::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__MMC::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {
	case PARAMETER_ID_p_mmc_file:
		{
			*(const_cast<std::string*>(&p_mmc_file)) = data;
		}
		break;
	case PARAMETER_ID_p_prodName:
		{
			*(const_cast<std::string*>(&p_prodName)) = data;
		}
		break;

        default:
            printf("error: Component__MMC::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__MMC::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__MMC::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__MMC::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__MMC::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__MMC::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__MMC::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__MMC::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__MMC::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__MMC::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "p_mmc_file") id = PARAMETER_ID_p_mmc_file;
    if (name == "p_prodName") id = PARAMETER_ID_p_prodName;
    if (name == "p_prodRev") id = PARAMETER_ID_p_prodRev;
    if (name == "p_manid") id = PARAMETER_ID_p_manid;
    if (name == "p_OEMid") id = PARAMETER_ID_p_OEMid;
    if (name == "p_sernum") id = PARAMETER_ID_p_sernum;
    if (name == "p_fast_access") id = PARAMETER_ID_p_fast_access;

    return id;
}

void Component__MMC::reset_resources__()
{
    // resource initialization code
	OCR_REG = 0; // reset register
	CID_REG0 = 0; // reset register
	CID_REG1 = 0; // reset register
	CID_REG2 = 0; // reset register
	CID_REG3 = 0; // reset register
	CSD_REG0 = 0; // reset register
	CSD_REG1 = 0; // reset register
	CSD_REG2 = 0; // reset register
	CSD_REG3 = 0; // reset register
	RCA_REG = 0; // reset register
	DSR_REG = 0; // reset register
	BLOCKLEN_REG = 0; // reset register
	STATUS_REG = 0; // reset register
	BLOCK_COUNT_REG = 0; // reset register

}


} // FVP_VE_Cortex_A15x1_NMS
#line 247 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::byte_ticks()
{
 return word_len + stop_bits + 1;
 
}
}

#line 253 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::log_hex2(char* dest, uint32_t val)
{
 char s[3];
 sprintf(s, "%2.2x", (val & 0xff));
 dest[0] = s[0];
 dest[1] = s[1];
 
}
}

#line 261 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::log_fifos()
{
 size_t i;
 for (i = 0; i < 79; ++i) fifo_string[i] = ' ';
 fifo_string[i] = 0;
 fifo_string[40] = '|';
 for (i = 0; i < in.size(); ++i) {
 log_hex2(&fifo_string[5+2*(15-i)],
 in[i]);
 }
 for (i = 0; i < out.size(); ++i) {
 log_hex2(&fifo_string[44+2*(15-i)],
 out[i]);
 }
 
}
}

#line 277 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::update_clock()
{
 if (ibrd > 0) 
 {
 uint32_t bauddiv = ((uint32_t)ibrd << 6) + (fbrd & 0x2f);

 __PL011_Uart_internal_1.set(64, bauddiv * 16);

 if (!0) ; else printf("PL011: clock rate is %"PRIu64"\n", (uint64_t)__PL011_Uart_internal_2.rateInHz());

 if (enabled) {
 __PL011_Uart_internal_3.set(byte_ticks());
 }
 } else {
 __PL011_Uart_internal_3.cancel();
 }
 
}
}

#line 296 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint16_t 
Component__PL011_Uart::update_fr()
{
 return fr;
 
}
}

#line 301 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::set_rts(bool rts_enabled)
{
 uint8_t signals = serial_out.signalsGet();

 rts = rts_enabled;
 signals = (signals & ~SIG_RTS) | (rts ? SIG_RTS : 0);

 serial_out.signalsSet(signals);
 
}
}

#line 311 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::update_interrupts()
{
 if (!0) ; else printf("PL011::interrupts now raw:0x%x masked:0x%x\n", irq, irq & irq_mask);

 bool signal = ((irq & irq_mask) != 0);
 if (signal != irq_signal) {
 intr.setValue((signal) ? sg::Signal::Set : sg::Signal::Clear);
 irq_signal = signal;
 }
 
}
}

#line 323 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::disconnect()
{
 __PL011_Uart_internal_3.cancel();
 {if(!controlPort_busslave__.disconnect.empty()) controlPort_busslave__.disconnect();if(!controlPort_clk_divider__.disconnect.empty()) controlPort_clk_divider__.disconnect();if(!controlPort_timer__.disconnect.empty()) controlPort_timer__.disconnect();};
 
}
}

#line 329 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::init()
{
 iFile = NULL;
 oFile = NULL;

 infile_status = INFILE_NEWLINE;

 {if(!controlPort_busslave__.init.empty()) controlPort_busslave__.init();if(!controlPort_clk_divider__.init.empty()) controlPort_clk_divider__.init();if(!controlPort_timer__.init.empty()) controlPort_timer__.init();};

 character_in.setName("pl011_character_in");
 character_in.setDescription("A character was received.");
 character_in.AddField("tick", "The count of ticks from simulation start that the UART has received.", MTI::EventFieldType::MTI_UNSIGNED_INT, 8);
 character_in.AddField(
 "char",
 "The character received.",
 MTI::EventFieldType::MTI_UNSIGNED_INT,
 1
 );
 character_in.AddField(
 "fifo_overflow",
 "If true, then the character was lost as the fifo was full.",
 MTI::EventFieldType::MTI_BOOL,
 1
 );
 cadi__->RegisterTraceSource(&character_in);

 character_out.setName("pl011_character_out");
 character_out.setDescription(
 "A character was written to the UART to output."
 );
 character_out.AddField(
 "tick",
 "The count of ticks from simulation start that the UART has received.",
 MTI::EventFieldType::MTI_UNSIGNED_INT,
 8
 );
 character_out.AddField(
 "char",
 "The output character.",
 MTI::EventFieldType::MTI_UNSIGNED_INT,
 1
 );
 character_out.AddField(
 "fifo_overflow",
 "If true, then the character was lost as the fifo was full.",
 MTI::EventFieldType::MTI_BOOL,
 1
 );
 cadi__->RegisterTraceSource(&character_out);

 line_buffered_out.setName("pl011_line_buffered_out");
 line_buffered_out.setDescription(
 "The buffered output of character_out.  The buffer is flushed when any control character is received.  The control characters do not form part of the buffer.  The buffer's size is limited to 255 characters and truncation is indicated by an appended '...'  "
 );
 line_buffered_out.AddField(
 "tick",
 "The count of ticks from simulation start that the UART has received at the point at which it receives the control character that flushes the buffer.",
 MTI::EventFieldType::MTI_UNSIGNED_INT,
 8
 );
 line_buffered_out.AddField(
 "buffer",
 "The line buffer.",
 MTI::EventFieldType::MTI_STRING,
 0,
 260
 );
 cadi__->RegisterTraceSource(&line_buffered_out);

 if (shutdown_on_eot)
 {
 shutdown_tag = "\04";
 }
 
}
}

#line 404 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::terminate()
{
 if (oFile)
 {
 
 if (oFile != stdout)
 fclose(oFile);
 oFile = NULL;
 }

 if (iFile)
 {
 fclose(iFile);
 iFile = NULL;
 }

 {if(!controlPort_busslave__.terminate.empty()) controlPort_busslave__.terminate();if(!controlPort_clk_divider__.terminate.empty()) controlPort_clk_divider__.terminate();if(!controlPort_timer__.terminate.empty()) controlPort_timer__.terminate();};
 
}
}

#line 423 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::reset(int level)
{
 {if(!controlPort_busslave__.reset.empty()) controlPort_busslave__.reset(level);if(!controlPort_clk_divider__.reset.empty()) controlPort_clk_divider__.reset(level);if(!controlPort_timer__.reset.empty()) controlPort_timer__.reset(level);};
 fifoTide[0]=2;
 fifoTide[1]=4;
 fifoTide[2]=8;
 fifoTide[3]=12;
 fifoTide[4]=14;
 fifoTide[5]=14;
 fifoTide[6]=14;
 fifoTide[7]=14;


 int temp = 16 * baud_rate;
 int divider = clock_rate / temp;
 int remainder = clock_rate % temp;
 temp = (8 * remainder) / baud_rate;
 int fraction = (temp >> 1) + (temp & 1);

 irq = 0;
 irq_mask = 0;
 lcr_h = 0;
 fr = UARTFR_TXFE | UARTFR_RXFE | UARTFR_CTS; 
 if (uart_enable)
 {
 ibrd = divider;
 fbrd = fraction;
 cr = UARTCR_RXE | UARTCR_TXE | UARTCR_UARTEN;
 } else {
 ibrd = 0;
 fbrd = 0;
 cr = UARTCR_RXE | UARTCR_TXE;
 }

 ifls = 0x12; 

 rsr = 0;
 word_len = 8;
 stop_bits = 1;

 rx_intlevel = fifoTide[2]; 
 tx_intlevel = fifoTide[2]; 


 fifo_enabled = 0;
 in.set_capacity(1);
 out.set_capacity(1);

 overrun = 0;
 fifo_overrun = 0;


 enabled = (cr & UARTCR_UARTEN) ? 1 : 0;
 tx_enabled = (cr & UARTCR_TXE) ? 1 : 0;
 rx_enabled = (cr & UARTCR_RXE) ? 1 : 0;

 rts = 1; 

 irq_signal = false;

 update_interrupts();
 update_clock();

 if (out_file != "")
 {
 if (out_file == "-") 
 oFile = stdout;
 else
 oFile = fopen(out_file.c_str(), "wb"); 

 if (NULL == oFile)
 {
 message(MSG_ERROR, "%s: could not open output file <%s> for writing\n", getInstanceName().c_str(), out_file.c_str());
 }
 }

 if (in_file != "")
 {
 iFile = fopen(in_file.c_str(), "rb");

 if (NULL == iFile)
 {
 message(MSG_ERROR, "%s: could not open input file <%s> for reading\n", getInstanceName().c_str(), in_file.c_str());
 }
 }
 
}
}

#line 511 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::registerRead(pv::bus_addr_t device_addr)
{
 switch (device_addr) {
 case 0x00: return getUARTDR();
 case 0x04: return getUARTRSR();
 case 0x08: return 0; 
 case 0x0c: return 0; 
 case 0x10: return 0; 
 case 0x14: return 0; 
 case 0x18: return getUARTFR();
 case 0x20: return 0; 
 case 0x24: return getUARTIBRD();
 case 0x28: return getUARTFBRD();
 case 0x2c: return getUARTLCR_H();
 case 0x30: return getUARTCR();
 case 0x34: return getUARTIFLS();
 case 0x38: return getUARTIMSC();
 case 0x3C: return getUARTRIS();
 case 0x40: return getUARTMIS();
 case 0x44: return 0; 
 case 0x48: return 0; 

 
 case 0xFE0: return 0x11;
 case 0xFE4: return 0x10;
 case 0xFE8: return 0x24;
 case 0xFEC: return 0x00;

 
 case 0xFF0: return 0x0d;
 case 0xFF4: return 0xf0;
 case 0xFF8: return 0x05;
 case 0xFFC: return 0xb1;

 default: return 0; 
 }
 
}
}

#line 549 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::registerWrite(pv::bus_addr_t device_addr, uint32_t data)
{
 switch (device_addr) {
 case 0x00: putUARTDR(data); return;
 case 0x04: putUARTECR(data); return;
 case 0x08: return; 
 case 0x0c: return; 
 case 0x10: return; 
 case 0x14: return; 
 case 0x18: return; 
 case 0x20: return; 
 case 0x24: putUARTIBRD(data); return;
 case 0x28: putUARTFBRD(data); return;
 case 0x2c: putUARTLCR_H(data); return;
 case 0x30: putUARTCR(data); return;
 case 0x34: putUARTIFLS(data); return;
 case 0x38: putUARTIMSC(data); return;
 case 0x3C: return; 
 case 0x40: return; 
 case 0x44: putUARTICR(data); return;
 case 0x48: return; 
 default: return;
 }
 
}
}

#line 574 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::debugRead(pv::bus_addr_t addr)
{
 if (addr == 0x00) {
 if (!in.empty()) {
 return (uint16_t)in.front();
 } else {
 return 0;
 }
 }
 return registerRead(addr);
 
}
}

#line 586 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTDR()
{
 uint32_t data;
 if (in.empty()) {
 data = 0;
 } else {
 data = rsr = (uint16_t)in.front();
 in.pop_front();
 fr &=~ UARTFR_RXFF;

 if (in.empty())
 {
 fr |= UARTFR_RXFE;

 
 irq &= ~RTINT;
 update_interrupts();
 }

 if (!fifo_enabled || in.size() < rx_intlevel)
 {
 
 irq &= ~RXINT;
 update_interrupts();

 
 if (cr & UARTCR_RTSEn) {
 set_rts(true);
 }
 }
 }
 last_dr = data;

 if (untimed_fifos) {
 handleByteClockSignal();
 }

 return data;
 
}
}

#line 626 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTRSR()
{
 
 
 return ((rsr & ~OVERRUN_ERR) | overrun) >> 8;
 
}
}

#line 632 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTFR()
{ return (uint32_t)update_fr(); 
}
}

#line 633 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTIBRD()
{ return ibrd; 
}
}

#line 634 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTFBRD()
{ return fbrd; 
}
}

#line 635 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTLCR_H()
{ return lcr_h; 
}
}

#line 636 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTCR()
{ return cr | (rts ? UARTCR_RTS : 0); 
}
}

#line 637 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTIFLS()
{ return ifls; 
}
}

#line 638 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTIMSC()
{ return irq_mask; 
}
}

#line 639 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTRIS()
{ return irq; 
}
}

#line 640 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::getUARTMIS()
{ return irq & irq_mask; 
}
}

#line 644 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::putUARTDR(uint32_t data)
{
 last_dr = data;

 if (!out.full())
 {
 out.push_back(data);
 fr &=~ UARTFR_TXFE;
 fr |= UARTFR_BUSY;

 if (!fifo_enabled || out.size() > tx_intlevel)
 {
 irq &=~ TXINT;
 update_interrupts();
 }

 if (out.full())
 {
 fr |= UARTFR_TXFF;
 }

 character_out_event(data, false);
 } else {
 
 character_out_event(data, true);
 }
 if (untimed_fifos) {
 handleByteClockSignal();
 }
 
}
}

#line 675 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::putUARTECR(uint32_t )
{
 
 rsr = 0;

 
 overrun = 0;
 
}
}

#line 684 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::putUARTIBRD(uint32_t data)
{
 ibrd = (uint16_t)data;
 
}
}

#line 688 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::putUARTFBRD(uint32_t data)
{
 fbrd = (uint8_t)data;
 
}
}

#line 692 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::putUARTLCR_H(uint32_t data)
{
 lcr_h = (uint8_t)(data);
 word_len = ((lcr_h >> 5) & 3) + 5;
 stop_bits = ((lcr_h >> 3) & 1) + 1;

 update_clock();

 uint8_t new_enabled = (lcr_h >> 4) & 1;
 if (new_enabled && !fifo_enabled)
 {
 
 
 flush();

 in.set_capacity(16);
 out.set_capacity(16);
 }
 else if (!new_enabled && fifo_enabled)
 {
 
 
 flush();

 in.set_capacity(1);
 out.set_capacity(1);
 }

 fifo_enabled = new_enabled;
 
}
}

#line 723 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::putUARTCR(uint32_t data)
{
 cr = (uint16_t)data;

 rx_enabled = (cr & UARTCR_RXE) != 0;
 tx_enabled = (cr & UARTCR_TXE) != 0;

 if (!enabled && (cr & UARTCR_UARTEN))
 {
 
 __PL011_Uart_internal_3.set(byte_ticks());
 }
 else if (enabled && !(cr & UARTCR_UARTEN))
 {
 
 __PL011_Uart_internal_3.cancel();
 }
 enabled = (cr & UARTCR_UARTEN) != 0;

 
 if ((cr & UARTCR_RTSEn) == 0) {
 set_rts(1);
 }
 else
 {
 set_rts(0);
 }
 
}
}

#line 752 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::putUARTIFLS(uint32_t data)
{
 ifls = (uint16_t)(data);

 rx_intlevel = fifoTide[(ifls >> 3) & 7];
 tx_intlevel = fifoTide[(ifls >> 0) & 7];

 
 
}
}

#line 762 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::putUARTIMSC(uint32_t data)
{
 
 irq_mask = data;

 update_interrupts();
 
}
}

#line 770 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::putUARTICR(uint32_t data)
{
 irq &=~ data;
 update_interrupts();
 
}
}

#line 777 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::flush()
{
 in.clear();
 out.clear();

 fr &=~ (UARTFR_TXFF | UARTFR_RXFF | UARTFR_BUSY); 
 fr |= UARTFR_TXFE | UARTFR_RXFE;

 set_rts(true);

 irq &= ~(RTINT | RXINT);
 update_interrupts();
 
}
}

#line 791 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::character_out_event(uint8_t character_, bool fifo_overflow)
{
 character_out.fire( ticks, character_, fifo_overflow );

 std::size_t const sz = line_buffer.size();

 unsigned const max_size = 256;

 if (character_ < 32 && character_ != uint8_t('\t'))
 {
 
 
 
 if ( ! line_buffer.empty() )
 {
 
 
 line_buffered_out.fire( ticks, line_buffer.c_str() );
 line_buffer.clear();
 }
 }
 else
 {
 if (sz < max_size)
 {
 
 line_buffer += (char)character_;
 }
 else if (sz == max_size)
 {
 line_buffer.append( "..." );
 }
 }
 
}
}

#line 830 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::handleByteClockSignal()
{
 if (!enabled)
 return 0;

 

 uint8_t signal_value = serial_out.signalsGet();
 fr = fr & ~(UARTFR_DCD | UARTFR_DSR);
 fr |= (signal_value & SIG_DSR) ? UARTFR_DSR : 0;
 fr |= (signal_value & SIG_DCD) ? UARTFR_DCD : 0;


 if (rx_enabled && rts)
 {
 uint16_t data;

 if (fifo_enabled
 && !in.full()
 && iFile
 && !feof(iFile)
 )
 {
 data = computeInFile();
 }
 else
 {
 data = serial_out.dataReceive(); 
 }


 if (0 == (data & UartData_NODATA))
 {
 if (!in.full())
 {
 character_in.fire( ticks, data, false );

 
 in.push_back((uint32_t)data | fifo_overrun);

 
 fifo_overrun = 0;

 fr &=~ UARTFR_RXFE;

 if (!fifo_enabled || in.size() == rx_intlevel)
 {
 irq |= RXINT;
 update_interrupts();

 
 if (cr & UARTCR_RTSEn) {
 set_rts(false);
 }
 }

 if (in.full()) {
 fr |= UARTFR_RXFF;
 }
 }
 else
 {
 character_in.fire( ticks, data, true );
 
 
 
 
 fifo_overrun = OVERRUN_ERR;
 if (overrun == 0)
 {
 overrun = OVERRUN_ERR;

 
 
 irq |= ORINT;
 update_interrupts();
 }
 }

 if (untimed_fifos) {
 
 irq |= RTINT;
 }

 }
 else
 {
 
 
 
 
 if (!(fr & UARTFR_RXFE))
 {
 irq |= RTINT;
 update_interrupts();
 }
 }
 }
 if (tx_enabled)
 {
 if (!out.empty())
 {
 uint8_t data = (uint8_t)out.front();

 bool ok = false;
 if (signal_value & SIG_CTS) {
 serial_out.dataTransmit(data);
 if (oFile)
 {
 if (data == 0)
 fwrite("<NUL>", 5, 1, oFile);
 else
 fwrite(&data, sizeof(data), 1, oFile);
 }

 
 if(unbuffered_output)
 {
 fflush(oFile);
 }

 shutdownTest(data);

 checkPrompt(data);
 ok = true;
 }

 
 
 if (ok )
 {
 out.pop_front();

 fr &=~ UARTFR_TXFF;
 if ((fr & UARTFR_CTS) == 0)
 {
 fr |= UARTFR_CTS;
 irq |= CTSINT;

 update_interrupts();
 }

 if (out.empty())
 {
 fr |= UARTFR_TXFE;
 fr &= ~UARTFR_BUSY;
 }

 if (!fifo_enabled || out.size() == tx_intlevel)
 {
 irq |= TXINT;
 update_interrupts();
 }
 }
 else
 {
 if (fr & UARTFR_CTS)
 {
 fr &= ~UARTFR_CTS;
 irq |= CTSINT;
 update_interrupts();
 }
 }
 }
 }

 return byte_ticks();
 
}
}

#line 999 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint16_t 
Component__PL011_Uart::computeInFile()
{
 uint16_t data = UartData_NODATA;

 switch (infile_status)
 {
 case INFILE_NEWLINE:
 {
 long fpos = ftell (iFile);
 char line[500];
 if (fscanf (iFile, "%500[^\n\r]\r", line) > 0)
 {
 if(fscanf (iFile, "\n") > 0)
 {
 if (strncmp (line, in_file_escape_sequence.c_str(), in_file_escape_sequence.size()) == 0)
 {
 char * ptr = line + in_file_escape_sequence.size();
 if (sscanf (ptr, " WaitForPrompt %[^\n]", prompt) == 1)
 {
 compare_index = 0;
 infile_status = INFILE_WAIT_PROMPT;
 break;
 }
 }
 }
 }
 fseek (iFile, fpos, SEEK_SET);
 infile_status = INFILE_IDLE;
 }

 case INFILE_IDLE:
 {
 uint8_t u8;
 if (fread(&u8, sizeof(u8), 1, iFile) == 1)
 {
 if (u8 == '\n')
 infile_status = INFILE_NEWLINE;
 data = (uint16_t)u8;
 data &= ~UartData_NODATA;
 fr = UARTFR_DCD | UARTFR_DSR | UARTFR_CTS;
 }
 }
 break;

 case INFILE_WAIT_PROMPT:
 break;
 }
 return data;
 
}
}

#line 1049 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::shutdownTest(uint8_t ch)
{
 static unsigned i = 0;

 if (shutdown_tag[0] != '\0')
 {
 if (ch == shutdown_tag[i])
 {
 if (shutdown_tag[++i] == '\0')
 {
 simShutdown();
 }
 }
 else
 {
 i = 0;
 }
 }
 
}
}

#line 1069 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::checkPrompt(uint8_t u8)
{
 if (infile_status == INFILE_WAIT_PROMPT)
 {
 if (u8 == prompt[compare_index])
 {
 ++ compare_index;
 if (compare_index == strlen(prompt))
 infile_status = INFILE_NEWLINE;
 }
 else
 compare_index = 0;
 }
 
}
}

#line 1087 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL011_Uart::debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects)
{
 if(reg_id == 0x000)
 {
 *datap = last_dr;

 } else {
 *datap = registerRead(reg_id);
 }
 return ACCESS_FUNC_OK;
 
}
}

#line 1099 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL011_Uart::debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects)
{
 registerWrite(reg_id, (uint32_t)*datap);

 return ACCESS_FUNC_OK;
 
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::interconnect()
{{if(!controlPort_busslave__.interconnect.empty()) controlPort_busslave__.interconnect();if(!controlPort_clk_divider__.interconnect.empty()) controlPort_clk_divider__.interconnect();if(!controlPort_timer__.interconnect.empty()) controlPort_timer__.interconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::update()
{{if(!controlPort_busslave__.update.empty()) controlPort_busslave__.update();if(!controlPort_clk_divider__.update.empty()) controlPort_clk_divider__.update();if(!controlPort_timer__.update.empty()) controlPort_timer__.update();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::communicate()
{{if(!controlPort_busslave__.communicate.empty()) controlPort_busslave__.communicate();if(!controlPort_clk_divider__.communicate.empty()) controlPort_clk_divider__.communicate();if(!controlPort_timer__.communicate.empty()) controlPort_timer__.communicate();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::traceEndOfCycle()
{{if(!controlPort_busslave__.traceEndOfCycle.empty()) controlPort_busslave__.traceEndOfCycle();if(!controlPort_clk_divider__.traceEndOfCycle.empty()) controlPort_clk_divider__.traceEndOfCycle();if(!controlPort_timer__.traceEndOfCycle.empty()) controlPort_timer__.traceEndOfCycle();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::loadApplicationFile(const std::string& filename)
{{if(!controlPort_busslave__.loadApplicationFile.empty()) controlPort_busslave__.loadApplicationFile(filename);if(!controlPort_clk_divider__.loadApplicationFile.empty()) controlPort_clk_divider__.loadApplicationFile(filename);if(!controlPort_timer__.loadApplicationFile.empty()) controlPort_timer__.loadApplicationFile(filename);};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL011_Uart::save(MxODataStream& os)
{{if(!controlPort_busslave__.save.empty()) controlPort_busslave__.save(os);if(!controlPort_clk_divider__.save.empty()) controlPort_clk_divider__.save(os);if(!controlPort_timer__.save.empty()) controlPort_timer__.save(os);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL011_Uart::restore(MxIDataStream& is)
{{if(!controlPort_busslave__.restore.empty()) controlPort_busslave__.restore(is);if(!controlPort_clk_divider__.restore.empty()) controlPort_clk_divider__.restore(is);if(!controlPort_timer__.restore.empty()) controlPort_timer__.restore(is);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL011_Uart::step()
{{if(!controlPort_busslave__.step.empty()) controlPort_busslave__.step();if(!controlPort_clk_divider__.step.empty()) controlPort_clk_divider__.step();if(!controlPort_timer__.step.empty()) controlPort_timer__.step();};
}
}

#line 49 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL011_Uart::abstract_port__timer_callback_handler__signal()
{
 ++ ticks;
 return handleByteClockSignal();
 
}
}

#line 61 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL011_Uart::abstract_port__device__read(pv::ReadTransaction tx)
{
 if (tx.getAccessWidth() > pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 
 return tx.setReturnData32((uint32_t)registerRead(tx.getAddress() & ~3));
 
}
}

#line 68 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL011_Uart::abstract_port__device__write(pv::WriteTransaction tx)
{
 registerWrite(tx.getAddress(),
 tx.getData32());
 return tx.writeComplete();
 
}
}

#line 75 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL011_Uart::abstract_port__device__debugRead(pv::ReadTransaction tx)
{
 return device.read(tx);
 
}
}

#line 80 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL011_Uart.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL011_Uart::abstract_port__device__debugWrite(pv::WriteTransaction tx)
{
 return device.write(tx);
 
}
}

#line 17161 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PL011_Uart
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PL011_Uart::Component__PL011_Uart(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,clock_rate(GetParameterValue(params, "clock_rate", MxS64CONST(0xe10000), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,baud_rate(GetParameterValue(params, "baud_rate", MxS64CONST(0x9600), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,uart_enable(!!GetParameterValue(params, "uart_enable", MxS64CONST(0x0), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,untimed_fifos(!!GetParameterValue(params, "untimed_fifos", MxS64CONST(0x1), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,out_file(GetParameterValue(params, "out_file", ""))
	,in_file(GetParameterValue(params, "in_file", ""))
	,unbuffered_output(!!GetParameterValue(params, "unbuffered_output", MxS64CONST(0x0), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,in_file_escape_sequence(GetParameterValue(params, "in_file_escape_sequence", "##"))
	,shutdown_on_eot(!!GetParameterValue(params, "shutdown_on_eot", MxS64CONST(0x0), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,shutdown_tag(GetParameterValue(params, "shutdown_tag", ""))


	,cadiParameterProxy_busslave_of_PVBusSlave_to_PL011_Uart__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "ARM PrimeCell UART(PL011)";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PL011_Uart_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockDivider_factory = ClockDivider_GetFactory();
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_busslave__ = params.getParamsFor("busslave");
			params_busslave__["size"] = MxU64CONST(0x0000000000001000);
			add(busslave = PVBusSlave_factory->instantiate("busslave", simulationContext, params_busslave__));
		}
		{
			sg::Params params_clk_divider__ = params.getParamsFor("clk_divider");
			add(clk_divider = ClockDivider_factory->instantiate("clk_divider", simulationContext, params_clk_divider__));
		}
		{
			sg::Params params_timer__ = params.getParamsFor("timer");
			add(timer = ClockTimer_factory->instantiate("timer", simulationContext, params_timer__));
		}
		ClockDivider_factory->dereference();
		ClockTimer_factory->dereference();
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PL011_Uart::control_port__configure, this);
    bind_method(control_port, init, &Component__PL011_Uart::init, this);
    bind_method(control_port, interconnect, &Component__PL011_Uart::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PL011_Uart::postConnect, this);
    bind_method(control_port, reset, &Component__PL011_Uart::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PL011_Uart::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PL011_Uart::disconnect, this);
    bind_method(control_port, terminate, &Component__PL011_Uart::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PL011_Uart::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PL011_Uart::refresh, this);
    bind_method(control_port, step, &Component__PL011_Uart::step, this);
    bind_method(control_port, update, &Component__PL011_Uart::update, this);
    bind_method(control_port, communicate, &Component__PL011_Uart::communicate, this);
    bind_method(control_port, getProperty, &Component__PL011_Uart::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PL011_Uart::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PL011_Uart::control_port__bypass, this);
    bind_method(control_port, run, &Component__PL011_Uart::control_port__run, this);
    bind_method(control_port, stop, &Component__PL011_Uart::control_port__stop, this);
    bind_method(control_port, idle, &Component__PL011_Uart::control_port__idle, this);
    bind_method(control_port, quit, &Component__PL011_Uart::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PL011_Uart::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PL011_Uart::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PL011_Uart::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PL011_Uart::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PL011_Uart::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PL011_Uart::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PL011_Uart::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PL011_Uart::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_busslave__.connectTo(busslave->findPort("$control"));
	controlPort_clk_divider__.connectTo(clk_divider->findPort("$control"));
	controlPort_timer__.connectTo(timer->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(timer_callback_handler, signal, &Component__PL011_Uart::abstract_port__timer_callback_handler__signal, this);
	bind_method(device, read, &Component__PL011_Uart::abstract_port__device__read, this);
	bind_method(device, write, &Component__PL011_Uart::abstract_port__device__write, this);
	bind_method(device, debugRead, &Component__PL011_Uart::abstract_port__device__debugRead, this);
	bind_method(device, debugWrite, &Component__PL011_Uart::abstract_port__device__debugWrite, this);


    // add abstract ports
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	publishMasterPort("serial_out", serial_out);
	serial_out.SetName__("serial_out");
	publishSlavePort("clk_in_ref", clk_in_ref);
	clk_in_ref.SetName__("clk_in_ref");
	publishMasterPort("intr", intr);
	intr.SetName__("intr");
	timer_callback_handler.SetName__("timer_callback_handler");
	device.SetName__("device");
	__PL011_Uart_internal_1.SetName__("__PL011_Uart_internal_1");
	__PL011_Uart_internal_2.SetName__("__PL011_Uart_internal_2");
	__PL011_Uart_internal_3.SetName__("__PL011_Uart_internal_3");


    // wire up static connection map
	clk_in_ref.connectTo(clk_divider->findPort("clk_in"));
	clk_divider->findPort("clk_out").connectTo(timer->findPort("clk_in"));
	timer->findPort("timer_callback").connectTo(timer_callback_handler);
	pvbus.connectTo(busslave->findPort("pvbus_s"));
	busslave->findPort("device").connectTo(device);
	__PL011_Uart_internal_1.connectTo(clk_divider->findPort("rate"));
	__PL011_Uart_internal_2.connectTo(clk_divider->findPort("clk_out"));
	__PL011_Uart_internal_3.connectTo(timer->findPort("timer_control"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PL011_Uart::~Component__PL011_Uart()
{
}

void Component__PL011_Uart::control_port__configure(const sg::Params& params)
{
	if(controlPort_busslave__.configure.implemented()) controlPort_busslave__.configure(params.getParamsFor("busslave"));
	if(controlPort_clk_divider__.configure.implemented()) controlPort_clk_divider__.configure(params.getParamsFor("clk_divider"));
	if(controlPort_timer__.configure.implemented()) controlPort_timer__.configure(params.getParamsFor("timer"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PL011_Uart_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PL011_Uart::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busslave__.populateCADIMap.implemented())
			{
				controlPort_busslave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("busslave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_busslave_of_PVBusSlave_to_PL011_Uart__ = new CADIParameterProxy(cadi, &parameterFilter_busslave_of_PVBusSlave_to_PL011_Uart__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clk_divider__.populateCADIMap.implemented())
			{
				controlPort_clk_divider__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_timer__.populateCADIMap.implemented())
			{
				controlPort_timer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PL011_Uart::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PL011_Uart::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PL011_Uart::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PL011_Uart::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PL011_Uart::control_port__run()
{
}


void Component__PL011_Uart::control_port__stop()
{
}


void Component__PL011_Uart::control_port__idle()
{
}


void Component__PL011_Uart::control_port__quit()
{
}


void Component__PL011_Uart::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PL011_Uart::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PL011_Uart::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PL011_Uart::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PL011_Uart::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PL011_Uart::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_busslave_of_PVBusSlave_to_PL011_Uart__;
	cadiParameterProxy_busslave_of_PVBusSlave_to_PL011_Uart__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PL011_Uart::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PL011_Uart::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PL011_Uart::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PL011_Uart::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_clock_rate: *data = clock_rate; break;
	case PARAMETER_ID_baud_rate: *data = baud_rate; break;
	case PARAMETER_ID_uart_enable: *data = uart_enable; break;
	case PARAMETER_ID_untimed_fifos: *data = untimed_fifos; break;
	case PARAMETER_ID_unbuffered_output: *data = unbuffered_output; break;
	case PARAMETER_ID_shutdown_on_eot: *data = shutdown_on_eot; break;

        default:
            printf("error: Component__PL011_Uart::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL011_Uart::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {
	case PARAMETER_ID_out_file:  data = out_file; break;
	case PARAMETER_ID_in_file:  data = in_file; break;
	case PARAMETER_ID_in_file_escape_sequence:  data = in_file_escape_sequence; break;
	case PARAMETER_ID_shutdown_tag:  data = shutdown_tag; break;

        default:
            printf("error: Component__PL011_Uart::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL011_Uart::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_clock_rate:
		{
			*(const_cast<uint32_t*>(&clock_rate)) = *data;
		}
		break;
	case PARAMETER_ID_baud_rate:
		{
			*(const_cast<uint32_t*>(&baud_rate)) = *data;
		}
		break;
	case PARAMETER_ID_uart_enable:
		{
			*(const_cast<bool*>(&uart_enable)) = !!*data;
		}
		break;
	case PARAMETER_ID_untimed_fifos:
		{
			*(const_cast<bool*>(&untimed_fifos)) = !!*data;
		}
		break;
	case PARAMETER_ID_unbuffered_output:
		{
			*(const_cast<bool*>(&unbuffered_output)) = !!*data;
		}
		break;
	case PARAMETER_ID_shutdown_on_eot:
		{
			*(const_cast<bool*>(&shutdown_on_eot)) = !!*data;
		}
		break;

        default:
            printf("error: Component__PL011_Uart::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL011_Uart::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {
	case PARAMETER_ID_out_file:
		{
			*(const_cast<std::string*>(&out_file)) = data;
		}
		break;
	case PARAMETER_ID_in_file:
		{
			*(const_cast<std::string*>(&in_file)) = data;
		}
		break;
	case PARAMETER_ID_in_file_escape_sequence:
		{
			*(const_cast<std::string*>(&in_file_escape_sequence)) = data;
		}
		break;
	case PARAMETER_ID_shutdown_tag:
		{
			shutdown_tag = data;
		}
		break;

        default:
            printf("error: Component__PL011_Uart::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PL011_Uart::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PL011_Uart::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PL011_Uart::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PL011_Uart::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PL011_Uart::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PL011_Uart::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PL011_Uart::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PL011_Uart::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PL011_Uart::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "clock_rate") id = PARAMETER_ID_clock_rate;
    if (name == "baud_rate") id = PARAMETER_ID_baud_rate;
    if (name == "uart_enable") id = PARAMETER_ID_uart_enable;
    if (name == "untimed_fifos") id = PARAMETER_ID_untimed_fifos;
    if (name == "out_file") id = PARAMETER_ID_out_file;
    if (name == "in_file") id = PARAMETER_ID_in_file;
    if (name == "unbuffered_output") id = PARAMETER_ID_unbuffered_output;
    if (name == "in_file_escape_sequence") id = PARAMETER_ID_in_file_escape_sequence;
    if (name == "shutdown_on_eot") id = PARAMETER_ID_shutdown_on_eot;
    if (name == "shutdown_tag") id = PARAMETER_ID_shutdown_tag;

    return id;
}

void Component__PL011_Uart::reset_resources__()
{
    // resource initialization code
	UARTDR = 0; // reset register
	UARTRSR = 0; // reset register
	UARTFR = 0; // reset register
	UARTIBRD = 0; // reset register
	UARTFBRD = 0; // reset register
	UARTLCR_H = 0; // reset register
	UARTCR = 0; // reset register
	UARTIFLS = 0; // reset register
	UARTIMSC = 0; // reset register
	UARTRIS = 0; // reset register
	UARTMIS = 0; // reset register
	UARTICR = 0; // reset register
	for(int loop0=0; loop0<4; loop0++) {
		UARTPeriphID[loop0] = 0; // reset register
	}
	for(int loop0=0; loop0<4; loop0++) {
		UARTCellID[loop0] = 0; // reset register
	}

}


} // FVP_VE_Cortex_A15x1_NMS
#line 101 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::init()
{
 {if(!controlPort_busslave__.init.empty()) controlPort_busslave__.init();if(!controlPort_timer__.init.empty()) controlPort_timer__.init();};
 common_reset();
 
}
}

#line 108 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::reset(int level)
{
 {if(!controlPort_busslave__.reset.empty()) controlPort_busslave__.reset(level);if(!controlPort_timer__.reset.empty()) controlPort_timer__.reset(level);};
 common_reset();
 __PL031_RTC_internal_1.cancel();
 update_rtc_interrupt();
 
}
}

#line 116 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::common_reset()
{
 RTCDR = 0;
 RTCMR = 0;
 RTCLR = 0;
 RTCCR = 0;
 RTCIMSC = 0;
 RTCRIS = 0;
 RTCMIS = 0;
 
}
}

#line 127 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::update_rtc_interrupt()
{
 RTCMIS = RTCRIS & RTCIMSC;
 if (RTCMIS != 0)
 {
 if (intr.setValue.implemented())
 intr.setValue(sg::Signal::Set);
 }
 else
 {
 if (intr.setValue.implemented())
 intr.setValue(sg::Signal::Clear);
 }
 
}
}

#line 142 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL031_RTC::registerRead(uint32_t addr)
{
 uint32_t data = 0;
 switch (addr) 
 {
 case 0x00: 
 data = RTCDR; 
 
 if (!0) ; else printf("%s: RTCDR -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x04: 
 data = RTCMR; 
 
 if (!0) ; else printf("%s: RTCMR -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x08: 
 data = RTCLR; 
 
 if (!0) ; else printf("%s: RTCLR -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x0c: 
 data = RTCCR; 
 
 if (!0) ; else printf("%s: RTCCR -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x10: 
 data = RTCIMSC; 
 
 if (!0) ; else printf("%s: RTCIMSC -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x14: 
 data = RTCRIS; 
 
 if (!0) ; else printf("%s: RTCRIS -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x18: 
 data = RTCMIS; 
 
 if (!0) ; else printf("%s: RTCMIS -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x1c: 
 if (!0) ; else printf("%s: RTCICR -> (Write Only)\n", getInstanceName().c_str());
 break;
 
 
 
 case 0xfe0: return 0x00000031; 
 case 0xfe4: return 0x00000010; 
 case 0xfe8: return 0x00000004; 
 case 0xfec: return 0x00000000; 
 
 case 0xff0: return 0x0000000d; 
 case 0xff4: return 0x000000f0; 
 case 0xff8: return 0x00000005; 
 case 0xffc: return 0x000000b1; 
 
 default:
 if (!0) ; else printf("%s: Read from unimplemented register at 0x%x\n", getInstanceName().c_str(), addr);
 break;
 }
 return data;
 
}
}

#line 212 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::registerWrite(uint32_t addr, uint32_t data)
{
 switch (addr) 
 {
 case 0x00: 
 if (!0) ; else printf("%s: RTCDR <- 0x%x (Read Only)\n", getInstanceName().c_str(), data);
 break;
 
 case 0x04: 
 if (!0) ; else printf("%s: RTCMR <- 0x%x\n", getInstanceName().c_str(), data);
 
 RTCMR = data;
 break;
 
 case 0x08:
 if (!0) ; else printf("%s: RTCLR <- 0x%x\n", getInstanceName().c_str(), data);
 
 RTCLR = data;
 RTCDR = data;
 break;
 
 case 0x0c:
 if (!0) ; else printf("%s: RTCCR <- 0x%x\n", getInstanceName().c_str(), data);
 
 
 if (data & 1)
 {
 if (RTCCR != 1)
 {
 RTCCR = 1;
 __PL031_RTC_internal_1.set(1);
 }
 }
 break;
 
 case 0x10:
 if (!0) ; else printf("%s: RTCIMSC <- 0x%x\n", getInstanceName().c_str(), data);
 
 RTCIMSC = data & 1;
 
 update_rtc_interrupt();
 break;
 
 case 0x014:
 if (!0) ; else printf("%s: RTCRIS <- 0x%x (Read Only)\n", getInstanceName().c_str(), data);
 break;
 
 case 0x018:
 if (!0) ; else printf("%s: RTCMIS <- 0x%x (Read Only)\n", getInstanceName().c_str(), data); 
 break;
 
 case 0x01c:
 if (!0) ; else printf("%s: RTCICR <- 0x%x\n", getInstanceName().c_str(), data);

 if (data & 1)
 {
 RTCRIS = 0;
 update_rtc_interrupt();
 }
 break;
 
 default: 
 if (!0) ; else printf("%s: write to unimplemented register at 0x%x <- 0x%x\n", getInstanceName().c_str(), addr, data);
 break;
 }
 
}
}

#line 280 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL031_RTC::debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects)
{
 *datap = registerRead(reg_id);
 
 return ACCESS_FUNC_OK;
 
}
}

#line 287 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL031_RTC::debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects)
{
 registerWrite(reg_id, (uint32_t)*datap);
 
 return ACCESS_FUNC_OK;
 
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::interconnect()
{{if(!controlPort_busslave__.interconnect.empty()) controlPort_busslave__.interconnect();if(!controlPort_timer__.interconnect.empty()) controlPort_timer__.interconnect();};
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::disconnect()
{{if(!controlPort_busslave__.disconnect.empty()) controlPort_busslave__.disconnect();if(!controlPort_timer__.disconnect.empty()) controlPort_timer__.disconnect();};
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::update()
{{if(!controlPort_busslave__.update.empty()) controlPort_busslave__.update();if(!controlPort_timer__.update.empty()) controlPort_timer__.update();};
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::communicate()
{{if(!controlPort_busslave__.communicate.empty()) controlPort_busslave__.communicate();if(!controlPort_timer__.communicate.empty()) controlPort_timer__.communicate();};
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::traceEndOfCycle()
{{if(!controlPort_busslave__.traceEndOfCycle.empty()) controlPort_busslave__.traceEndOfCycle();if(!controlPort_timer__.traceEndOfCycle.empty()) controlPort_timer__.traceEndOfCycle();};
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::loadApplicationFile(const std::string& filename)
{{if(!controlPort_busslave__.loadApplicationFile.empty()) controlPort_busslave__.loadApplicationFile(filename);if(!controlPort_timer__.loadApplicationFile.empty()) controlPort_timer__.loadApplicationFile(filename);};
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::terminate()
{{if(!controlPort_busslave__.terminate.empty()) controlPort_busslave__.terminate();if(!controlPort_timer__.terminate.empty()) controlPort_timer__.terminate();};
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL031_RTC::save(MxODataStream& os)
{{if(!controlPort_busslave__.save.empty()) controlPort_busslave__.save(os);if(!controlPort_timer__.save.empty()) controlPort_timer__.save(os);};return true;
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL031_RTC::restore(MxIDataStream& is)
{{if(!controlPort_busslave__.restore.empty()) controlPort_busslave__.restore(is);if(!controlPort_timer__.restore.empty()) controlPort_timer__.restore(is);};return true;
}
}

#line 7 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL031_RTC::step()
{{if(!controlPort_busslave__.step.empty()) controlPort_busslave__.step();if(!controlPort_timer__.step.empty()) controlPort_timer__.step();};
}
}

#line 45 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL031_RTC::abstract_port__timer_callback_handler__signal()
{
 
 
 RTCDR++;

 if (RTCDR == RTCMR)
 {
 RTCRIS = 1;
 update_rtc_interrupt();
 }
 return 1;
 
}
}

#line 67 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL031_RTC::abstract_port__device__read(pv::ReadTransaction tx)
{
 if (tx.getAccessWidth() > pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 
 return tx.setReturnData32((uint32_t)registerRead((uint32_t)tx.getAddress() & ~3));
 
}
}

#line 74 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL031_RTC::abstract_port__device__write(pv::WriteTransaction tx)
{
 if (tx.getAccessWidth() != pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 registerWrite((uint32_t)tx.getAddress(), tx.getData32());
 return tx.writeComplete();
 
}
}

#line 81 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL031_RTC::abstract_port__device__debugRead(pv::ReadTransaction tx)
{
 return device.read(tx);
 
}
}

#line 86 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL031_RTC.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL031_RTC::abstract_port__device__debugWrite(pv::WriteTransaction tx)
{
 return device.write(tx);
 
}
}

#line 18208 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PL031_RTC
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PL031_RTC::Component__PL031_RTC(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)



	,cadiParameterProxy_busslave_of_PVBusSlave_to_PL031_RTC__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "ARM PrimeCell Real Time Clock(PL031)";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PL031_RTC_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_busslave__ = params.getParamsFor("busslave");
			params_busslave__["size"] = MxU64CONST(0x0000000000001000);
			add(busslave = PVBusSlave_factory->instantiate("busslave", simulationContext, params_busslave__));
		}
		{
			sg::Params params_timer__ = params.getParamsFor("timer");
			add(timer = ClockTimer_factory->instantiate("timer", simulationContext, params_timer__));
		}
		ClockTimer_factory->dereference();
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PL031_RTC::control_port__configure, this);
    bind_method(control_port, init, &Component__PL031_RTC::init, this);
    bind_method(control_port, interconnect, &Component__PL031_RTC::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PL031_RTC::postConnect, this);
    bind_method(control_port, reset, &Component__PL031_RTC::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PL031_RTC::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PL031_RTC::disconnect, this);
    bind_method(control_port, terminate, &Component__PL031_RTC::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PL031_RTC::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PL031_RTC::refresh, this);
    bind_method(control_port, step, &Component__PL031_RTC::step, this);
    bind_method(control_port, update, &Component__PL031_RTC::update, this);
    bind_method(control_port, communicate, &Component__PL031_RTC::communicate, this);
    bind_method(control_port, getProperty, &Component__PL031_RTC::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PL031_RTC::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PL031_RTC::control_port__bypass, this);
    bind_method(control_port, run, &Component__PL031_RTC::control_port__run, this);
    bind_method(control_port, stop, &Component__PL031_RTC::control_port__stop, this);
    bind_method(control_port, idle, &Component__PL031_RTC::control_port__idle, this);
    bind_method(control_port, quit, &Component__PL031_RTC::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PL031_RTC::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PL031_RTC::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PL031_RTC::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PL031_RTC::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PL031_RTC::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PL031_RTC::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PL031_RTC::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PL031_RTC::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_busslave__.connectTo(busslave->findPort("$control"));
	controlPort_timer__.connectTo(timer->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(timer_callback_handler, signal, &Component__PL031_RTC::abstract_port__timer_callback_handler__signal, this);
	bind_method(device, read, &Component__PL031_RTC::abstract_port__device__read, this);
	bind_method(device, write, &Component__PL031_RTC::abstract_port__device__write, this);
	bind_method(device, debugRead, &Component__PL031_RTC::abstract_port__device__debugRead, this);
	bind_method(device, debugWrite, &Component__PL031_RTC::abstract_port__device__debugWrite, this);


    // add abstract ports
	publishMasterPort("intr", intr);
	intr.SetName__("intr");
	publishSlavePort("clock", clock);
	clock.SetName__("clock");
	timer_callback_handler.SetName__("timer_callback_handler");
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	device.SetName__("device");
	__PL031_RTC_internal_1.SetName__("__PL031_RTC_internal_1");


    // wire up static connection map
	clock.connectTo(timer->findPort("clk_in"));
	timer->findPort("timer_callback").connectTo(timer_callback_handler);
	pvbus.connectTo(busslave->findPort("pvbus_s"));
	busslave->findPort("device").connectTo(device);
	__PL031_RTC_internal_1.connectTo(timer->findPort("timer_control"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PL031_RTC::~Component__PL031_RTC()
{
}

void Component__PL031_RTC::control_port__configure(const sg::Params& params)
{
	if(controlPort_busslave__.configure.implemented()) controlPort_busslave__.configure(params.getParamsFor("busslave"));
	if(controlPort_timer__.configure.implemented()) controlPort_timer__.configure(params.getParamsFor("timer"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PL031_RTC_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PL031_RTC::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busslave__.populateCADIMap.implemented())
			{
				controlPort_busslave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("busslave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_busslave_of_PVBusSlave_to_PL031_RTC__ = new CADIParameterProxy(cadi, &parameterFilter_busslave_of_PVBusSlave_to_PL031_RTC__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_timer__.populateCADIMap.implemented())
			{
				controlPort_timer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PL031_RTC::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PL031_RTC::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PL031_RTC::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PL031_RTC::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PL031_RTC::control_port__run()
{
}


void Component__PL031_RTC::control_port__stop()
{
}


void Component__PL031_RTC::control_port__idle()
{
}


void Component__PL031_RTC::control_port__quit()
{
}


void Component__PL031_RTC::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PL031_RTC::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PL031_RTC::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PL031_RTC::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PL031_RTC::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PL031_RTC::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_busslave_of_PVBusSlave_to_PL031_RTC__;
	cadiParameterProxy_busslave_of_PVBusSlave_to_PL031_RTC__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PL031_RTC::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PL031_RTC::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PL031_RTC::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PL031_RTC::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PL031_RTC::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL031_RTC::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL031_RTC::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL031_RTC::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PL031_RTC::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL031_RTC::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL031_RTC::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PL031_RTC::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PL031_RTC::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PL031_RTC::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PL031_RTC::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PL031_RTC::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PL031_RTC::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PL031_RTC::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PL031_RTC::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PL031_RTC::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__PL031_RTC::reset_resources__()
{
    // resource initialization code
	RTCDR = 0; // reset register
	RTCMR = 0; // reset register
	RTCLR = 0; // reset register
	RTCCR = 0; // reset register
	RTCIMSC = 0; // reset register
	RTCRIS = 0; // reset register
	RTCMIS = 0; // reset register

}


} // FVP_VE_Cortex_A15x1_NMS
#line 306 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::ResetRegisters()
{
 rxcr1 = 0x0;
 txcr1 = 0x0;
 sr1 = 0x0b;
 isr1 = 0x0;
 ie1 = 0x0;
 
 rxcr2 = 0x0;
 txcr2 = 0x0;
 sr2 = 0x0b;
 isr2 = 0x0;
 ie2 = 0x0;
 
 rxcr3 = 0x0;
 txcr3 = 0x0;
 sr3 = 0x0b;
 isr3 = 0x0;
 ie3 = 0x0;
 
 rxcr4 = 0x0;
 txcr4 = 0x0;
 sr4 = 0x0b;
 isr4 = 0x0;
 ie4 = 0x0; 
 
 sl1rx = 0x0;
 sl1tx = 0x0;
 sl2rx = 0x0;
 sl2tx = 0x0;
 sl12rx = 0x0;
 sl12tx = 0x0;
 
 slfr = 0x0a80;
 slistat = 0; 
 slien = 0;
 maincr = 0;
 rst = 1;
 sync = 1;
 mainfr = 0x0;
 
}
}

#line 348 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::resetLM4549Registers()
{
 masterVol = 0x8000;
 auxVol = 0x8000;
 monoVol = 0x8000;
 beepVol = 0x0000;
 phoneVol = 0x8008;
 micVol = 0x8008;
 lineVol = 0x8808;
 cdVol = 0x8808;
 videoVol = 0x8808;
 auxinVol = 0x8808;
 pcmVol = 0x8808;
 recSel = 0x0000;
 recGain = 0x8000;
 gen = 0x0000;
 pdctrl = 0x000F;
 eaid = 0x0001;
 eactrl = 0x0000;
 pcmDACRate = 0xBB80;
 pcmADCRate = 0xBB80;
 
}
}

#line 371 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::updateInterrupts()
{
 
 
 
 
 bool signal = ((isr1 & ie1) != 0) ||
 ((isr2 & ie2) != 0) ||
 ((isr3 & ie3) != 0) ||
 ((isr4 & ie4) != 0);
 
 
 signal = (signal || ((slistat & slien) != 0));
 
 
 if(signal != irq_signal) {
 irq.setValue( (signal) ? sg::Signal::Set : sg::Signal::Clear );
 irq_signal = signal;
 }
 
 
}
}

#line 394 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::setSlot1rx(uint32_t data)
{
 if((maincr & (1<<3)) == (1<<3))
 {
 sl1rx = data;
 slfr |= (1<<6);
 }
 
}
}

#line 404 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::setSlot2rx(uint32_t data)
{
 if((maincr & (1<<5)) == (1<<5))
 {
 sl2rx = data;
 slfr |= (1<<8);
 }
 
}
}

#line 414 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL041_AACI::getSlot2rx()
{
 
 return sl2rx; 
 
}
}

#line 421 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::getSlot2tx(uint32_t* dest)
{
 if((maincr & (1<<6)) == (1<<6))
 {
 *dest = SL2TOVAL(sl2tx); 
 }
 
}
}

#line 429 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::slot1tx()
{
 
 
 
 
 
 
 
 
 if((maincr & (1<<4)) == (1<<4))
 {
 const uint32_t maskedVal = (sl1tx & SL1MASK);
 const bool read = ((sl1tx & SL1READ) == SL1READ);
 bool valid = true;
 
 slfr &= ~(1<<8);
 slfr &= ~(1<<6);
 
 slfr |= (1<<7);
 
 switch(maskedVal)
 { 
 case REGTOSL1(PV_AC97_RESET):
 if(!0) ; else printf("%s","   SL1TX AC97 VendorID 1\n");
 if(read) {
 setSlot2rx(VALTOSL2(PV_LM4519A_RESET));
 } else {
 resetLM4549Registers();
 }
 break;
 case REGTOSL1(PV_AC97_MASTERVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 Master Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(masterVol));
 } else {
 getSlot2tx(&masterVol);
 }
 break;
 case REGTOSL1(PV_AC97_AUXVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 Aux Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(auxVol));
 } else {
 getSlot2tx(&auxVol);
 }
 break;
 case REGTOSL1(PV_AC97_MONOVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 Mono Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(auxVol));
 } else {
 getSlot2tx(&auxVol);
 }
 break;
 case REGTOSL1(PV_AC97_BEEPVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 BEEP Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(beepVol));
 } else {
 getSlot2tx(&beepVol);
 }
 break;
 case REGTOSL1(PV_AC97_PHONEVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 Phone Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(phoneVol));
 } else {
 getSlot2tx(&phoneVol);
 }
 break;
 case REGTOSL1(PV_AC97_MICVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 Mic Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(micVol));
 } else {
 getSlot2tx(&micVol);
 }
 break;
 case REGTOSL1(PV_AC97_LINEVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 Line Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(lineVol));
 } else {
 getSlot2tx(&lineVol);
 }
 break;
 case REGTOSL1(PV_AC97_CDVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 CD Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(cdVol));
 } else {
 getSlot2tx(&cdVol);
 }
 break;
 case REGTOSL1(PV_AC97_VIDEOVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 Video Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(videoVol));
 } else {
 getSlot2tx(&videoVol);
 }
 break;
 case REGTOSL1(PV_AC97_AUXINVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 Aux in Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(auxinVol));
 } else {
 getSlot2tx(&auxinVol);
 }
 break;
 case REGTOSL1(PV_AC97_PCMVOL):
 if(!0) ; else printf("%s","   SL1TX AC97 PCM Volume\n");
 if(read) {
 setSlot2rx(VALTOSL2(pcmVol));
 } else {
 getSlot2tx(&pcmVol);
 }
 break;
 case REGTOSL1(PV_AC97_RECSEL):
 if(!0) ; else printf("%s","   SL1TX AC97 Record Select\n");
 if(read) {
 setSlot2rx(VALTOSL2(recVol));
 } else {
 getSlot2tx(&recVol);
 }
 break;
 case REGTOSL1(PV_AC97_RECGAIN):
 if(!0) ; else printf("%s","   SL1TX AC97 Record Gain\n");
 if(read) {
 setSlot2rx(VALTOSL2(recGain));
 } else {
 getSlot2tx(&recGain);
 }
 break;
 case REGTOSL1(PV_AC97_GEN):
 if(!0) ; else printf("%s","   SL1TX AC97 General Purpose\n");
 if(read) {
 setSlot2rx(VALTOSL2(gen));
 } else {
 getSlot2tx(&gen);
 }
 break;
 case REGTOSL1(PV_AC97_3DCTRL):
 if(!0) ; else printf("%s","   SL1TX AC97 3DCTRL\n");
 if(read) {
 setSlot2rx(VALTOSL2(PV_LM4519A_3DCTL));
 }
 break;
 case REGTOSL1(PV_AC97_PDCTRL):
 if(!0) ; else printf("%s","   SL1TX AC97 PowerDown Control\n");
 if(read) {
 
 
 
 setSlot2rx(VALTOSL2(PV_LM4519A_PDCTRL));
 } else {
 getSlot2tx(&pdctrl);
 }
 break;
 case REGTOSL1(PV_AC97_EXTAUDID):
 if(!0) ; else printf("%s","   SL1TX AC97 Extended Audio ID\n");
 if(read) {
 setSlot2rx(VALTOSL2(PV_LM4519A_EXTID));
 }
 break;
 case REGTOSL1(PV_AC97_EXTAUDCTRL):
 if(!0) ; else printf("%s","   SL1TX AC97 Extended Audio Control\n");
 if(read) {
 setSlot2rx(VALTOSL2(eactrl));
 } else {
 getSlot2tx(&eactrl);
 } 
 break;
 case REGTOSL1(PV_AC97_PCMFDACRATE):
 if(!0) ; else printf("%s","   SL1TX AC97 PCM Front DAC Rate\n");
 if(read) {
 setSlot2rx(VALTOSL2(pcmDACRate));
 } else {
 
 
 
 
 
 }
 break;
 case REGTOSL1(PV_AC97_PCMLRADCRATE):
 if(!0) ; else printf("%s","   SL1TX AC97 PCM ADC Rate\n");
 if(read) {
 setSlot2rx(VALTOSL2(pcmADCRate));
 } else {
 getSlot2tx(&pcmADCRate);
 }
 break;
 case REGTOSL1(PV_AC97_VID1):
 if(!0) ; else printf("%s","   SL1TX AC97 VendorID 1\n");
 if(read) {
 setSlot2rx(VALTOSL2(PV_LM4519A_VID1));
 }
 break;
 case REGTOSL1(PV_AC97_VID2):
 if(!0) ; else printf("%s","   SL1TX AC97 VendorID 2\n");
 if(read) {
 setSlot2rx(VALTOSL2(PV_LM4519A_VID2));
 }
 break;
 default:
 if(!0) ; else printf("%s %x\n","   SL1TX Unsupported register", SL1TOREG(maskedVal));
 valid = false;
 }
 
 if(valid) {
 setSlot1rx(maskedVal);
 } else {
 
 if(read) {
 setSlot1rx(maskedVal);
 setSlot2rx(0x0);
 }
 }
 
 }
 else
 {
 if(!0) ; else printf("%s\n","   WARNING SL1TXEN not enabled");
 }
 
 
}
}

#line 658 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::handleIntClr(uint32_t data)
{
 if((data & (1<<5)) == (1<<5))
 {
 sr1 &= ~(1<<9);
 isr1 &= ~(1<<5);
 }
 
 updateInterrupts();
 
}
}

#line 669 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::handleMainCR(uint32_t newValue)
{
 
 
 if(((maincr & (1<<0)) == 0) && ((newValue & (1<<0)) == (1<<0)))
 {
 audioBuf->reset();
 if (isRunning)
 {
 audioBuf->start();
 }
 }
 
}
}

#line 683 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::updateFIFO1(uint32_t sim_ms)
{
 const size_t buflevel = audioBuf->getLevel(sim_ms);
 
 if(!0) ; else printf("AACI BUFLEVEL %lu\n",(long unsigned)buflevel);
 
 if(buflevel == 0)
 {
 
 sr1 &= ~(1<<5);
 sr1 |= (1<<1);
 isr1 |= (1<<0);
 
 
 sr1 |= (1<<3);
 isr1 |= (1<<2);
 }
 else
 { 
 
 sr1 &= ~(1<<1);
 isr1 &= ~(1<<0);
 
 if(buflevel >= effectiveDepth)
 {
 
 sr1 |= (1<<5);
 
 sr1 &= ~(1<<3);
 isr1 &= ~(1<<2);
 
 }
 else
 {
 
 sr1 &= ~(1<<5);
 if(buflevel < effectiveHalfDepth)
 {
 sr1 |= (1<<3);
 isr1 |= (1<<2);
 
 }
 else
 {
 sr1 &= ~(1<<3);
 isr1 &= ~(1<<2);
 
 }
 }
 }
 
}
}

#line 735 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::writeFIFO1(uint32_t data)
{
 if(isStereo)
 {
 if(isCompact)
 {
 const int16_t sd0 = (int16_t)(data & 0xFFFF);
 const int16_t sd1 = (int16_t)((data >> 16) & 0xFFFF);
 
 switch(txcr1 & (0x3<<13))
 {
 case (0x0<<13):
 audioBuf->write(sd0,sd1);
 break;
 case (0x3<<13):
 audioBuf->write(sd0 << 4,sd1 << 4);
 break;
 case (0x1<<13):
 
 assert(false);
 break;
 case (0x2<<13):
 
 assert(false);
 break;
 }
 }
 else
 {
 int32_t sd0 = (int32_t)data;
 
 switch(txcr1 & (0x3<<13))
 {
 case (0x3<<13):
 sd0 = sd0 << 4;
 break;
 case (0x1<<13):
 sd0 = sd0 >> 2;
 break;
 case (0x2<<13):
 sd0 = sd0 >> 4;
 break;
 }
 
 if(isWrite)
 {
 audioBuf->write(prevSample,(int16_t)sd0);
 isWrite = false;
 }
 else
 {
 prevSample = (int16_t)sd0;
 isWrite = true;
 }
 }
 }
 else
 {
 if(isCompact)
 {
 const int16_t sd0 = (int16_t)(data & 0xFFFF);
 const int16_t sd1 = (int16_t)((data >> 16) & 0xFFFF);
 
 switch(txcr1 & (0x3<<13))
 {
 case (0x0<<13):
 audioBuf->write(sd0,sd0);
 audioBuf->write(sd1,sd1);
 break;
 case (0x3<<13):
 audioBuf->write(sd0 << 4,sd0 << 4);
 audioBuf->write(sd1 << 4,sd1 << 4);
 break;
 case (0x1<<13):
 
 assert(false);
 break;
 case (0x2<<13):
 
 assert(false);
 break;
 }
 }
 else
 {
 const int32_t sd0 = (int32_t)data;
 
 switch(txcr1 & (0x3<<13))
 {
 case (0x0<<13):
 audioBuf->write(sd0,sd0);
 break;
 case (0x3<<13):
 audioBuf->write(sd0 << 4,sd0 << 4);
 break;
 case (0x1<<13):
 audioBuf->write(sd0 >> 2,sd0 >> 2);
 break;
 case (0x2<<13):
 audioBuf->write(sd0 >> 4,sd0 >> 4);
 break;
 }
 }
 }
 
}
}

#line 842 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::init()
{
 depth = 512;
 audioBuf = NULL;
 effectiveDepth = depth/2;
 effectiveHalfDepth = depth/4;
 isWrite = false;
 isRunning = false;
 irq_signal = false; 
 ResetRegisters();
 {if(!controlPort_busslave__.init.empty()) controlPort_busslave__.init();if(!controlPort_timer__.init.empty()) controlPort_timer__.init();};
 
}
}

#line 855 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::terminate()
{
 
 {if(!controlPort_busslave__.terminate.empty()) controlPort_busslave__.terminate();if(!controlPort_timer__.terminate.empty()) controlPort_timer__.terminate();};
 
}
}

#line 861 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::reset(int level)
{
 {if(!controlPort_busslave__.reset.empty()) controlPort_busslave__.reset(level);if(!controlPort_timer__.reset.empty()) controlPort_timer__.reset(level);};
 if(audioBuf != NULL)
 {
 audio.releasePVAudioBuffer(audioBuf);
 }
 audioBuf = audio.getPVAudioBuffer((uint32_t)effectiveDepth);
 
 isWrite = false;
 isRunning = false;
 
 ResetRegisters();
 updateControl1();
 
}
}

#line 877 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::updateControl1()
{
 const bool threeEn = ((txcr1 & (1<<3)) == (1<<3));
 const bool fourEn = ((txcr1 & (1<<4)) == (1<<4));
 const bool other = ((txcr1 & (1<<1)) == (1<<1)) ||
 ((txcr1 & (1<<2)) == (1<<2)) ||
 ((txcr1 & (1<<1)) == (1<<4)) ||
 ((txcr1 & (1<<2)) == (1<<5)) ||
 ((txcr1 & (1<<1)) == (1<<6)) ||
 ((txcr1 & (1<<2)) == (1<<7)) ||
 ((txcr1 & (1<<1)) == (1<<9)) ||
 ((txcr1 & (1<<2)) == (1<<10)) ||
 ((txcr1 & (1<<1)) == (1<<11)) ||
 ((txcr1 & (1<<2)) == (1<<12));
 
 isStereo = (threeEn && fourEn);
 
 isCompact = ((txcr1 & (1<<15)) == (1<<15));
 
 if(isCompact)
 {
 if(!0) ; else printf("Using: COMPACT FIFO ");
 }
 else
 {
 if(!0) ; else printf("Using: NORMAL FIFO ");
 }
 
 isLegal = (threeEn || fourEn) && !other;
 
 
 
 
 
 
 size_t newEffectiveDepth;
 
 if(isStereo)
 {
 newEffectiveDepth = depth/2;
 if(!0) ; else printf("Stereo\n");
 }
 else
 {
 newEffectiveDepth = depth;
 if(!0) ; else printf("Mono\n");
 }
 
 if(newEffectiveDepth != effectiveDepth)
 {
 effectiveDepth = newEffectiveDepth;
 effectiveHalfDepth = effectiveDepth/2;
 
 if(!0) ; else printf("Effective: %lu Half: %lu\n",
 (unsigned long)effectiveDepth,
 (unsigned long)effectiveHalfDepth);
 
 audioBuf->changeDepth(effectiveDepth);
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 sampleDelta = uint32_t(effectiveDepth / 64 );
 tDelta = sampleDelta * 520;
 }
 
}
}

#line 958 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL041_AACI::registerRead(pv::bus_addr_t device_addr)
{ 
 if(!0) ; else printf("AACI READ %x ",(uint32_t)device_addr);
 switch(device_addr)
 {
 case 0x000: 
 if(!0) ; else printf("%s %08x\n","RXCR1", rxcr1);
 return rxcr1;
 case 0x004: 
 if(!0) ; else printf("%s %08x\n","TXCR1",txcr1);
 return txcr1;
 case 0x008: 
 updateFIFO1(0);
 if(!0) ; else printf("%s %08x\n","SR1",sr1);
 return sr1; 
 case 0x00c: 
 updateFIFO1(0);
 if(!0) ; else printf("%s %08x\n","ISR1",(isr1 & ie1));
 return (isr1 & ie1);
 case 0x010: 
 if(!0) ; else printf("%s %08x\n","IE1",ie1);
 return ie1;
 case 0x014: 
 if(!0) ; else printf("%s %08x\n","RXCR1",rxcr2);
 return rxcr2;
 case 0x018: 
 if(!0) ; else printf("%s %08x\n","TXCR2",txcr2);
 return txcr2;
 case 0x01c: 
 if(!0) ; else printf("%s %08x\n","SR2",sr2);
 return sr2;
 case 0x020: 
 if(!0) ; else printf("%s %08x\n","ISR2",(isr2 & ie2));
 return (isr2 & ie2);
 case 0x024: 
 if(!0) ; else printf("%s %08x\n","IE2",ie2);
 return ie2;
 case 0x028: 
 if(!0) ; else printf("%s %08x\n","RXCR3",rxcr3);
 return rxcr3;
 case 0x02c: 
 if(!0) ; else printf("%s %08x\n","TXCR3",txcr3);
 return txcr3;
 case 0x030: 
 if(!0) ; else printf("%s %08x\n","SR3",sr3);
 return sr3;
 case 0x034: 
 if(!0) ; else printf("%s %08x\n","ISR3",(isr3 & ie3));
 return (isr3 & ie3);
 case 0x038: 
 if(!0) ; else printf("%s %08x\n","IE3",ie3);
 return ie3;
 case 0x03c: 
 if(!0) ; else printf("%s %08x\n","RXCR4",rxcr4);
 return rxcr4;
 case 0x040: 
 if(!0) ; else printf("%s %08x\n","TXCR4",txcr4);
 return txcr4;
 case 0x044: 
 if(!0) ; else printf("%s %08x\n","SR4",sr4);
 return sr4;
 case 0x048: 
 if(!0) ; else printf("%s %08x\n","ISR4",(isr4 & ie4));
 return (isr4 & ie4);
 case 0x04c: 
 if(!0) ; else printf("%s %08x\n","IE4",ie4);
 return ie4;
 case 0x050: 
 if(!0) ; else printf("%s %08x\n","SL1RX",sl1rx);
 return sl1rx;
 case 0x054: 
 if(!0) ; else printf("%s %08x\n","SL1TX",sl1tx);
 return sl1tx;
 case 0x058: 
 if(!0) ; else printf("%s %08x\n","SL2RX",sl2rx);
 return (getSlot2rx());
 case 0x05c: 
 if(!0) ; else printf("%s %08x\n","SL2TX",sl2tx);
 return sl2tx;
 case 0x060: 
 if(!0) ; else printf("%s %08x\n","SL12RX",sl12rx);
 return sl12rx;
 case 0x064: 
 if(!0) ; else printf("%s %08x\n","SL12TX",sl12tx);
 return sl12tx;
 case 0x068: 
 if(!0) ; else printf("%s %08x\n","SLFR",slfr);
 return slfr;
 case 0x06c: 
 if(!0) ; else printf("%s %08x\n","SLISTAT",(slistat & slien));
 return (slistat & slien);
 case 0x070: 
 if(!0) ; else printf("%s %08x\n","SLIEN",slien);
 return slien;
 case 0x074: 
 if(!0) ; else printf("%s\n","*** READING WRITE ONLY REGISTER ***");
 return 0;
 case 0x078: 
 if(!0) ; else printf("%s %08x\n","MAINCR",maincr);
 return maincr;
 case 0x07C: 
 if(!0) ; else printf("%s %08x\n","RESET",rst);
 return rst;
 case 0x080: 
 if(!0) ; else printf("%s %08x\n","SYNC",sync);
 return sync;
 case 0x084: 
 {
 const uint32_t allints = (((isr4 & ie4) << 21) |
 ((isr3 & ie3) << 14) |
 ((isr2 & ie2) << 7) |
 (isr1 & ie1) );
 if(!0) ; else printf("%s %08x\n","ALLINTS",allints);
 return allints;
 }
 case 0x088: 
 if(!0) ; else printf("%s %08x\n","MAINFR",mainfr);
 return mainfr;
 
 
 case 0xfe0: 
 if(!0) ; else printf("%s %08x\n","PERIPHID0",0x041);
 return 0x041;
 case 0xfe4: 
 if(!0) ; else printf("%s %08x\n","PERIPHID1",0x010);
 return 0x010; 
 case 0xfe8: 
 if(!0) ; else printf("%s %08x\n","PERIPHID2",0x004);
 return 0x004;
 case 0xfec: 
 if(!0) ; else printf("%s %08x\n","PERIPHID3",0x000);
 return 0x000;
 case 0xff0: 
 if(!0) ; else printf("%s %08x\n","PCELLID0",0x00d);
 return 0x00d;
 case 0xff4: 
 if(!0) ; else printf("%s %08x\n","PCELLID1",0x0f0);
 return 0x0f0;
 case 0xff8: 
 if(!0) ; else printf("%s %08x\n","PCELLID2",0x005);
 return 0x005; 
 case 0xffc: 
 if(!0) ; else printf("%s %08x\n","PCELLID3",0x0b1);
 return 0x0b1; 
 }
 
 if(!0) ; else printf("%s\n", "*** READING UNSUPPORTED REGISTER ***");
 return 0;
 
}
}

#line 1108 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::registerWrite(pv::bus_addr_t device_addr, uint32_t data)
{ 
 if(!0) ; else printf("AACI WRITE %x ",(uint32_t)device_addr);
 switch (device_addr)
 {
 case 0x000: 
 rxcr1 = data;
 if(!0) ; else printf("%s %08x\n","RXCR1", rxcr1);
 break ; 
 case 0x004:
 txcr1 = data;
 if(!0) ; else printf("%s %08x\n","TXCR1",txcr1);
 updateControl1();
 if((txcr1 & (1<<0)) == (1<<0)) {
 
 if(!isRunning)
 {
 isWrite = false;
 if(isLegal)
 {
 isRunning = true;
 audioBuf->start();
 __PL041_AACI_internal_1.set(tDelta);
 }
 }
 } else {
 
 if(isRunning)
 {
 isRunning = false;
 __PL041_AACI_internal_1.cancel();
 audioBuf->stop();
 }
 }
 updateFIFO1(0);
 break; 
 case 0x010:
 ie1 = data;
 if(!0) ; else printf("%s %08x\n","IE1",ie1);
 updateInterrupts();
 break;
 
 case 0x014: 
 rxcr2 = data;
 if(!0) ; else printf("%s %08x\n","RXCR1",rxcr2);
 break; 
 case 0x018:
 txcr2 = data;
 if(!0) ; else printf("%s %08x\n","TXCR2",txcr2);
 break; 
 case 0x024:
 ie2 = data;
 if(!0) ; else printf("%s %08x\n","IE2",ie2);
 break;
 
 case 0x028: 
 rxcr3 = data;
 if(!0) ; else printf("%s %08x\n","RXCR3",rxcr3);
 break ; 
 case 0x02c:
 txcr3 = data;
 if(!0) ; else printf("%s %08x\n","TXCR3",txcr3);
 break; 
 case 0x038:
 ie3 = data;
 if(!0) ; else printf("%s %08x\n","IE3",ie3);
 break;
 
 case 0x03c: 
 rxcr4 = data;
 if(!0) ; else printf("%s %08x\n","RXCR4",rxcr4);
 break ; 
 case 0x040:
 txcr4 = data;
 if(!0) ; else printf("%s %08x\n","TXCR4",txcr4);
 break; 
 case 0x04c:
 ie4 = data;
 if(!0) ; else printf("%s %08x\n","IE4",ie4);
 break; 
 
 case 0x054:
 sl1tx = data;
 if(!0) ; else printf("%s %08x\n","SL1TX",sl1tx);
 slot1tx();
 break;
 case 0x05C:
 sl2tx = data;
 if(!0) ; else printf("%s %08x\n","SL2TX",sl2tx);
 break;
 case 0x064:
 sl12tx = data;
 if(!0) ; else printf("%s %08x\n","SL12TX",sl12tx);
 break;
 
 case 0x068:
 slfr = data;
 if(!0) ; else printf("%s %08x\n","SLFR",slfr);
 break; 
 case 0x070:
 slien = data;
 if(!0) ; else printf("%s %08x\n","SLIEN",slien);
 break;
 case 0x074:
 if(!0) ; else printf("%s %08x\n","ALLINTCLR",data);
 handleIntClr(data);
 break;
 case 0x078:
 handleMainCR(data);
 maincr = data;
 if(!0) ; else printf("%s %08x\n","MAINCR",maincr);
 break; 
 
 case 0x07C:
 rst = data;
 if(!0) ; else printf("%s %08x\n","RESET",rst);
 break; 
 case 0x080:
 sync = data;
 if(!0) ; else printf("%s %08x\n","SYNC",sync);
 break; 
 
 case 0x090:
 case 0x094:
 case 0x098:
 case 0x09C:
 case 0x0A0:
 case 0x0A4:
 case 0x0A8:
 case 0x0AC:
 if(!0) ; else printf("%s %08x\n","DR1",data);
 writeFIFO1(data);
 break;
 
 case 0x0B0:
 case 0x0B4:
 case 0x0B8:
 case 0x0BC:
 case 0x0C0:
 case 0x0C4:
 case 0x0C8:
 case 0x0CC:
 if(!0) ; else printf("%s %08x\n","DR2",data);
 break;
 
 case 0x0D0:
 case 0x0D4:
 case 0x0D8:
 case 0x0DC:
 case 0x0E0:
 case 0x0E4:
 case 0x0E8:
 case 0x0EC:
 if(!0) ; else printf("%s %08x\n","DR3",data);
 break;
 
 case 0x0F0:
 case 0x0F4:
 case 0x0F8:
 case 0x0FC:
 case 0x100:
 case 0x104:
 case 0x108:
 case 0x10C:
 if(!0) ; else printf("%s %08x\n","DR4",data);
 break;
 
 default:
 if(!0) ; else printf("%s\n", "*** WRITING UNSUPPORTED REGISTER ***");
 }
 
}
}

#line 1281 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL041_AACI::debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects)
{
 *datap = registerRead(reg_id);
 
 return ACCESS_FUNC_OK;
 
}
}

#line 1288 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL041_AACI::debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects)
{
 registerWrite(reg_id, (uint32_t)*datap);
 
 return ACCESS_FUNC_OK;
 
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::interconnect()
{{if(!controlPort_busslave__.interconnect.empty()) controlPort_busslave__.interconnect();if(!controlPort_timer__.interconnect.empty()) controlPort_timer__.interconnect();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::disconnect()
{{if(!controlPort_busslave__.disconnect.empty()) controlPort_busslave__.disconnect();if(!controlPort_timer__.disconnect.empty()) controlPort_timer__.disconnect();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::update()
{{if(!controlPort_busslave__.update.empty()) controlPort_busslave__.update();if(!controlPort_timer__.update.empty()) controlPort_timer__.update();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::communicate()
{{if(!controlPort_busslave__.communicate.empty()) controlPort_busslave__.communicate();if(!controlPort_timer__.communicate.empty()) controlPort_timer__.communicate();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::traceEndOfCycle()
{{if(!controlPort_busslave__.traceEndOfCycle.empty()) controlPort_busslave__.traceEndOfCycle();if(!controlPort_timer__.traceEndOfCycle.empty()) controlPort_timer__.traceEndOfCycle();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::loadApplicationFile(const std::string& filename)
{{if(!controlPort_busslave__.loadApplicationFile.empty()) controlPort_busslave__.loadApplicationFile(filename);if(!controlPort_timer__.loadApplicationFile.empty()) controlPort_timer__.loadApplicationFile(filename);};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL041_AACI::save(MxODataStream& os)
{{if(!controlPort_busslave__.save.empty()) controlPort_busslave__.save(os);if(!controlPort_timer__.save.empty()) controlPort_timer__.save(os);};return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL041_AACI::restore(MxIDataStream& is)
{{if(!controlPort_busslave__.restore.empty()) controlPort_busslave__.restore(is);if(!controlPort_timer__.restore.empty()) controlPort_timer__.restore(is);};return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::step()
{{if(!controlPort_busslave__.step.empty()) controlPort_busslave__.step();if(!controlPort_timer__.step.empty()) controlPort_timer__.step();};
}
}

#line 242 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::abstract_port__dma_rx__response(uint32_t response)
{
 
 
}
}

#line 249 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL041_AACI::abstract_port__dma_tx__response(uint32_t response)
{
 
 
}
}

#line 257 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL041_AACI::abstract_port__timer_cbHandler__signal()
{
 if(!0) ; else printf("AACI Timer CallBack Signaled\n");
 updateFIFO1(sampleDelta); 
 updateInterrupts();
 return tDelta;
 
}
}

#line 269 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL041_AACI::abstract_port__device__read(pv::ReadTransaction tx)
{
 if (tx.getAccessWidth() > pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 
 return tx.setReturnData32((uint32_t)registerRead(tx.getAddress() & ~3));
 
}
}

#line 277 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL041_AACI::abstract_port__device__write(pv::WriteTransaction tx)
{
 if (tx.getAccessWidth() != pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 registerWrite(tx.getAddress(),
 tx.getData32());
 return tx.writeComplete();
 
}
}

#line 285 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL041_AACI::abstract_port__device__debugRead(pv::ReadTransaction tx)
{
 return device.read(tx);
 
}
}

#line 290 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL041_AACI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL041_AACI::abstract_port__device__debugWrite(pv::WriteTransaction tx)
{
 return device.write(tx);
 
}
}

#line 19987 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PL041_AACI
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PL041_AACI::Component__PL041_AACI(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)



	,cadiParameterProxy_busslave_of_PVBusSlave_to_PL041_AACI__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "ARM PrimeCell Advanced Audio CODEC Interface(PL041)";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PL041_AACI_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_busslave__ = params.getParamsFor("busslave");
			params_busslave__["size"] = MxU64CONST(0x0000000000001000);
			add(busslave = PVBusSlave_factory->instantiate("busslave", simulationContext, params_busslave__));
		}
		{
			sg::Params params_timer__ = params.getParamsFor("timer");
			add(timer = ClockTimer_factory->instantiate("timer", simulationContext, params_timer__));
		}
		ClockTimer_factory->dereference();
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PL041_AACI::control_port__configure, this);
    bind_method(control_port, init, &Component__PL041_AACI::init, this);
    bind_method(control_port, interconnect, &Component__PL041_AACI::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PL041_AACI::postConnect, this);
    bind_method(control_port, reset, &Component__PL041_AACI::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PL041_AACI::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PL041_AACI::disconnect, this);
    bind_method(control_port, terminate, &Component__PL041_AACI::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PL041_AACI::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PL041_AACI::refresh, this);
    bind_method(control_port, step, &Component__PL041_AACI::step, this);
    bind_method(control_port, update, &Component__PL041_AACI::update, this);
    bind_method(control_port, communicate, &Component__PL041_AACI::communicate, this);
    bind_method(control_port, getProperty, &Component__PL041_AACI::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PL041_AACI::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PL041_AACI::control_port__bypass, this);
    bind_method(control_port, run, &Component__PL041_AACI::control_port__run, this);
    bind_method(control_port, stop, &Component__PL041_AACI::control_port__stop, this);
    bind_method(control_port, idle, &Component__PL041_AACI::control_port__idle, this);
    bind_method(control_port, quit, &Component__PL041_AACI::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PL041_AACI::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PL041_AACI::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PL041_AACI::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PL041_AACI::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PL041_AACI::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PL041_AACI::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PL041_AACI::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PL041_AACI::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_busslave__.connectTo(busslave->findPort("$control"));
	controlPort_timer__.connectTo(timer->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(dma_rx, response, &Component__PL041_AACI::abstract_port__dma_rx__response, this);
	bind_method(dma_tx, response, &Component__PL041_AACI::abstract_port__dma_tx__response, this);
	bind_method(timer_cbHandler, signal, &Component__PL041_AACI::abstract_port__timer_cbHandler__signal, this);
	bind_method(device, read, &Component__PL041_AACI::abstract_port__device__read, this);
	bind_method(device, write, &Component__PL041_AACI::abstract_port__device__write, this);
	bind_method(device, debugRead, &Component__PL041_AACI::abstract_port__device__debugRead, this);
	bind_method(device, debugWrite, &Component__PL041_AACI::abstract_port__device__debugWrite, this);


    // add abstract ports
	publishSlavePort("clk_in_ref", clk_in_ref);
	clk_in_ref.SetName__("clk_in_ref");
	publishMasterPort("audio", audio);
	audio.SetName__("audio");
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	publishMasterPort("irq", irq);
	irq.SetName__("irq");
	publishMasterPort("dma_rx", dma_rx);
	dma_rx.SetName__("dma_rx");
	publishMasterPort("dma_tx", dma_tx);
	dma_tx.SetName__("dma_tx");
	timer_cbHandler.SetName__("timer_cbHandler");
	device.SetName__("device");
	__PL041_AACI_internal_1.SetName__("__PL041_AACI_internal_1");


    // wire up static connection map
	pvbus.connectTo(busslave->findPort("pvbus_s"));
	busslave->findPort("device").connectTo(device);
	clk_in_ref.connectTo(timer->findPort("clk_in"));
	timer->findPort("timer_callback").connectTo(timer_cbHandler);
	__PL041_AACI_internal_1.connectTo(timer->findPort("timer_control"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PL041_AACI::~Component__PL041_AACI()
{
}

void Component__PL041_AACI::control_port__configure(const sg::Params& params)
{
	if(controlPort_busslave__.configure.implemented()) controlPort_busslave__.configure(params.getParamsFor("busslave"));
	if(controlPort_timer__.configure.implemented()) controlPort_timer__.configure(params.getParamsFor("timer"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PL041_AACI_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PL041_AACI::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busslave__.populateCADIMap.implemented())
			{
				controlPort_busslave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("busslave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_busslave_of_PVBusSlave_to_PL041_AACI__ = new CADIParameterProxy(cadi, &parameterFilter_busslave_of_PVBusSlave_to_PL041_AACI__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_timer__.populateCADIMap.implemented())
			{
				controlPort_timer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PL041_AACI::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PL041_AACI::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PL041_AACI::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PL041_AACI::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PL041_AACI::control_port__run()
{
}


void Component__PL041_AACI::control_port__stop()
{
}


void Component__PL041_AACI::control_port__idle()
{
}


void Component__PL041_AACI::control_port__quit()
{
}


void Component__PL041_AACI::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PL041_AACI::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PL041_AACI::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PL041_AACI::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PL041_AACI::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PL041_AACI::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_busslave_of_PVBusSlave_to_PL041_AACI__;
	cadiParameterProxy_busslave_of_PVBusSlave_to_PL041_AACI__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PL041_AACI::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PL041_AACI::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PL041_AACI::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PL041_AACI::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PL041_AACI::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL041_AACI::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL041_AACI::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL041_AACI::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PL041_AACI::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL041_AACI::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL041_AACI::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PL041_AACI::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PL041_AACI::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PL041_AACI::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PL041_AACI::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PL041_AACI::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PL041_AACI::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PL041_AACI::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PL041_AACI::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PL041_AACI::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__PL041_AACI::reset_resources__()
{
    // resource initialization code
	RXCR1 = 0; // reset register
	TXCR1 = 0; // reset register
	SR1 = 0; // reset register
	ISR1 = 0; // reset register
	IE1 = 0; // reset register
	RXCR2 = 0; // reset register
	TXCR2 = 0; // reset register
	SR2 = 0; // reset register
	ISR2 = 0; // reset register
	IE2 = 0; // reset register
	RXCR3 = 0; // reset register
	TXCR3 = 0; // reset register
	SR3 = 0; // reset register
	ISR3 = 0; // reset register
	IE3 = 0; // reset register
	RXCR4 = 0; // reset register
	TXCR4 = 0; // reset register
	SR4 = 0; // reset register
	ISR4 = 0; // reset register
	IE4 = 0; // reset register
	SL1RX = 0; // reset register
	SL1TX = 0; // reset register
	SL2RX = 0; // reset register
	SL2TX = 0; // reset register
	SL12RX = 0; // reset register
	SL12TX = 0; // reset register
	LSFR = 0; // reset register
	SLISTAT = 0; // reset register
	SLIEN = 0; // reset register
	ALLINTCLR = 0; // reset register
	MAINCR = 0; // reset register
	RESET = 0; // reset register
	SYNC = 0; // reset register
	ALLINTS = 0; // reset register
	MAINFR = 0; // reset register

}


} // FVP_VE_Cortex_A15x1_NMS
#line 179 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::init()
{
 {if(!controlPort_clk_divider__.init.empty()) controlPort_clk_divider__.init();if(!controlPort_clk_timer__.init.empty()) controlPort_clk_timer__.init();if(!controlPort_busslave__.init.empty()) controlPort_busslave__.init();};
 stat = 0;
 clkdiv = 0;
 irq = 0;
 
 
}
}

#line 188 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::reset(int level)
{
 {if(!controlPort_clk_divider__.reset.empty()) controlPort_clk_divider__.reset(level);if(!controlPort_clk_timer__.reset.empty()) controlPort_clk_timer__.reset(level);if(!controlPort_busslave__.reset.empty()) controlPort_busslave__.reset(level);};
 device_reset();
 
}
}

#line 196 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::update_kmi_interrupt()
{
 bool new_irq = (ir & irmask) != 0;
 
 if (irq != new_irq)
 {
 irq = new_irq;
 if (!0) ; else printf("%s:irq %s\n", getInstanceName().c_str(), irq ? "set" : "cleared");
 
 if (intr.setValue.implemented())
 intr.setValue(irq ? sg::Signal::Set : sg::Signal::Clear);
 }
 
}
}

#line 210 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::control_write(uint32_t new_cr)
{
 cr = (uint8_t)new_cr;

 uint32_t c = (cr & KMICR_FKMIC) ? 0 : 1;
 uint32_t d = (cr & KMICR_FKMID) ? 0 : 1;


 
 

 
 
 
 
 
 
 
 
 
 


 

 ps2clockdata_state state;
 if (c && d) {
 if (!(stat & KMIST_TXEMPTY))
 state = PS2_Request_To_Send;
 else if (stat & KMIST_RXFULL)
 state = PS2_Inhibit;
 else
 state = PS2_Ready;
 } else if (!d) {
 state = PS2_Request_To_Send;
 } else {
 state = PS2_Inhibit;
 }
 ps2device.setClockData(state);

 irmask = 0;
 if (cr & KMICR_TXEN) {
 irmask |= KMITXINT;
 }
 if (cr & KMICR_RXEN) {
 irmask |= KMIRXINT;
 }

 
 update_kmi_interrupt();
 
}
}

#line 262 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL050_KMI::status_read()
{
 uint8_t s = stat &~ (KMIST_PARITY|KMIST_C|KMIST_D);

 
 uint8_t parity = rxdata;
 parity ^= (parity>>4);
 parity ^= (parity>>2);
 parity ^= (parity>>1);
 if (!(parity & 1))
 s |= KMIST_PARITY;

 
 
 s |= ((~cr << 1) & KMIST_C);
 s |= ((~cr >> 1) & KMIST_D);

 
 stat = s;
 return stat;
 
}
}

#line 284 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::data_write(uint8_t data)
{
 txdata = data;

 ir &=~ KMITXINT;
 stat |= KMIST_TXBUSY;
 stat &=~ KMIST_TXEMPTY;

 update_kmi_interrupt();

 
 
 ps2device.setClockData(PS2_Request_To_Send);
 
}
}

#line 299 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint8_t 
Component__PL050_KMI::data_read()
{
 if (stat & KMIST_RXFULL)
 {
 ir &=~ KMIRXINT;
 stat &=~ KMIST_RXFULL;

 update_kmi_interrupt();

 
 ps2device.setClockData(PS2_Ready);
 }
 return rxdata;
 
}
}

#line 314 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::update_clock()
{
 __PL050_KMI_internal_1.set(1, (1+clkdiv));
 
}
}

#line 319 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::device_reset()
{
 stat = KMIST_TXEMPTY;
 rxdata = 0;
 txdata = 0;
 ir = KMITXINT;
 clkdiv = 0;
 irmask = 0;

 control_write(0);
 update_clock();
 
}
}

#line 332 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL050_KMI::registerRead(uint32_t device_addr)
{
 uint32_t data = 0;
 switch (device_addr)
 {
 case 0x00:
 data = cr;
 
 if (!0) ; else printf("%s:KMICR -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x04:
 data = status_read();;
 
 if (!0) ; else printf("%s:KMISTAT -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x08:
 data = data_read();
 
 if (!0) ; else printf("%s:KMIDATA -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0x0c:
 data = clkdiv;

 if (!0) ; else printf("%s:KMICLKDIV -> 0x%x\n", getInstanceName().c_str(), data);
 
 update_clock();
 
 break;
 
 case 0x10:
 data = ir & irmask;
 
 if (!0) ; else printf("%s:KMIIR -> 0x%x\n", getInstanceName().c_str(), data);
 break;
 
 case 0xFE0: data = 0x50; 
 
 if (!0) ; else printf("%s:PeriphID0 -> 0x%x\n", getInstanceName().c_str(), data);
 
 break;
 case 0xFE4: data = 0x10; 
 
 if (!0) ; else printf("%s:PeriphID1 -> 0x%x\n", getInstanceName().c_str(), data);
 
 break;
 case 0xFE8: data = 0x14; 
 
 if (!0) ; else printf("%s:PeriphID2 -> 0x%x\n", getInstanceName().c_str(), data);
 
 break;
 case 0xFEC: data = 0x00; 
 
 if (!0) ; else printf("%s:PeriphID3 -> 0x%x\n", getInstanceName().c_str(), data);
 
 break;
 case 0xFF0: data = 0x0D; 
 
 if (!0) ; else printf("%s:PCellID0 -> 0x%x\n", getInstanceName().c_str(), data);
 
 break;
 case 0xFF4: data = 0xF0; 
 
 if (!0) ; else printf("%s:PCellID1 -> 0x%x\n", getInstanceName().c_str(), data);
 
 break;
 case 0xFF8: data = 0x05; 
 
 if (!0) ; else printf("%s:PCellID2 -> 0x%x\n", getInstanceName().c_str(), data);
 
 break;
 case 0xFFC: data = 0xB1; 
 
 if (!0) ; else printf("%s:PCellID3 -> 0x%x\n", getInstanceName().c_str(), data);
 
 break;
 
 default:
 if (!0) ; else printf("%s:KMI read at 0x%x\n", getInstanceName().c_str(), device_addr);
 break;
 }
 return data;
 
}
}

#line 418 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::registerWrite(uint32_t device_addr, uint32_t data)
{
 switch (device_addr)
 {
 
 case 0x00: 
 if (!0) ; else printf("%s:KMICR <- 0x%x\n", getInstanceName().c_str(), data);
 
 
 
 
 
 
 
 
 
 control_write(static_cast<uint8_t>(data & 0xff));
 
 return;
 
 case 0x04: 
 if (!0) ; else printf("%s:KMISTAT <- 0x%x (READ ONLY)\n", getInstanceName().c_str(), data);
 
 return;
 
 case 0x08: 
 if (!0) ; else printf("%s:KMIDATA <- 0x%x\n", getInstanceName().c_str(), data);
 
 
 
 
 data_write(static_cast<uint8_t>(data & 0xff));
 return;
 
 case 0x0c: 
 if (!0) ; else printf("%s:KMICLKDIV <- 0x%x\n", getInstanceName().c_str(), data);
 
 clkdiv = (uint8_t)(data & 0xf);
 
 return;
 
 case 0x10: 
 if (!0) ; else printf("%s:KMIIR <- 0x%x (READ ONLY)\n", getInstanceName().c_str(), data);
 
 return;
 
 default: 
 if (!0) ; else printf("%s:KMI write at 0x%x <- 0x%x\n", getInstanceName().c_str(), device_addr, data);
 return; 
 }
 
}
}

#line 472 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL050_KMI::debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects)
{
 if (reg_id == 0x8)
 {
 *datap = rxdata;
 }
 else
 {
 *datap = registerRead(reg_id);
 }
 
 return ACCESS_FUNC_OK;
 
}
}

#line 486 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL050_KMI::debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects)
{
 registerWrite(reg_id, (uint32_t)*datap);
 
 return ACCESS_FUNC_OK;
 
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::interconnect()
{{if(!controlPort_clk_divider__.interconnect.empty()) controlPort_clk_divider__.interconnect();if(!controlPort_clk_timer__.interconnect.empty()) controlPort_clk_timer__.interconnect();if(!controlPort_busslave__.interconnect.empty()) controlPort_busslave__.interconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::disconnect()
{{if(!controlPort_clk_divider__.disconnect.empty()) controlPort_clk_divider__.disconnect();if(!controlPort_clk_timer__.disconnect.empty()) controlPort_clk_timer__.disconnect();if(!controlPort_busslave__.disconnect.empty()) controlPort_busslave__.disconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::update()
{{if(!controlPort_clk_divider__.update.empty()) controlPort_clk_divider__.update();if(!controlPort_clk_timer__.update.empty()) controlPort_clk_timer__.update();if(!controlPort_busslave__.update.empty()) controlPort_busslave__.update();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::communicate()
{{if(!controlPort_clk_divider__.communicate.empty()) controlPort_clk_divider__.communicate();if(!controlPort_clk_timer__.communicate.empty()) controlPort_clk_timer__.communicate();if(!controlPort_busslave__.communicate.empty()) controlPort_busslave__.communicate();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::traceEndOfCycle()
{{if(!controlPort_clk_divider__.traceEndOfCycle.empty()) controlPort_clk_divider__.traceEndOfCycle();if(!controlPort_clk_timer__.traceEndOfCycle.empty()) controlPort_clk_timer__.traceEndOfCycle();if(!controlPort_busslave__.traceEndOfCycle.empty()) controlPort_busslave__.traceEndOfCycle();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::loadApplicationFile(const std::string& filename)
{{if(!controlPort_clk_divider__.loadApplicationFile.empty()) controlPort_clk_divider__.loadApplicationFile(filename);if(!controlPort_clk_timer__.loadApplicationFile.empty()) controlPort_clk_timer__.loadApplicationFile(filename);if(!controlPort_busslave__.loadApplicationFile.empty()) controlPort_busslave__.loadApplicationFile(filename);};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::terminate()
{{if(!controlPort_clk_divider__.terminate.empty()) controlPort_clk_divider__.terminate();if(!controlPort_clk_timer__.terminate.empty()) controlPort_clk_timer__.terminate();if(!controlPort_busslave__.terminate.empty()) controlPort_busslave__.terminate();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL050_KMI::save(MxODataStream& os)
{{if(!controlPort_clk_divider__.save.empty()) controlPort_clk_divider__.save(os);if(!controlPort_clk_timer__.save.empty()) controlPort_clk_timer__.save(os);if(!controlPort_busslave__.save.empty()) controlPort_busslave__.save(os);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL050_KMI::restore(MxIDataStream& is)
{{if(!controlPort_clk_divider__.restore.empty()) controlPort_clk_divider__.restore(is);if(!controlPort_clk_timer__.restore.empty()) controlPort_clk_timer__.restore(is);if(!controlPort_busslave__.restore.empty()) controlPort_busslave__.restore(is);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::step()
{{if(!controlPort_clk_divider__.step.empty()) controlPort_clk_divider__.step();if(!controlPort_clk_timer__.step.empty()) controlPort_clk_timer__.step();if(!controlPort_busslave__.step.empty()) controlPort_busslave__.step();};
}
}

#line 100 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL050_KMI::abstract_port__device__read(pv::ReadTransaction tx)
{
 if (tx.getAccessWidth() > pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();

 
 uint32_t device_addr = (uint32_t)tx.getAddress() & ~3;
 uint32_t data = registerRead(device_addr);
 return tx.setReturnData32(data);
 
}
}

#line 110 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL050_KMI::abstract_port__device__write(pv::WriteTransaction tx)
{
 if (tx.getAccessWidth() > pv::ACCESS_32_BITS || (tx.getAddress() & 3) != 0) return tx.generateAbort();
 uint32_t device_addr = (uint32_t)tx.getAddress();
 registerWrite(device_addr, tx.getData32());
 return tx.writeComplete();
 
}
}

#line 118 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL050_KMI::abstract_port__device__debugRead(pv::ReadTransaction tx)
{
 return device.read(tx);
 
}
}

#line 123 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL050_KMI::abstract_port__device__debugWrite(pv::WriteTransaction tx)
{
 return device.write(tx);
 
}
}

#line 132 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint8_t 
Component__PL050_KMI::abstract_port__ps2device__getData()
{
 if (stat & KMIST_TXBUSY)
 {
 stat &=~ KMIST_TXBUSY;
 stat |= KMIST_TXEMPTY;

 ir |= KMITXINT;

 update_kmi_interrupt();

 }
 
 ps2device.setClockData(PS2_Ready);
 
 return txdata; 
 
}
}

#line 150 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL050_KMI::abstract_port__ps2device__putData(uint8_t data)
{
 if (!(stat & KMIST_RXFULL))
 {
 rxdata = data;
 stat |= KMIST_RXFULL;
 ir |= KMIRXINT;

 update_kmi_interrupt();
 }
 
 
 ps2device.setClockData(PS2_Inhibit);
 
}
}

#line 169 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL050_KMI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL050_KMI::abstract_port__timer_callback__signal()
{
 if (!0) ; else printf("KMI tick\n");
 update_kmi_interrupt();
 return 0; 
 
}
}

#line 21133 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PL050_KMI
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PL050_KMI::Component__PL050_KMI(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)



	,cadiParameterProxy_busslave_of_PVBusSlave_to_PL050_KMI__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "ARM PrimeCell PS2 Keyboard/Mouse Interface(PL050)";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PL050_KMI_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockDivider_factory = ClockDivider_GetFactory();
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_clk_divider__ = params.getParamsFor("clk_divider");
			add(clk_divider = ClockDivider_factory->instantiate("clk_divider", simulationContext, params_clk_divider__));
		}
		{
			sg::Params params_clk_timer__ = params.getParamsFor("clk_timer");
			add(clk_timer = ClockTimer_factory->instantiate("clk_timer", simulationContext, params_clk_timer__));
		}
		{
			sg::Params params_busslave__ = params.getParamsFor("busslave");
			params_busslave__["size"] = MxU64CONST(0x0000000000001000);
			add(busslave = PVBusSlave_factory->instantiate("busslave", simulationContext, params_busslave__));
		}
		ClockDivider_factory->dereference();
		ClockTimer_factory->dereference();
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PL050_KMI::control_port__configure, this);
    bind_method(control_port, init, &Component__PL050_KMI::init, this);
    bind_method(control_port, interconnect, &Component__PL050_KMI::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PL050_KMI::postConnect, this);
    bind_method(control_port, reset, &Component__PL050_KMI::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PL050_KMI::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PL050_KMI::disconnect, this);
    bind_method(control_port, terminate, &Component__PL050_KMI::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PL050_KMI::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PL050_KMI::refresh, this);
    bind_method(control_port, step, &Component__PL050_KMI::step, this);
    bind_method(control_port, update, &Component__PL050_KMI::update, this);
    bind_method(control_port, communicate, &Component__PL050_KMI::communicate, this);
    bind_method(control_port, getProperty, &Component__PL050_KMI::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PL050_KMI::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PL050_KMI::control_port__bypass, this);
    bind_method(control_port, run, &Component__PL050_KMI::control_port__run, this);
    bind_method(control_port, stop, &Component__PL050_KMI::control_port__stop, this);
    bind_method(control_port, idle, &Component__PL050_KMI::control_port__idle, this);
    bind_method(control_port, quit, &Component__PL050_KMI::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PL050_KMI::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PL050_KMI::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PL050_KMI::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PL050_KMI::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PL050_KMI::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PL050_KMI::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PL050_KMI::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PL050_KMI::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_clk_divider__.connectTo(clk_divider->findPort("$control"));
	controlPort_clk_timer__.connectTo(clk_timer->findPort("$control"));
	controlPort_busslave__.connectTo(busslave->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(device, read, &Component__PL050_KMI::abstract_port__device__read, this);
	bind_method(device, write, &Component__PL050_KMI::abstract_port__device__write, this);
	bind_method(device, debugRead, &Component__PL050_KMI::abstract_port__device__debugRead, this);
	bind_method(device, debugWrite, &Component__PL050_KMI::abstract_port__device__debugWrite, this);
	bind_method(ps2device, getData, &Component__PL050_KMI::abstract_port__ps2device__getData, this);
	bind_method(ps2device, putData, &Component__PL050_KMI::abstract_port__ps2device__putData, this);
	bind_method(timer_callback, signal, &Component__PL050_KMI::abstract_port__timer_callback__signal, this);


    // add abstract ports
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	publishMasterPort("intr", intr);
	intr.SetName__("intr");
	publishSlavePort("clock", clock);
	clock.SetName__("clock");
	device.SetName__("device");
	publishSlavePort("ps2device", ps2device);
	ps2device.SetName__("ps2device");
	publishSlavePort("timer_callback", timer_callback);
	timer_callback.SetName__("timer_callback");
	__PL050_KMI_internal_1.SetName__("__PL050_KMI_internal_1");


    // wire up static connection map
	pvbus.connectTo(busslave->findPort("pvbus_s"));
	busslave->findPort("device").connectTo(device);
	clock.connectTo(clk_divider->findPort("clk_in"));
	clk_divider->findPort("clk_out").connectTo(clk_timer->findPort("clk_in"));
	clk_timer->findPort("timer_callback").connectTo(timer_callback);
	__PL050_KMI_internal_1.connectTo(clk_divider->findPort("rate"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PL050_KMI::~Component__PL050_KMI()
{
}

void Component__PL050_KMI::control_port__configure(const sg::Params& params)
{
	if(controlPort_clk_divider__.configure.implemented()) controlPort_clk_divider__.configure(params.getParamsFor("clk_divider"));
	if(controlPort_clk_timer__.configure.implemented()) controlPort_clk_timer__.configure(params.getParamsFor("clk_timer"));
	if(controlPort_busslave__.configure.implemented()) controlPort_busslave__.configure(params.getParamsFor("busslave"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PL050_KMI_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PL050_KMI::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clk_divider__.populateCADIMap.implemented())
			{
				controlPort_clk_divider__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_clk_timer__.populateCADIMap.implemented())
			{
				controlPort_clk_timer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busslave__.populateCADIMap.implemented())
			{
				controlPort_busslave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("busslave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_busslave_of_PVBusSlave_to_PL050_KMI__ = new CADIParameterProxy(cadi, &parameterFilter_busslave_of_PVBusSlave_to_PL050_KMI__);
			}
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PL050_KMI::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PL050_KMI::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PL050_KMI::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PL050_KMI::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PL050_KMI::control_port__run()
{
}


void Component__PL050_KMI::control_port__stop()
{
}


void Component__PL050_KMI::control_port__idle()
{
}


void Component__PL050_KMI::control_port__quit()
{
}


void Component__PL050_KMI::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PL050_KMI::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PL050_KMI::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PL050_KMI::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PL050_KMI::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PL050_KMI::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_busslave_of_PVBusSlave_to_PL050_KMI__;
	cadiParameterProxy_busslave_of_PVBusSlave_to_PL050_KMI__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PL050_KMI::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PL050_KMI::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PL050_KMI::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PL050_KMI::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PL050_KMI::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL050_KMI::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL050_KMI::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL050_KMI::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PL050_KMI::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL050_KMI::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL050_KMI::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PL050_KMI::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PL050_KMI::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PL050_KMI::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PL050_KMI::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PL050_KMI::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PL050_KMI::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PL050_KMI::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PL050_KMI::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PL050_KMI::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__PL050_KMI::reset_resources__()
{
    // resource initialization code
	KMICR = 0; // reset register
	KMISTAT = 0; // reset register
	KMIDATA = 0; // reset register
	KMICLKDIV = 0; // reset register
	KMIIR = 0; // reset register
	KMIPeriphID0 = 0; // reset register
	KMIPeriphID1 = 0; // reset register
	KMIPeriphID2 = 0; // reset register
	KMIPeriphID3 = 0; // reset register
	KMIPCellID0 = 0; // reset register
	KMIPCellID1 = 0; // reset register
	KMIPCellID2 = 0; // reset register
	KMIPCellID3 = 0; // reset register

}


} // FVP_VE_Cortex_A15x1_NMS
#line 85 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL111_CLCD::debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects)
{
 *datap = pl11x_clcd->registerRead(reg_id);
 
 return ACCESS_FUNC_OK;
 
}
}

#line 92 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL111_CLCD::debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects)
{
 pl11x_clcd->registerWrite(reg_id, (uint32_t)*datap);
 
 return ACCESS_FUNC_OK;
 
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::interconnect()
{{if(!controlPort_pl11x_clcd__.interconnect.empty()) controlPort_pl11x_clcd__.interconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::disconnect()
{{if(!controlPort_pl11x_clcd__.disconnect.empty()) controlPort_pl11x_clcd__.disconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::update()
{{if(!controlPort_pl11x_clcd__.update.empty()) controlPort_pl11x_clcd__.update();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::communicate()
{{if(!controlPort_pl11x_clcd__.communicate.empty()) controlPort_pl11x_clcd__.communicate();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::traceEndOfCycle()
{{if(!controlPort_pl11x_clcd__.traceEndOfCycle.empty()) controlPort_pl11x_clcd__.traceEndOfCycle();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::loadApplicationFile(const std::string& filename)
{{if(!controlPort_pl11x_clcd__.loadApplicationFile.empty()) controlPort_pl11x_clcd__.loadApplicationFile(filename);};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::init()
{{if(!controlPort_pl11x_clcd__.init.empty()) controlPort_pl11x_clcd__.init();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::terminate()
{{if(!controlPort_pl11x_clcd__.terminate.empty()) controlPort_pl11x_clcd__.terminate();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::reset(int level)
{{if(!controlPort_pl11x_clcd__.reset.empty()) controlPort_pl11x_clcd__.reset(level);};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::reset(int level, int /*argc*/, char** /*argv*/)
{
	reset(level);

}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL111_CLCD::save(MxODataStream& os)
{{if(!controlPort_pl11x_clcd__.save.empty()) controlPort_pl11x_clcd__.save(os);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL111_CLCD::restore(MxIDataStream& is)
{{if(!controlPort_pl11x_clcd__.restore.empty()) controlPort_pl11x_clcd__.restore(is);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL111_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL111_CLCD::step()
{{if(!controlPort_pl11x_clcd__.step.empty()) controlPort_pl11x_clcd__.step();};
}
}

#line 21858 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PL111_CLCD
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PL111_CLCD::Component__PL111_CLCD(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,pixel_double_limit(GetParameterValue(params, "pixel_double_limit", MxS64CONST(0x12c), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))


	,cadiParameterProxy_pl11x_clcd_of_PL11x_CLCD_to_PL111_CLCD__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "ARM PrimeCell Color LCD Controller(PL111)";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PL111_CLCD_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *PL11x_CLCD_factory = PL11x_CLCD_GetFactory();
		{
			sg::Params params_pl11x_clcd__ = params.getParamsFor("pl11x_clcd");
			params_pl11x_clcd__["pl11x_behavior"] = MxU64CONST(0x0000000000000001);
			params_pl11x_clcd__["pixel_double_limit"] = pixel_double_limit;
			pl11x_clcd = dynamic_cast<Component__PL11x_CLCD*>(PL11x_CLCD_factory->instantiate("pl11x_clcd", simulationContext, params_pl11x_clcd__));
			assert(pl11x_clcd);
			add(pl11x_clcd);
		}
		PL11x_CLCD_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PL111_CLCD::control_port__configure, this);
    bind_method(control_port, init, &Component__PL111_CLCD::init, this);
    bind_method(control_port, interconnect, &Component__PL111_CLCD::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PL111_CLCD::postConnect, this);
    bind_method(control_port, reset, &Component__PL111_CLCD::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PL111_CLCD::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PL111_CLCD::disconnect, this);
    bind_method(control_port, terminate, &Component__PL111_CLCD::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PL111_CLCD::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PL111_CLCD::refresh, this);
    bind_method(control_port, step, &Component__PL111_CLCD::step, this);
    bind_method(control_port, update, &Component__PL111_CLCD::update, this);
    bind_method(control_port, communicate, &Component__PL111_CLCD::communicate, this);
    bind_method(control_port, getProperty, &Component__PL111_CLCD::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PL111_CLCD::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PL111_CLCD::control_port__bypass, this);
    bind_method(control_port, run, &Component__PL111_CLCD::control_port__run, this);
    bind_method(control_port, stop, &Component__PL111_CLCD::control_port__stop, this);
    bind_method(control_port, idle, &Component__PL111_CLCD::control_port__idle, this);
    bind_method(control_port, quit, &Component__PL111_CLCD::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PL111_CLCD::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PL111_CLCD::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PL111_CLCD::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PL111_CLCD::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PL111_CLCD::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PL111_CLCD::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PL111_CLCD::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PL111_CLCD::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_pl11x_clcd__.connectTo(pl11x_clcd->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports


    // add abstract ports
	publishSlavePort("clk_in", clk_in);
	clk_in.SetName__("clk_in");
	publishSlavePort("control", control);
	control.SetName__("control");
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	publishMasterPort("display", display);
	display.SetName__("display");
	publishMasterPort("intr", intr);
	intr.SetName__("intr");
	publishMasterPort("pvbus_m", pvbus_m);
	pvbus_m.SetName__("pvbus_m");


    // wire up static connection map
	clk_in.connectTo(pl11x_clcd->findPort("clk_in"));
	control.connectTo(pl11x_clcd->findPort("control"));
	pvbus.connectTo(pl11x_clcd->findPort("pvbus"));
	pl11x_clcd->findPort("display").connectTo(display);
	pl11x_clcd->findPort("intr").connectTo(intr);
	pl11x_clcd->findPort("pvbus_m").connectTo(pvbus_m);


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PL111_CLCD::~Component__PL111_CLCD()
{
}

void Component__PL111_CLCD::control_port__configure(const sg::Params& params)
{
	if(controlPort_pl11x_clcd__.configure.implemented()) controlPort_pl11x_clcd__.configure(params.getParamsFor("pl11x_clcd"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PL111_CLCD_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PL111_CLCD::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_pl11x_clcd__.populateCADIMap.implemented())
			{
				controlPort_pl11x_clcd__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("pl11x_clcd", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_pl11x_clcd_of_PL11x_CLCD_to_PL111_CLCD__ = new CADIParameterProxy(cadi, &parameterFilter_pl11x_clcd_of_PL11x_CLCD_to_PL111_CLCD__);
			}
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PL111_CLCD::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PL111_CLCD::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PL111_CLCD::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PL111_CLCD::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PL111_CLCD::control_port__run()
{
}


void Component__PL111_CLCD::control_port__stop()
{
}


void Component__PL111_CLCD::control_port__idle()
{
}


void Component__PL111_CLCD::control_port__quit()
{
}


void Component__PL111_CLCD::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PL111_CLCD::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PL111_CLCD::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PL111_CLCD::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PL111_CLCD::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PL111_CLCD::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_pl11x_clcd_of_PL11x_CLCD_to_PL111_CLCD__;
	cadiParameterProxy_pl11x_clcd_of_PL11x_CLCD_to_PL111_CLCD__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PL111_CLCD::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PL111_CLCD::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PL111_CLCD::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PL111_CLCD::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_pixel_double_limit: *data = pixel_double_limit; break;

        default:
            printf("error: Component__PL111_CLCD::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL111_CLCD::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL111_CLCD::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL111_CLCD::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_pixel_double_limit:
		{
			*(const_cast<uint32_t*>(&pixel_double_limit)) = *data;
		}
		break;

        default:
            printf("error: Component__PL111_CLCD::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL111_CLCD::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL111_CLCD::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PL111_CLCD::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PL111_CLCD::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PL111_CLCD::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PL111_CLCD::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PL111_CLCD::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PL111_CLCD::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PL111_CLCD::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PL111_CLCD::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PL111_CLCD::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "pixel_double_limit") id = PARAMETER_ID_pixel_double_limit;

    return id;
}

void Component__PL111_CLCD::reset_resources__()
{
    // resource initialization code
	LCDTiming0 = 0; // reset register
	LCDTiming1 = 0; // reset register
	LCDTiming2 = 0; // reset register
	LCDTiming3 = 0; // reset register
	LCDUPBASE = 0; // reset register
	LCDLPBASE = 0; // reset register
	LCDControl = 0; // reset register
	LCDIMSC = 0; // reset register
	LCDRIS = 0; // reset register
	LCDMIS = 0; // reset register
	LCDICR = 0; // reset register
	LCDUPCURR = 0; // reset register
	LCDLPCURR = 0; // reset register
	for(int loop0=0; loop0<128; loop0++) {
		LCDPalette[loop0] = 0; // reset register
	}
	for(int loop0=0; loop0<256; loop0++) {
		CursorImage[loop0] = 0; // reset register
	}
	ClcdCrsrCtrl = 0; // reset register
	ClcdCrsrConfig = 0; // reset register
	ClcdCrsrPalette0 = 0; // reset register
	ClcdCrsrPalette1 = 0; // reset register
	ClcdCrsrXY = 0; // reset register
	ClcdCrsrClip = 0; // reset register
	ClcdCrsrIMSC = 0; // reset register
	ClcdCrsrICR = 0; // reset register
	ClcdCrsrRIS = 0; // reset register
	ClcdCrsrMIS = 0; // reset register
	CLCDPERIPHID0 = 0; // reset register
	CLCDPERIPHID1 = 0; // reset register
	CLCDPERIPHID2 = 0; // reset register
	CLCDPERIPHID3 = 0; // reset register
	CLCDPCELLID0 = 0; // reset register
	CLCDPCELLID1 = 0; // reset register
	CLCDPCELLID2 = 0; // reset register
	CLCDPCELLID3 = 0; // reset register

}


} // FVP_VE_Cortex_A15x1_NMS
#line 971 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::init()
{
 fdata = NULL;
 pixel_double = false;
 pv::TransactionMasterControl t_control;
 t_control >> busmaster->findPort("control");
 dma = t_control.createStreamingTransactionGenerator();
 fbuffer_changed = true;
 force_redraw = true;
 crsr_palette_changed = true;
 blit.pl11x_pixel_format = &pl11x_pixel_format;
 blit.pl11x_channel_format = &pl11x_channel_format;
 blit.pl11x_bpp = &pl11x_bpp;
 blit.pixels_per_line = &pixels_per_line;
 {if(!controlPort_busslave__.init.empty()) controlPort_busslave__.init();if(!controlPort_busmaster__.init.empty()) controlPort_busmaster__.init();if(!controlPort_timer__.init.empty()) controlPort_timer__.init();};

 cm_control = 0;
 mux = 0;
 
}
}

#line 991 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::terminate()
{
 delete dma;
 {if(!controlPort_busslave__.terminate.empty()) controlPort_busslave__.terminate();if(!controlPort_busmaster__.terminate.empty()) controlPort_busmaster__.terminate();if(!controlPort_timer__.terminate.empty()) controlPort_timer__.terminate();};
 
}
}

#line 997 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::reset(int level)
{
 {if(!controlPort_busslave__.reset.empty()) controlPort_busslave__.reset(level);if(!controlPort_busmaster__.reset.empty()) controlPort_busmaster__.reset(level);if(!controlPort_timer__.reset.empty()) controlPort_timer__.reset(level);};
 reg_changed = (1<<eLCDTiming0)
 | (1<<eLCDTiming1)
 | (1<<eLCDTiming2)
 | (1<<eLCDTiming3)
 | (1<<eLCDUpbase)
 | (1<<eLCDLpbase)
 | (1<<eLCDControl)
 | (1<<eLCDPalette);

 if (pl11x_behavior == 1)
 {
 reg_changed = (1 << CrsrCtrl)
 | (1<<CrsrConfig)
 | (1<<CrsrPalette0)
 | (1<<CrsrPalette1)
 | (1<<CrsrXY)
 | (1<<CrsrClip)
 | (1<<CrsrIMSC)
 | (1<<CrsrICR)
 | (1<<CrsrRIS)
 | (1<<CrsrMIS)
 | (1<<CrsrIMG);
 }

 timing0 = 0;
 timing1 = 0;
 timing2 = 0;
 timing3 = 0;
 r_control = 0;
 upbase = 0;
 lpbase = 0;
 irq_raw = 0;
 irq_mask = 0;

 pixels_per_line = 480;
 lines_per_panel = 640;

 panel_clock_divisor = 1;
 bypass_pcd = true;
 clocks_per_line = 640;

 up_base = 0; 
 lp_base = 0; 

 vcomp = 0; 

 

 be_pixel_order = false;
 be_byte_order = false;
 bgr = false;

 lcddual = false;
 lcdmono8 = false;
 lcdtft = false;
 lcdbw = false;

 pl11x_bpp = 1;

 enabled = false;

 
 
 
 crsr_ctrl = 0;
 crsr_config = 0;
 crsr_palette0 = 0;
 crsr_palette1 = 0;
 crsr_xy = 0;
 crsr_clip = 0;
 crsr_imsc = 0;
 crsr_icr = 0;
 crsr_ris = 0;
 crsr_mis = 0;
 old_crsrx = 0xFFFFFFFF;
 old_crsry = 0xFFFFFFFF;
 old_clipx = 0;
 old_clipy = 0;
 old_ch = 0;
 
 
 

 update_registers();

 lcd_event = 0;
 event_period = 0;
 __PL11x_CLCD_internal_1.cancel();
 dma->setRange(0, 0);
 
}
}

#line 1092 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::update_interrupts()
{
 if (irq_raw & irq_mask) {
 if (intr.setValue.implemented())
 intr.setValue(sg::Signal::Set);
 } else {
 if (intr.setValue.implemented())
 intr.setValue(sg::Signal::Clear);
 }
 
}
}

#line 1105 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::update_registers()
{
 if (reg_changed) {
 fbuffer_changed = true;
 }
 if (reg_changed & (1<<eLCDTiming0))
 {
 pixels_per_line = (((timing0 & LCD_PPL_MASK)>>LCD_PPL_SHIFT)+1) * 16;

 
 bytes_per_line = pl11x_bpp <= 16 ? (pixels_per_line * pl11x_bpp)/8
 : pl11x_bpp == 24 ? pixels_per_line * 4
 : 0;

 if(!0) ; else printf("LCD pixels per line = %d\n", pixels_per_line);
 }

 if (reg_changed & (1<<eLCDTiming1))
 {
 lines_per_panel = ((timing1 & LCD_LPP_MASK)>>LCD_LPP_SHIFT) + 1;

 

 if(!0) ; else printf("LCD lines per panel = %d\n", lines_per_panel);
 }

 if (reg_changed & (1<<eLCDTiming2))
 {
 panel_clock_divisor = ((((timing2 & LCD_PCD_HI_MASK)>>LCD_PCD_HI_SHIFT)<<5)
 | ((timing2 & LCD_PCD_LO_MASK)>>LCD_PCD_LO_SHIFT)) + 2;

 bypass_pcd = (timing2 & LCD_BCD_MASK) != 0;
 clocks_per_line = ((timing2 & LCD_CPL_MASK) >> LCD_CPL_SHIFT)+1;

 

 if(!0) ; else printf("LCD panel_clock_divisor = %d %s\n", panel_clock_divisor, bypass_pcd ? "(bypassed)" : "");
 if(!0) ; else printf("LCD clocks_per_line = %d\n", clocks_per_line);


 
 event_period = (clocks_per_line*lines_per_panel);

 }

 if (reg_changed & (1<<eLCDTiming3))
 {
 
 }

 if (reg_changed & (1<<eLCDUpbase))
 {
 up_base = upbase;

 if(!0) ; else printf("LCD upper panel base = 0x%x\n", up_base);
 }

 if (reg_changed & (1<<eLCDLpbase))
 {
 lp_base = lpbase;

 if(!0) ; else printf("LCD lower panel base = 0x%x\n", lp_base);
 }

 if (reg_changed & (1<<eLCDControl))
 {
 uint32_t c = r_control;

 vcomp = (c&LCD_VCOMP_MASK)>>LCD_VCOMP_SHIFT;


 be_pixel_order = (c&LCD_BEPO) != 0;
 be_byte_order = (c&LCD_BEBO) != 0;
 bgr = (c&LCD_BGR) != 0;
 blit.bgr = bgr;

 lcddual = (c&LCD_DUAL) != 0;
 lcdmono8 = (c&LCD_MONO8) != 0;
 lcdtft = (c&LCD_TFT) != 0;
 lcdbw = (c&LCD_BW) != 0;

 static const uint32_t bpptable[8] = { 1, 2, 4, 8, 16, 24, 16, 16 }; 
 static const PL11X_ChannelFormat format[8] = { CF_INDEX, CF_INDEX, CF_INDEX, CF_INDEX,
 CF_1555, CF_888, CF_565, CF_444 };
 static const char* formatname[8] = { "indexed", "indexed", "indexed", "indexed",
 "555", "888", "565", "444" };

 uint32_t bppcode = (c&LCD_BPP_MASK)>>LCD_BPP_SHIFT;

 
 if (bppcode == 4)
 {
 if (mux == 2)
 {
 bppcode = 6;
 bgr = false;
 }
 else if (mux == 3)
 {
 bppcode = 6;
 bgr = true;
 }
 }
 pl11x_bpp = bpptable[bppcode];
 pl11x_channel_format = format[bppcode];

 bytes_per_line = pl11x_bpp <= 16 ? (pixels_per_line * pl11x_bpp)/8
 : pl11x_bpp == 24 ? pixels_per_line * 4
 : 0;

 if(!0) ; else printf("LCD pixel format: %s %s %s %d bpp (%s)\n",
 be_pixel_order ? "BEPO" : "LEPO",
 be_byte_order ? "BEBO" : "LEBO",
 bgr ? "BGR" : "RGB",
 pl11x_bpp,
 formatname[bppcode]);

 
 colour_format_changed = true;
 }

 if (reg_changed & (1<<eLCDPalette))
 {
 palette_changed = true;
 }

 if (reg_changed & ((1<<eLCDUpbase)|(1<<eLCDTiming0)|(1<<eLCDTiming1)))
 {
 uint32_t fbuffer_bytes = (bytes_per_line * lines_per_panel);

 dma->setRange(up_base, fbuffer_bytes);
 }


 
 
 

 if (reg_changed & (1<<CrsrCtrl))
 {
 blit.crsrnum = (crsr_ctrl & CRSR_NUM_MASK) >> CRSR_NUM_SHIFT;
 }

 if (reg_changed & (1<<CrsrConfig))
 {
 blit.crsrWidth = blit.crsrHeight = (crsr_config & CRSR_SIZE)==0?32:64;
 blit.cw = blit.crsrWidth - blit.clipx - 1;
 blit.ch = blit.crsrHeight - blit.clipy - 1;
 }
 if (reg_changed & (1<<CrsrPalette0))
 {
 crsr_palette_changed = true;
 }

 if (reg_changed & (1<<CrsrPalette1))
 {
 crsr_palette_changed = true;
 }

 if (reg_changed & (1<<CrsrXY))
 {
 blit.crsrx = (crsr_xy & CRSR_X_MASK) >> CRSR_X_SHIFT;
 blit.crsry = (crsr_xy & CRSR_Y_MASK) >> CRSR_Y_SHIFT;
 blit.cx = blit.crsrx+blit.clipx;
 blit.cy = blit.crsry+blit.clipy;
 }

 if (reg_changed & (1<<CrsrClip))
 {
 blit.clipx = (crsr_clip & CRSR_CLIPX_MASK) >> CRSR_CLIPX_SHIFT;
 blit.clipy = (crsr_clip & CRSR_CLIPY_MASK) >> CRSR_CLIPY_SHIFT;
 blit.cx = blit.crsrx+blit.clipx;
 blit.cy = blit.crsry+blit.clipy;
 blit.cw = blit.crsrWidth - blit.clipx - 1;
 blit.ch = blit.crsrHeight - blit.clipy - 1;
 }

 if (reg_changed & (1<<CrsrIMSC))
 {
 
 }

 if (reg_changed & (1<<CrsrICR))
 {
 
 }

 if (reg_changed & (1<<CrsrRIS))
 {
 
 }

 if (reg_changed & (1<<CrsrMIS))
 {
 
 }
 if (reg_changed & (1<<CrsrIMG))
 {
 blit.decodeCursorImage(crsr_ram);
 }
 
 
 

 reg_changed = 0;

 
 irq_raw |= INT_LNBU;
 update_interrupts();
 
}
}

#line 1317 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::update_palette()
{
 VisPixelFormat const * f = &fdata->format;
 if(!0) ; else printf("update_palette pl11x_bpp=%d\n", pl11x_bpp);
 if(!0) ; else printf("output format\n");
 if(!0) ; else printf("    rbits: %d, gbits: %d, bbits: %d\n", f->rbits, f->gbits, f->bbits);
 if(!0) ; else printf("    roff: %d, boff:%d, goff: %d\n", f->roff, f->boff, f->goff);
 if(!0) ; else printf("    pbytes: %d\n", f->pbytes);

 
 if (pl11x_bpp <= 8)
 {
 pl11x_pixel_format = be_byte_order ? BB8 : LB8;

 
 
 
 

 uint32_t pixels_per_byte = 8 / pl11x_bpp;
 for (uint32_t i=0; i<256; ++i)
 {
 
 uint32_t rbits = 5;
 uint32_t gbits = 5;
 uint32_t bbits = 5;

 uint32_t roff = bgr ? 10 : 0;
 uint32_t goff = bgr ? 5 : 5;
 uint32_t boff = bgr ? 0 : 10;

 uint32_t rmask = (1<<rbits)-1;
 uint32_t gmask = (1<<gbits)-1;
 uint32_t bmask = (1<<bbits)-1;

 
 for (uint32_t pixel=0;pixel<pixels_per_byte; ++pixel)
 {
 
 uint32_t poffset = be_pixel_order ? (8 - pl11x_bpp * (pixel + 1))
 : pl11x_bpp * pixel;
 
 uint32_t pmask = (1<<pl11x_bpp)-1;

 
 uint32_t pindex = (i>>poffset) & pmask;

 
 uint32_t p = palette[pindex>>1];
 if (be_byte_order)
 p = ((pindex&1) ? p : (p>>16)) & 0xffff;
 else
 p = ((pindex&1) ? (p>>16) : p) & 0xffff;


 uint32_t rindex = (p>>roff) & rmask;
 uint32_t gindex = (p>>goff) & gmask;
 uint32_t bindex = (p>>boff) & bmask;

 uint32_t dpixel = blit.rcomp[rindex<<(8-rbits)] | blit.rcomp[rindex>>rbits]
 | blit.gcomp[gindex<<(8-gbits)] | blit.gcomp[gindex>>gbits]
 | blit.bcomp[bindex<<(8-bbits)] | blit.bcomp[bindex>>bbits];

 

 switch (f->pbytes) {
 case 1: blit.clut_src8[i].dst8[pixel] = (uint8_t) dpixel; break;
 case 2: blit.clut_src8[i].dst16[pixel] = (uint16_t) dpixel; break;
 case 4: blit.clut_src8[i].dst32[pixel] = (uint32_t) dpixel; break;
 default: assert(!"Unsupported destination pixel size\n"); break;
 }
 }
 }

 dst_bytes = f->pbytes * pixels_per_byte;
 }
 
 
 else if (pl11x_bpp == 16)
 {
 pl11x_pixel_format = bgr ? BGR16 : RGB16;

 uint32_t roff, goff, boff, rbits, gbits, bbits;
 if (pl11x_channel_format == CF_1555)
 {
 

 rbits = 5;
 gbits = 5;
 bbits = 5;

 roff = bgr ? 10 : 0;
 goff = bgr ? 5 : 5;
 boff = bgr ? 0 : 10;
 }
 else if (pl11x_channel_format == CF_444)
 {
 rbits = 4;
 gbits = 4;
 bbits = 4;

 roff = bgr ? 8 : 0;
 goff = bgr ? 4 : 4;
 boff = bgr ? 0 : 8;
 }
 else 
 {
 rbits = 5;
 gbits = 6;
 bbits = 5;

 roff = bgr ? 11 : 0;
 goff = bgr ? 5 : 5;
 boff = bgr ? 0 : 11;
 }

 uint32_t rmask = (1<<rbits)-1;
 uint32_t gmask = (1<<gbits)-1;
 uint32_t bmask = (1<<bbits)-1;

 
 for (uint32_t i=0; i<65536; ++i)
 {
 uint32_t rindex = (i>>roff) & rmask;
 uint32_t gindex = (i>>goff) & gmask;
 uint32_t bindex = (i>>boff) & bmask;

 uint32_t dpixel = blit.rcomp[rindex<<(8-rbits)] | blit.rcomp[rindex>>rbits]
 | blit.gcomp[gindex<<(8-gbits)] | blit.gcomp[gindex>>gbits]
 | blit.bcomp[bindex<<(8-bbits)] | blit.bcomp[bindex>>bbits];

 switch (f->pbytes) {
 case 1: blit.clut_src16[i].dst8 = (uint8_t) dpixel; break;
 case 2: blit.clut_src16[i].dst16 = (uint16_t) dpixel; break;
 case 4: blit.clut_src16[i].dst32 = (uint32_t) dpixel; break;
 default: assert(!"Unsupported destination pixel size\n"); break;
 }
 }

 dst_bytes = f->pbytes; 
 }
 
 else 
 {
 pl11x_pixel_format = bgr ? BGR24 : RGB24;

 dst_bytes = f->pbytes; 
 }

 force_redraw = true;

 palette_changed = false;
 
}
}

#line 1471 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL11x_CLCD::updateCrsrPalette(uint32_t palette)
{
 uint8_t r, g, b;
 uint32_t dst_bytes = 0;
 uint32_t pal = 0;
 VisPixelFormat const * f = &fdata->format;
 if(pl11x_bpp <= 8)
 {
 dst_bytes = f->pbytes * 8 / pl11x_bpp;
 } else if ( pl11x_bpp == 16 || pl11x_bpp == 24) {
 dst_bytes = f->pbytes;
 }

 switch(dst_bytes)
 {
 case 1:
 if (bgr)
 {
 b = ((palette >> 16) & 0xFF);
 g = ((palette >> 8) & 0xFF);
 r = ((palette >> 0) & 0xFF);
 }
 else
 {
 r = ((palette >> 16) & 0xFF);
 g = ((palette >> 8) & 0xFF);
 b = ((palette >> 0) & 0xFF);
 }
 pal = r | g | b;
 break;
 case 2:
 if (pl11x_channel_format == CF_1555)
 {
 if (bgr)
 {
 b = ((palette >> 16) & 0xFF)/8;
 g = ((palette >> 8) & 0xFF)/8;
 r = ((palette >> 0) & 0xFF)/8;
 pal = b << 10 | g << 5 | r << 0;
 }
 else
 {
 r = ((palette >> 16) & 0xFF)/8;
 g = ((palette >> 8) & 0xFF)/8;
 b = ((palette >> 0) & 0xFF)/8;
 pal = r << 10 | g << 5 | b << 0;
 }
 }
 else if (pl11x_channel_format == CF_444)
 {
 if (bgr)
 {
 b = ((palette >> 16) & 0xFF)/16;
 g = ((palette >> 8) & 0xFF)/16;
 r = ((palette >> 0) & 0xFF)/16;
 pal = b << 8 | g << 4 | r << 0;
 }
 else
 {
 r = ((palette >> 16) & 0xFF)/16;
 g = ((palette >> 8) & 0xFF)/16;
 b = ((palette >> 0) & 0xFF)/16;
 pal = r << 8 | g << 4 | b << 0;
 }
 }
 else 
 {
 if (bgr)
 {
 b = ((palette >> 16) & 0xFF)/8;
 g = ((palette >> 8) & 0xFF)/4;
 r = ((palette >> 0) & 0xFF)/8;
 pal = b << 11 | g << 5 | r << 0;
 }
 else
 {
 r = ((palette >> 16) & 0xFF)/8;
 g = ((palette >> 8) & 0xFF)/4;
 b = ((palette >> 0) & 0xFF)/8;
 pal = r << 11 | g << 5 | b << 0;
 }
 }
 break;
 case 4:
 pal = palette;
 break;
 }

 return pal;
 
}
}

#line 1562 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::update_colour_tables()
{
 
 
 VisPixelFormat const * f = &fdata->format;
 for (uint32_t i=0; i<256; ++i)
 {
 blit.rcomp[i] = (i>>(8-f->rbits))<<f->roff;
 blit.gcomp[i] = (i>>(8-f->gbits))<<f->goff;
 blit.bcomp[i] = (i>>(8-f->bbits))<<f->boff;
 }
 colour_format_changed = false;
 
}
}

#line 1580 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::blit_frame()
{
 pixel_double = (pixels_per_line < pixel_double_limit) ? true : false;

 if (pixel_double) {
 if(display.setPreferredLayout.implemented())
 display.setPreferredLayout(pixels_per_line*2, lines_per_panel*2, pl11x_bpp);
 } else {
 if(display.setPreferredLayout.implemented())
 display.setPreferredLayout(pixels_per_line, lines_per_panel, pl11x_bpp);
 }
 if(display.lock.implemented())
 fdata = display.lock();
 else
 fdata = NULL;

 if (fdata == NULL)
 return;

 bool crsron = false;
 if (pl11x_behavior == 1) {
 crsron = crsr_ctrl & CRSR_ON;
 
 if (crsron)
 blit.f = &fdata->format;
 }

 if (fdata->changed || colour_format_changed)
 {
 update_colour_tables();
 palette_changed = true;
 crsr_palette_changed = true;
 }

 if (palette_changed)
 update_palette();

 if (crsr_palette_changed)
 {
 blit.palette0 = updateCrsrPalette(crsr_palette0);
 blit.palette1 = updateCrsrPalette(crsr_palette1);
 }

 unsigned int src_bytes = (pl11x_bpp == 24?32:pl11x_bpp) / 8;
 unsigned int render_bytes_per_line = fdata->width * src_bytes;
 unsigned int render_height = fdata->height;
 if (pixel_double) {
 render_height /= 2;
 render_bytes_per_line /= 2;
 }

 if (render_bytes_per_line > bytes_per_line) {
 render_bytes_per_line = bytes_per_line;
 }
 if (render_height > lines_per_panel) {
 render_height = lines_per_panel;
 }

 fbuffer_changed |= force_redraw;

 dma->startDma(up_base);

 const uint8_t* src_ptr;
 if (pixel_double)
 {
 for (uint32_t line = 0; line < render_height; ++line)
 {
 uint32_t line_offset = 0;

 uint8_t* dest_ptr0 = fdata->buffer + 2 * line * fdata->pitch;
 uint8_t* dest_ptr = dest_ptr0 + fdata->pitch;
 while (line_offset < bytes_per_line)
 {
 uint32_t dma_bytes = bytes_per_line - line_offset;
 bool changed = dma->getDmaData(&src_ptr, &dma_bytes);

 if (old_crsrx != blit.crsrx || old_crsry != blit.crsry || old_clipx != blit.clipx || old_clipy != blit.clipy)
 if (line >= old_crsry && line<(old_crsry+old_ch))
 changed = true;

 
 const uint8_t* src = NULL;
 if(line >= blit.crsry && line<(blit.crsry+blit.ch))
 src = src_ptr;
 else
 src = NULL;

 if (!changed && !force_redraw) {
 src_ptr = NULL;
 }

 fbuffer_changed |= changed;


 if (line_offset < render_bytes_per_line) {
 uint32_t render_bytes = render_bytes_per_line - line_offset;
 if (render_bytes > dma_bytes) render_bytes = dma_bytes;

 uint8_t* dst0 = dest_ptr0;
 uint8_t* dst = dest_ptr;

 dest_ptr0 = blit.blit_line<Double>(dest_ptr0, src_ptr, render_bytes, dst_bytes);
 dest_ptr = blit.blit_line<Double>(dest_ptr, src_ptr, render_bytes, dst_bytes);

 if (pl11x_behavior == 1)
 {
 if (crsron && src)
 {
 uint32_t merge_bytes;
 const uint8_t* src0 = src;
 merge_bytes = blit.crsrUpdatePointers<Double>(&dst0, &src0, render_bytes/src_bytes, line_offset/src_bytes, line, dst_bytes);

 if (merge_bytes != 0)
 blit.blit_cursor_line<Double>(dst0, src0, merge_bytes, dst_bytes);

 merge_bytes = blit.crsrUpdatePointers<Double>(&dst, &src, render_bytes/src_bytes, line_offset/src_bytes, line, dst_bytes);

 if (merge_bytes != 0)
 blit.blit_cursor_line<Double>(dst, src, merge_bytes, dst_bytes);
 }
 }
 }
 line_offset += dma_bytes;
 }
 }
 }
 else
 {
 for (uint32_t line = 0; line < render_height; ++line)
 {
 uint32_t line_offset = 0;

 uint8_t* dest_ptr = fdata->buffer + line * fdata->pitch;

 while (line_offset < bytes_per_line)
 {
 uint32_t dma_bytes = bytes_per_line - line_offset;
 bool changed = dma->getDmaData(&src_ptr, &dma_bytes);

 if (old_crsrx != blit.crsrx || old_crsry != blit.crsry || old_clipx != blit.clipx || old_clipy != blit.clipy)
 if (line >= old_crsry && line<(old_crsry+old_ch))
 changed = true;

 
 const uint8_t* src = NULL;
 if(line >= blit.crsry && line<(blit.crsry+blit.ch))
 src = src_ptr;
 else
 src = NULL;

 if (!changed && !force_redraw) {
 src_ptr = NULL;
 }

 fbuffer_changed |= changed;

 if (line_offset < render_bytes_per_line) {
 uint32_t render_bytes = render_bytes_per_line - line_offset;
 if (render_bytes > dma_bytes) render_bytes = dma_bytes;

 uint8_t* dst = dest_ptr;
 dest_ptr = blit.blit_line<Single>(dest_ptr, src_ptr, render_bytes, dst_bytes);
 if (pl11x_behavior == 1)
 {
 if (crsron && src)
 {
 uint32_t merge_bytes;

 merge_bytes = blit.crsrUpdatePointers<Single>(&dst, &src, render_bytes/src_bytes, line_offset/src_bytes, line, dst_bytes);

 if (merge_bytes != 0)
 blit.blit_cursor_line<Single>(dst, src, merge_bytes, dst_bytes);
 }
 }
 }
 line_offset += dma_bytes;
 }
 }
 }
 if(display.unlock.implemented())
 display.unlock();

 if (fbuffer_changed)
 {
 if (pixel_double) {
 if(display.update.implemented())
 display.update(0,0, pixels_per_line*2, lines_per_panel*2);
 } else {
 if(display.update.implemented())
 display.update(0,0, pixels_per_line, lines_per_panel);
 }
 }

 fbuffer_changed = false;
 force_redraw = false;
 crsr_palette_changed = false;

 old_crsrx = blit.crsrx;
 old_crsry = blit.crsry;
 old_clipx = blit.clipx;
 old_clipy = blit.clipy;
 old_ch = blit.ch;

 
 irq_raw |= INT_Vcomp;
 update_interrupts();

 
}
}

#line 1790 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::control_changed()
{
 
 

 bool enabled = (r_control & LCD_ENABLE) != 0;

 if (enabled && !lcd_event)
 {
 lcd_event = 1;
 this->enabled = true;

 
 __PL11x_CLCD_internal_1.set(timer_callback());
 }
 else if (!enabled && lcd_event)
 {
 
 __PL11x_CLCD_internal_1.cancel();

 event_period = 0;
 lcd_event = 0;

 this->enabled = false;
 }
 
}
}

#line 1824 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL11x_CLCD::timer_callback()
{
 if(!0) ; else printf("Triger timer_callback()\n");
 
 if (!enabled)
 {
 if(!0) ; else printf("LCD disabled\n");
 event_period = 0;
 lcd_event = 0;
 return 0;
 }

 
 update_registers();

 
 blit_frame();

 
 if (event_period < 10000)
 return 10000;
 else
 return event_period;
 
}
}

#line 1853 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::setCMControl(uint32_t control)
{
 if(!0) ; else printf("LCD cm control <- 0x%x\n", control);

 uint32_t changed = control ^ cm_control;
 if (changed)
 {
 if ((changed & LCD_CM_BRIGHTER) && (control & LCD_CM_BRIGHTER)) {
 if(!0) ; else printf("LCD brighter\n");
 }
 if ((changed & LCD_CM_DIMMER) && (control & LCD_CM_DIMMER)) {
 if(!0) ; else printf("LCD dimmer\n");
 }
 if (changed & LCD_CM_MUX_MASK) {
 if(!0) ; else printf("LCD mux %d\n", (control & LCD_CM_MUX_MASK)>>LCD_CM_MUX_SHIFT);
 }
 if (changed & LCD_CM_EN0) {
 if(!0) ; else printf("LCD %s 0\n", (control & LCD_CM_EN0) ? "enable" : "disable");
 }
 if (changed & LCD_CM_EN1) {
 if(!0) ; else printf("LCD %s 1\n", (control & LCD_CM_EN1) ? "enable" : "disable");
 }

 cm_control = control;

 
 mux = (control & LCD_CM_MUX_MASK)>>LCD_CM_MUX_SHIFT;

 
 reg_changed |= (1<<eLCDControl);
 }
 
}
}

#line 1886 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL11x_CLCD::registerRead(uint32_t device_addr)
{
 uint32_t data = 0;
 uint32_t peri_id = 0;
 if (pl11x_behavior == 1)
 peri_id = 0x041111;
 else
 peri_id = 0x041110;
 switch (device_addr) {
 case 0x00: 
 data = timing0;

 if(!0) ; else printf("LCDTiming0 -> %x\n", data);
 return data;

 case 0x04: 
 data = timing1;

 if(!0) ; else printf("LCDTiming1 -> %x\n", data);
 return data;

 case 0x08: 
 data = timing2;

 if(!0) ; else printf("LCDTiming2 -> %x\n", data);
 return data;

 case 0x0c: 
 data = timing3;

 if(!0) ; else printf("LCDTiming3 -> %x\n", data);
 return data;

 case 0x10: 
 data = upbase;

 if(!0) ; else printf("LCDUPBASE -> %x\n", data);
 return data;

 case 0x14: 
 data = lpbase;

 if(!0) ; else printf("LCDLPBASE -> %x\n", data);
 return data;
 case 0x18: 
 if (pl11x_behavior == 1)
 {
 data = r_control;

 if(!0) ; else printf("LCDControl -> %x\n", data);

 return data;
 }
 else
 {
 data = irq_mask;

 if(!0) ; else printf("LCCIMSC -> %x\n", data);

 return data;
 }
 case 0x1C: 
 if (pl11x_behavior == 1)
 {
 data = irq_mask;

 if(!0) ; else printf("LCCIMSC -> %x\n", data);

 return data;
 }
 else
 {
 data = r_control;

 if(!0) ; else printf("LCDControl -> %x\n", data);

 return data;
 }
 case 0x20: 
 data = irq_raw;

 if(!0) ; else printf("LCDRIS -> %x\n", data);
 return data;

 case 0x24: 
 data = irq_raw & irq_mask;

 if(!0) ; else printf("LCDMIS -> %x\n", data);
 return data;

 case 0x28:
 if (pl11x_behavior == 0) 
 {
 if(!0) ; else printf("LCDUPCURR -> %x -- UNIMPLEMENTED\n", data);
 }
 else 
 {
 if(!0) ; else printf("LCDICR -> %x -- Write only\n", data);
 }
 return data;

 case 0x2c:
 if (pl11x_behavior == 0) 
 {
 if(!0) ; else printf("LCDLPCURR -> %x -- UNIMPLEMENTED\n", data);
 }
 else 
 {
 if(!0) ; else printf("LCDUPCURR -> %x -- UNIMPLEMENTED\n", data);
 }
 return data;

 case 0x30: 
 if (pl11x_behavior == 1) 
 {
 if(!0) ; else printf("LCDLPCURR -> %x -- UNIMPLEMENTED\n", data);
 return data;
 }
 else
 {
 if(!0) ; else printf("LCD undefined register %x -> %x\n", (uint32_t)device_addr, data);
 return 0;
 }
 
 
 
 case 0xC00: 
 if (pl11x_behavior == 1)
 {
 data = crsr_ctrl;
 if(!0) ; else printf("CLCDCRSRCTRL -> %x\n", data);
 return data;
 }
 case 0xC04: 
 if (pl11x_behavior == 1)
 {
 data = crsr_config;
 if(!0) ; else printf("CLCDCRSRCONFIG -> %x\n", data);
 return data;
 }
 case 0xC08: 
 if (pl11x_behavior == 1)
 {
 data = crsr_palette0;
 if(!0) ; else printf("CLCDCRSRPALETTE0 -> %x\n", data);
 return data;
 }
 case 0xC0C: 
 if (pl11x_behavior == 1)
 {
 data = crsr_palette1;
 if(!0) ; else printf("CLCDCRSRPALETTE1 -> %x\n", data);
 return data;
 }
 case 0xC10: 
 if (pl11x_behavior == 1)
 {
 data = crsr_xy;
 if(!0) ; else printf("CLCDCRSRXY -> %x\n", data);
 return data;
 }
 case 0xC14: 
 if (pl11x_behavior == 1)
 {
 data = crsr_clip;
 if(!0) ; else printf("CLCDCRSRCLIP -> %x\n", data);
 return data;
 }
 case 0xC20: 
 if (pl11x_behavior == 1)
 {
 data = crsr_imsc;
 if(!0) ; else printf("CLCDCRSRIMSC -> %x\n", data);
 return data;
 }
 case 0xC24: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRICR -> %x --  Write only \n", data);
 return data;
 }
 case 0xC28: 
 if (pl11x_behavior == 1)
 {
 data = crsr_ris;
 if(!0) ; else printf("CLCDCRSRRIS -> %x\n", data);
 return data;
 }
 case 0xC2C: 
 if (pl11x_behavior == 1)
 {
 data = crsr_mis;
 if(!0) ; else printf("CLCDCRSRMIS -> %x\n", data);
 return data;
 }
 else
 {
 if(!0) ; else printf("LCD undefined register %x -> %x\n", (uint32_t)device_addr, data);
 return 0;
 }
 
 
 
 
 
 
 
 
 
 
 
 
 case 0xFE0: data = peri_id & 0xff; break; case 0xFE4: data = (peri_id >> 8) & 0xff; break; case 0xFE8: data = (peri_id >> 16) & 0xff; break; case 0xFEC: data = (peri_id >> 24) & 0xff; break; case 0xFF0: data = 0x0D; break; case 0xFF4: data = 0xF0; break; case 0xFF8: data = 0x05; break; case 0xFFC: data = 0xB1; break;;
 default:
 
 
 
 if (pl11x_behavior == 1)
 {
 if (device_addr >= 0x800 && device_addr < 0xC00) 
 {
 uint32_t entry = (uint32_t)((device_addr - 0x800)>>2);

 data = crsr_ram[entry];

 if(!0) ; else printf("CursorImage[%d] -> 0x%x\n", entry, data);
 return data;
 }
 }
 
 
 
 if (device_addr >= 0x200 && device_addr < 0x400) 
 {
 uint32_t entry = (uint32_t)((device_addr - 0x200)>>2);

 data = palette[entry];

 if(!0) ; else printf("LCDPalette[%d] -> 0x%x\n", entry, data);
 return data;
 }
 else
 {
 if(!0) ; else printf("LCD undefined register %x -> %x\n", (uint32_t)device_addr, data);
 return 0;
 }
 }

 return data;
 
}
}

#line 2137 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::registerWrite(uint32_t device_addr, uint32_t data)
{
 switch (device_addr) {
 case 0x00: 
 if(!0) ; else printf("LCDTiming0 <- %x\n", data);

 timing0 = data & LCD_TIMING0_MASK;

 reg_changed |= (1<<eLCDTiming0);

 break;

 case 0x04: 
 if(!0) ; else printf("LCDTiming1 <- %x\n", data);

 timing1 = data & LCD_TIMING1_MASK;
 reg_changed |= (1<<eLCDTiming1);

 break;

 case 0x08: 
 if(!0) ; else printf("LCDTiming2 <- %x\n", data);

 timing2 = data & LCD_TIMING2_MASK;
 reg_changed |= (1<<eLCDTiming2);

 break;

 case 0x0c: 
 if(!0) ; else printf("LCDTiming3 <- %x\n", data);

 timing3 = data & LCD_TIMING3_MASK;
 reg_changed |= (1<<eLCDTiming3);

 break;

 case 0x10: 
 if(!0) ; else printf("LCDUPBASE <- %x\n", data);

 
 upbase = data &~ 3;
 reg_changed |= (1<<eLCDUpbase);

 break;

 case 0x14: 
 if(!0) ; else printf("LCDLPBASE <- %x\n", data);

 
 lpbase = data &~ 3;
 reg_changed |= (1<<eLCDLpbase);

 break;
 case 0x18: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("LCDControl <- %x\n", data);

 r_control = data;
 reg_changed |= (1<<eLCDControl);

 control_changed();
 }
 else
 {
 if(!0) ; else printf("LCCIMSC <- %x\n", data);

 irq_mask = data & LCD_INT_MASK;

 update_interrupts();
 }
 break;
 case 0x1C: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("LCCIMSC <- %x\n", data);

 irq_mask = data & LCD_INT_MASK;

 update_interrupts();
 }
 else
 {
 if(!0) ; else printf("LCDControl <- %x\n", data);

 r_control = data;
 reg_changed |= (1<<eLCDControl);

 control_changed();
 }
 break;

 case 0x20: 
 if (pl11x_behavior == 0) 
 {
 if(!0) ; else printf("LCDRIS <- %x\n", data);
 irq_raw &=~ (data & LCD_INT_MASK);
 update_interrupts();
 }
 else 
 {
 if(!0) ; else printf("LCDRIS <- %x -- Read only\n", data);
 }
 break;

 case 0x24: 
 if(!0) ; else printf("LCDMIS <- %x -- Read only\n", data);
 break;

 case 0x28:
 if (pl11x_behavior == 0) 
 {
 if(!0) ; else printf("LCDUPCURR <- %x -- Read only\n", data);
 }
 else 
 {
 if(!0) ; else printf("LCDICR <- %x\n", data);
 irq_raw &=~ (data & LCD_INT_MASK);
 update_interrupts();
 }
 break;

 case 0x2C:
 if (pl11x_behavior == 0) 
 {
 if(!0) ; else printf("LCDLPCURR <- %x -- Read only\n", data);
 }
 else 
 {
 if(!0) ; else printf("LCDUPCURR <- %x -- Read only\n", data);
 }
 break;

 case 0x30: 
 if (pl11x_behavior == 1) 
 {
 if(!0) ; else printf("LCDLPCURR <- %x -- Read only\n", data);
 break;
 }
 else
 {
 if(!0) ; else printf("LCD undefined register %x <- %x\n", (uint32_t)device_addr, data);
 return;
 }

 
 
 
 case 0xC00: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRCTRL <- %x\n", data);
 crsr_ctrl = data;
 reg_changed |= (1<<CrsrCtrl);
 break;
 }
 case 0xC04: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRCONFIG <- %x\n", data);
 crsr_config = data;
 reg_changed |= (1<<CrsrConfig);
 break;
 }
 case 0xC08: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRPALETTE0 <- %x\n", data);
 crsr_palette0 = data;
 reg_changed |= (1<<CrsrPalette0);
 break;
 }
 case 0xC0C: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRPALETTE1 <- %x\n", data);
 crsr_palette1 = data;
 reg_changed |= (1<<CrsrPalette1);
 break;
 }
 case 0xC10: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRXY <- %x\n", data);
 crsr_xy = data;
 reg_changed |= (1<<CrsrXY);
 break;
 }
 case 0xC14: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRCLIP <- %x\n", data);
 crsr_clip = data;
 reg_changed |= (1<<CrsrClip);
 break;
 }
 case 0xC20: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRIMSC <- %x\n", data);
 crsr_imsc = data;
 reg_changed |= (1<<CrsrIMSC);
 break;
 }
 case 0xC24: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRICR <- %x\n", data);
 crsr_icr = data;
 reg_changed |= (1<<CrsrICR);
 break;
 }
 case 0xC28: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRRIS <- %x -- Read only\n", data);
 break;
 }
 case 0xC2C: 
 if (pl11x_behavior == 1)
 {
 if(!0) ; else printf("CLCDCRSRMIS <- %x -- Read only\n", data);
 break;
 }
 
 
 
 default:
 
 
 
 if (pl11x_behavior == 1)
 {
 if(device_addr >= 0x800 && device_addr < 0xC00) 
 {
 uint32_t entry = (uint32_t)((device_addr - 0x800)>>2);

 crsr_ram[entry] = data;
 reg_changed |= (1<<CrsrIMG);
 if(!0) ; else printf("CursorImage[%d] <- 0x%x\n", entry, data);
 return;
 }
 }
 
 
 
 if (device_addr >= 0x200 && device_addr < 0x400) 
 {
 uint32_t entry = (uint32_t)((device_addr - 0x200)>>2);

 palette[entry] = data;
 reg_changed |= (1<<eLCDPalette);

 if(!0) ; else printf("LCDPalette[%d] <- 0x%x\n", entry, data);
 return;
 }
 else
 {
 if(!0) ; else printf("LCD undefined register %x <- %x\n", (uint32_t)device_addr, data);
 return;
 }
 }

 
}
}

#line 2406 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL11x_CLCD::debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects)
{
 *datap = registerRead(reg_id);

 return ACCESS_FUNC_OK;
 
}
}

#line 2413 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL11x_CLCD::debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects)
{
 registerWrite(reg_id, (uint32_t)*datap);

 return ACCESS_FUNC_OK;
 
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::interconnect()
{{if(!controlPort_busslave__.interconnect.empty()) controlPort_busslave__.interconnect();if(!controlPort_busmaster__.interconnect.empty()) controlPort_busmaster__.interconnect();if(!controlPort_timer__.interconnect.empty()) controlPort_timer__.interconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::disconnect()
{{if(!controlPort_busslave__.disconnect.empty()) controlPort_busslave__.disconnect();if(!controlPort_busmaster__.disconnect.empty()) controlPort_busmaster__.disconnect();if(!controlPort_timer__.disconnect.empty()) controlPort_timer__.disconnect();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::update()
{{if(!controlPort_busslave__.update.empty()) controlPort_busslave__.update();if(!controlPort_busmaster__.update.empty()) controlPort_busmaster__.update();if(!controlPort_timer__.update.empty()) controlPort_timer__.update();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::communicate()
{{if(!controlPort_busslave__.communicate.empty()) controlPort_busslave__.communicate();if(!controlPort_busmaster__.communicate.empty()) controlPort_busmaster__.communicate();if(!controlPort_timer__.communicate.empty()) controlPort_timer__.communicate();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::traceEndOfCycle()
{{if(!controlPort_busslave__.traceEndOfCycle.empty()) controlPort_busslave__.traceEndOfCycle();if(!controlPort_busmaster__.traceEndOfCycle.empty()) controlPort_busmaster__.traceEndOfCycle();if(!controlPort_timer__.traceEndOfCycle.empty()) controlPort_timer__.traceEndOfCycle();};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::loadApplicationFile(const std::string& filename)
{{if(!controlPort_busslave__.loadApplicationFile.empty()) controlPort_busslave__.loadApplicationFile(filename);if(!controlPort_busmaster__.loadApplicationFile.empty()) controlPort_busmaster__.loadApplicationFile(filename);if(!controlPort_timer__.loadApplicationFile.empty()) controlPort_timer__.loadApplicationFile(filename);};
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL11x_CLCD::save(MxODataStream& os)
{{if(!controlPort_busslave__.save.empty()) controlPort_busslave__.save(os);if(!controlPort_busmaster__.save.empty()) controlPort_busmaster__.save(os);if(!controlPort_timer__.save.empty()) controlPort_timer__.save(os);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL11x_CLCD::restore(MxIDataStream& is)
{{if(!controlPort_busslave__.restore.empty()) controlPort_busslave__.restore(is);if(!controlPort_busmaster__.restore.empty()) controlPort_busmaster__.restore(is);if(!controlPort_timer__.restore.empty()) controlPort_timer__.restore(is);};return true;
}
}

#line 5 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::step()
{{if(!controlPort_busslave__.step.empty()) controlPort_busslave__.step();if(!controlPort_busmaster__.step.empty()) controlPort_busmaster__.step();if(!controlPort_timer__.step.empty()) controlPort_timer__.step();};
}
}

#line 897 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL11x_CLCD::abstract_port__device__read(pv::ReadTransaction tx)
{
 
 if (tx.getAccessWidth() > pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 
 return tx.setReturnData32((uint32_t)registerRead(tx.getAddress() & ~3));
 
}
}

#line 905 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL11x_CLCD::abstract_port__device__write(pv::WriteTransaction tx)
{
 
 
 
 
 if (tx.getAccessWidth() != pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();
 registerWrite(tx.getAddress(),tx.getData32());
 return tx.writeComplete();
 
}
}

#line 916 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL11x_CLCD::abstract_port__device__debugRead(pv::ReadTransaction tx)
{
 return device.read(tx);
 
}
}

#line 921 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL11x_CLCD::abstract_port__device__debugWrite(pv::WriteTransaction tx)
{
 return device.write(tx);
 
}
}

#line 952 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL11x_CLCD::abstract_port__control__setValue(uint32_t control)
{
 setCMControl(control);
 
}
}

#line 962 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL11x_CLCD.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL11x_CLCD::abstract_port__timer_callback_handler__signal()
{
 return timer_callback();
 
}
}

#line 24079 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PL11x_CLCD
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PL11x_CLCD::Component__PL11x_CLCD(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)

	,pixel_double_limit(GetParameterValue(params, "pixel_double_limit", MxS64CONST(0x12c), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))
	,pl11x_behavior(GetParameterValue(params, "pl11x_behavior", MxS64CONST(0x0), MxS64CONST(0x8000000000000000), MxS64CONST(0x7fffffffffffffff)))


	,cadiParameterProxy_busslave_of_PVBusSlave_to_PL11x_CLCD__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Internal component used by PL110 and PL111 CLCD controllers";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "1";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PL11x_CLCD_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		sg::ComponentFactory *PVBusMaster_factory = PVBusMaster_GetFactory();
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_busslave__ = params.getParamsFor("busslave");
			params_busslave__["size"] = MxU64CONST(0x0000000000001000);
			add(busslave = PVBusSlave_factory->instantiate("busslave", simulationContext, params_busslave__));
		}
		{
			sg::Params params_busmaster__ = params.getParamsFor("busmaster");
			add(busmaster = PVBusMaster_factory->instantiate("busmaster", simulationContext, params_busmaster__));
		}
		{
			sg::Params params_timer__ = params.getParamsFor("timer");
			add(timer = ClockTimer_factory->instantiate("timer", simulationContext, params_timer__));
		}
		ClockTimer_factory->dereference();
		PVBusMaster_factory->dereference();
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PL11x_CLCD::control_port__configure, this);
    bind_method(control_port, init, &Component__PL11x_CLCD::init, this);
    bind_method(control_port, interconnect, &Component__PL11x_CLCD::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PL11x_CLCD::postConnect, this);
    bind_method(control_port, reset, &Component__PL11x_CLCD::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PL11x_CLCD::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PL11x_CLCD::disconnect, this);
    bind_method(control_port, terminate, &Component__PL11x_CLCD::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PL11x_CLCD::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PL11x_CLCD::refresh, this);
    bind_method(control_port, step, &Component__PL11x_CLCD::step, this);
    bind_method(control_port, update, &Component__PL11x_CLCD::update, this);
    bind_method(control_port, communicate, &Component__PL11x_CLCD::communicate, this);
    bind_method(control_port, getProperty, &Component__PL11x_CLCD::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PL11x_CLCD::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PL11x_CLCD::control_port__bypass, this);
    bind_method(control_port, run, &Component__PL11x_CLCD::control_port__run, this);
    bind_method(control_port, stop, &Component__PL11x_CLCD::control_port__stop, this);
    bind_method(control_port, idle, &Component__PL11x_CLCD::control_port__idle, this);
    bind_method(control_port, quit, &Component__PL11x_CLCD::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PL11x_CLCD::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PL11x_CLCD::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PL11x_CLCD::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PL11x_CLCD::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PL11x_CLCD::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PL11x_CLCD::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PL11x_CLCD::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PL11x_CLCD::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_busslave__.connectTo(busslave->findPort("$control"));
	controlPort_busmaster__.connectTo(busmaster->findPort("$control"));
	controlPort_timer__.connectTo(timer->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(device, read, &Component__PL11x_CLCD::abstract_port__device__read, this);
	bind_method(device, write, &Component__PL11x_CLCD::abstract_port__device__write, this);
	bind_method(device, debugRead, &Component__PL11x_CLCD::abstract_port__device__debugRead, this);
	bind_method(device, debugWrite, &Component__PL11x_CLCD::abstract_port__device__debugWrite, this);
	bind_method(control, setValue, &Component__PL11x_CLCD::abstract_port__control__setValue, this);
	bind_method(timer_callback_handler, signal, &Component__PL11x_CLCD::abstract_port__timer_callback_handler__signal, this);


    // add abstract ports
	device.SetName__("device");
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	publishSlavePort("clk_in", clk_in);
	clk_in.SetName__("clk_in");
	publishMasterPort("intr", intr);
	intr.SetName__("intr");
	publishMasterPort("display", display);
	display.SetName__("display");
	publishSlavePort("control", control);
	control.SetName__("control");
	timer_callback_handler.SetName__("timer_callback_handler");
	publishMasterPort("pvbus_m", pvbus_m);
	pvbus_m.SetName__("pvbus_m");
	__PL11x_CLCD_internal_1.SetName__("__PL11x_CLCD_internal_1");


    // wire up static connection map
	pvbus.connectTo(busslave->findPort("pvbus_s"));
	busslave->findPort("device").connectTo(device);
	clk_in.connectTo(timer->findPort("clk_in"));
	timer->findPort("timer_callback").connectTo(timer_callback_handler);
	busmaster->findPort("pvbus_m").connectTo(pvbus_m);
	__PL11x_CLCD_internal_1.connectTo(timer->findPort("timer_control"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PL11x_CLCD::~Component__PL11x_CLCD()
{
}

void Component__PL11x_CLCD::control_port__configure(const sg::Params& params)
{
	if(controlPort_busslave__.configure.implemented()) controlPort_busslave__.configure(params.getParamsFor("busslave"));
	if(controlPort_busmaster__.configure.implemented()) controlPort_busmaster__.configure(params.getParamsFor("busmaster"));
	if(controlPort_timer__.configure.implemented()) controlPort_timer__.configure(params.getParamsFor("timer"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PL11x_CLCD_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PL11x_CLCD::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busslave__.populateCADIMap.implemented())
			{
				controlPort_busslave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("busslave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_busslave_of_PVBusSlave_to_PL11x_CLCD__ = new CADIParameterProxy(cadi, &parameterFilter_busslave_of_PVBusSlave_to_PL11x_CLCD__);
			}
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busmaster__.populateCADIMap.implemented())
			{
				controlPort_busmaster__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}
		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_timer__.populateCADIMap.implemented())
			{
				controlPort_timer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PL11x_CLCD::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PL11x_CLCD::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PL11x_CLCD::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PL11x_CLCD::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PL11x_CLCD::control_port__run()
{
}


void Component__PL11x_CLCD::control_port__stop()
{
}


void Component__PL11x_CLCD::control_port__idle()
{
}


void Component__PL11x_CLCD::control_port__quit()
{
}


void Component__PL11x_CLCD::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PL11x_CLCD::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PL11x_CLCD::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PL11x_CLCD::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PL11x_CLCD::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PL11x_CLCD::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_busslave_of_PVBusSlave_to_PL11x_CLCD__;
	cadiParameterProxy_busslave_of_PVBusSlave_to_PL11x_CLCD__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PL11x_CLCD::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PL11x_CLCD::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PL11x_CLCD::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PL11x_CLCD::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_pixel_double_limit: *data = pixel_double_limit; break;
	case PARAMETER_ID_pl11x_behavior: *data = pl11x_behavior; break;

        default:
            printf("error: Component__PL11x_CLCD::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL11x_CLCD::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL11x_CLCD::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL11x_CLCD::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {
	case PARAMETER_ID_pixel_double_limit:
		{
			*(const_cast<uint32_t*>(&pixel_double_limit)) = *data;
		}
		break;
	case PARAMETER_ID_pl11x_behavior:
		{
			*(const_cast<uint32_t*>(&pl11x_behavior)) = *data;
		}
		break;

        default:
            printf("error: Component__PL11x_CLCD::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL11x_CLCD::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL11x_CLCD::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PL11x_CLCD::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PL11x_CLCD::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PL11x_CLCD::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PL11x_CLCD::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PL11x_CLCD::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PL11x_CLCD::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PL11x_CLCD::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PL11x_CLCD::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PL11x_CLCD::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;
    if (name == "pixel_double_limit") id = PARAMETER_ID_pixel_double_limit;
    if (name == "pl11x_behavior") id = PARAMETER_ID_pl11x_behavior;

    return id;
}

void Component__PL11x_CLCD::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 202 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::init_id_registers()
{
 MCIPCellID0 = 0x80;
 MCIPCellID1 = 0x11;
 MCIPCellID2 = 0x04;
 MCIPCellID3 = 0x00;

 MCIPeriphID0 = 0x0d;
 MCIPeriphID1 = 0xF0;
 MCIPeriphID2 = 0x05;
 MCIPeriphID3 = 0xB1;

}
}

#line 215 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::init()
{
 {if(!controlPort_busslave__.init.empty()) controlPort_busslave__.init();};
 init_id_registers();

 MCIStatus = 0;
 doTrace = true;
 common_reset();

}
}

#line 225 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::reset(int level)
{
 {if(!controlPort_busslave__.reset.empty()) controlPort_busslave__.reset(level);};
 common_reset();

}
}

#line 231 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::common_reset()
{
 
 init_id_registers();
 MCIPower = 0;
 MCIClock = 0;
 MCIArgument = 0;
 MCICommand = 0;
 MCIRespCmd = 0;
 MCIResponse0 = 0;
 MCIResponse1 = 0;
 MCIResponse2 = 0;
 MCIResponse3 = 0;
 MCIDataTimer = 0;
 MCIDataLength = 0;
 MCIDataCtrl = 0;
 MCIDataCnt = 0;
 
 MCIClear = 0;
 MCIMask0 = 0;
 MCIMask1 = 0;
 MCISelect = 0;
 MCIFifoCnt = 0;
 MCIFIFO = 0;

 
 tx_addr = (uint8_t *) 0;
 rx_addr = (const uint8_t *) 0;
 receiving = false;
 transmitting = false;

 transfer_len = 0;
 transfer_idx = 0;

 
 stat_CmdSent = 0;
 stat_CmdTimeOut = 0;
 stat_CmdRespEnd = 0;
 stat_DataEnd = 0;
 stat_DataBlockEnd = 0;

 MCIINTR_int[0] = sg::Signal::Clear;
 MCIINTR_int[1] = sg::Signal::Clear;

 
 update_status(true); 

 if (!0) ; else printf("%s:%d %s() common_reset done\n", __FILE__, __LINE__, __FUNCTION__);

}
}

#line 333 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL180_MCI::read_word_from_mmc()
{
 uint32_t ret;
 if (receiving && transfer_len)
 {
 stat_DataBlockEnd = 0; 
 if (transfer_idx == 0)
 {
 if (!0) ; else printf("%s:%d %s() read_word_from_mmc() starting receiving for address %p \n"
 , __FILE__, __LINE__, __FUNCTION__, rx_addr);
 }
 ret = ((uint32_t*)rx_addr)[transfer_idx++];

 MCIDataCnt -= 4;

 
 if (MCIDataCnt == 0) stat_DataEnd = 1;

 
 if (MCIFifoCnt > 0) MCIFifoCnt--;

 if (transfer_idx >= transfer_len)
 {
 if (!0) ; else printf("%s:%d %s()  rx_addr=%p block transferred\n", __FILE__, __LINE__, __FUNCTION__, rx_addr);
 receiving = false;
 rx_addr = 0;
 transfer_len = 0;
 stat_DataBlockEnd = 1; 
 mmc_m.Rx_rdy();
 }

 
 
 update_status(true);

 return ret;
 }

 
 
 if (!0) ; else printf("%s: Host requested data with Rx FIFO empty.\n", getInstanceName().c_str());
 return 0xdeaddead;

}
}

#line 378 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::write_word_to_mmc(uint32_t data)
{
 if (transmitting)
 {
 stat_DataBlockEnd = 0; 
 if (!0) ; else printf("%s: write_word_to_mmc tx_addr[%4d] = 0x%08X transfer_len=%4d MCIDataCnt=%d\n"
 , getInstanceName().c_str(), transfer_idx, data, transfer_len, MCIDataCnt - 4);

 ((uint32_t *) tx_addr)[transfer_idx++] = data;
 MCIDataCnt -= 4;

 
 if (MCIDataCnt == 0) stat_DataEnd = 1;

 
 if (MCIFifoCnt > 0) MCIFifoCnt--;

 if (transfer_idx >= transfer_len)
 {
 if (!0) ; else printf("%s: write_word_to_mmc() finished transmitting\n", getInstanceName().c_str());
 transmitting = false;
 tx_addr = 0;
 transfer_len = 0;
 stat_DataBlockEnd = 1; 
 mmc_m.Tx_done();
 }

 
 
 update_status(true);

 return;
 }

 
 
 if (!0) ; else printf("%s: Host requested data with Tx FIFO full.\n", getInstanceName().c_str());

}
}

#line 456 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::update_status(bool update_static)
{
 if (update_static)
 update_static_status();

 merge_dynamic_status();
 update_intr(0, MCIStatus & MCIMask0);
 update_intr(1, MCIStatus & MCIMask1);

}
}

#line 466 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::clear_status(uint32_t bits)
{
 

 if (bits & (1<<MCIStatus_CMDTIMEOUT_BIT)) stat_CmdTimeOut = 0;
 if (bits & (1<<MCIStatus_CMDRESPEND_BIT)) stat_CmdRespEnd = 0;
 if (bits & (1<<MCIStatus_CMDSENT_BIT)) stat_CmdSent = 0;
 if (bits & (1<<MCIStatus_DATAEND_BIT)) stat_DataEnd = 0;
 if (bits & (1<<MCIStatus_DATABLOCKEND_BIT)) stat_DataBlockEnd = 0;

 update_static_status();
 merge_dynamic_status();

 update_intr(0, MCIStatus & MCIMask0);
 update_intr(1, MCIStatus & MCIMask1);

}
}

#line 487 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::merge_dynamic_status()
{
 MCIStatus = MCIStatus & (MCIStatus_STATIC_MASK);
 int32_t wordsLeft;

 if (!(MCIDataCtrl & MCIDataCtrl_EN_MASK))
 {
 return;
 }

 

 MCIStatus |= (receiving << MCIStatus_RXACTIVE_BIT);
 MCIStatus |= (transmitting << MCIStatus_TXACTIVE_BIT);
 wordsLeft = (transfer_len - transfer_idx);
 if ((MCIDataCtrl & MCIDataCtrl_DIR_MASK)) 
 {
 if (receiving)
 {
 MCIStatus |=
 ((wordsLeft >= MCI_FIFOHALFSIZE) << MCIStatus_RXFIFOHALFFULL_BIT) |
 ((wordsLeft >= MCI_FIFOSIZE) << MCIStatus_RXFIFOFULL_BIT) |
 ((wordsLeft == 0) << MCIStatus_RXFIFOEMPTY_BIT) |
 ((wordsLeft > 0) << MCIStatus_RXDATAAVAIL_BIT);
 }
 else
 {
 if (!0) ; else printf("%s: merge_dynamic_status() - Card to controller NOT receiving\n",
 getInstanceName().c_str());
 }
 } 
 else 
 {
 if (transmitting)
 {
 MCIStatus |=
 ((wordsLeft >= MCI_FIFOHALFSIZE) << MCIStatus_TXFIFOHALFEMPTY_BIT) |
 ((wordsLeft >= MCI_FIFOSIZE) << MCIStatus_TXFIFOFULL_BIT) |
 ((wordsLeft == 0) << MCIStatus_TXFIFOEMPTY_BIT) |
 ((wordsLeft > 0) << MCIStatus_TXDATAAVAIL_BIT);
 if (!0) ; else printf("%s: merge_dynamic_status() - Controller to card txdata=%2d "
 "MCIDataCtrl=0x%08X MCIDataCtrl_DIR_MASK=0x%08X MCIStatus=0x%08X\n",
 getInstanceName().c_str(), transfer_len - transfer_idx,
 MCIDataCtrl, MCIDataCtrl_DIR_MASK, MCIStatus);
 }
 else
 {
 if (!0) ; else printf("%s: merge_dynamic_status() - Controller to card NOT transmitting\n",
 getInstanceName().c_str());
 }
 } 

}
}

#line 540 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { char* 
Component__PL180_MCI::intstat()
{
 static char int_stat_tmp[2048];
 sprintf(int_stat_tmp, "0x%08x m0=0x%08x m1=0x%08x:%7s %7s %7s %7s %7s %7s %7s %7s %7s %7s %7s %7s %7s %7s"
 , MCIStatus
 , MCIMask0
 , MCIMask1
 , MCIStatus & (1 << MCIStatus_RXACTIVE_BIT) ? "R      " : ""
 , MCIStatus & (1 << MCIStatus_TXACTIVE_BIT) ? "T      " : ""
 , MCIStatus & (1 << MCIStatus_TXFIFOEMPTY_BIT) ? "TXE    " : ""
 , MCIStatus & (1 << MCIStatus_TXFIFOFULL_BIT) ? "TXF    " : ""
 , MCIStatus & (1 << MCIStatus_TXFIFOHALFEMPTY_BIT)? "TXHE   " : ""
 , MCIStatus & (1 << MCIStatus_RXFIFOHALFFULL_BIT) ? "RXHF   " : ""
 , MCIStatus & (1 << MCIStatus_RXFIFOFULL_BIT) ? "RXF    " : ""
 , MCIStatus & (1 << MCIStatus_RXFIFOEMPTY_BIT) ? "RXE    " : ""
 , MCIStatus & (1 << MCIStatus_RXDATAAVAIL_BIT) ? "RDA    " : ""
 , MCIStatus & (1 << MCIStatus_CMDTIMEOUT_BIT) ? "CMDTO  " : ""
 , MCIStatus & (1 << MCIStatus_CMDRESPEND_BIT) ? "CMDRE  " : ""
 , MCIStatus & (1 << MCIStatus_CMDSENT_BIT) ? "CMDSENT" : ""
 , MCIStatus & (1 << MCIStatus_DATAEND_BIT) ? "DE     " : ""
 , MCIStatus & (1 << MCIStatus_DATABLOCKEND_BIT) ? "DBE    " : ""
 );
 return int_stat_tmp;

}
}

#line 566 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::update_static_status()
{
 
 

 MCIStatus = MCIStatus & (~MCIStatus_STATIC_MASK);
 MCIStatus |= (stat_CmdTimeOut << MCIStatus_CMDTIMEOUT_BIT) |
 (stat_CmdRespEnd << MCIStatus_CMDRESPEND_BIT) |
 (stat_CmdSent << MCIStatus_CMDSENT_BIT) |
 (stat_DataEnd << MCIStatus_DATAEND_BIT) |
 (stat_DataBlockEnd << MCIStatus_DATABLOCKEND_BIT);

}
}

#line 582 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::update_intr(uint32_t index, uint32_t status)
{
 if (index > 1) return;

 sg::Signal::State state = (status)?sg::Signal::Set:sg::Signal::Clear;

 if (MCIINTR_int[index] != state)
 {
 

 MCIINTR_int[index] = state;
 if (!0) ; else printf("%s() int%d=%d (int0=%d int1=%d) %s\n", __FUNCTION__, index
 , (state == sg::Signal::Clear) ? 0 : 1
 , (MCIINTR_int[0] == sg::Signal::Clear) ? 0 : 1
 , (MCIINTR_int[1] == sg::Signal::Clear) ? 0 : 1
 , (state == sg::Signal::Clear) ? "" : intstat()
 );
 if (MCIINTR[index].setValue.implemented())
 {
 MCIINTR[index].setValue(state);
 }
 }

}
}

#line 608 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::sendCmd(uint32_t data)
{
 MCICommand = data;
 if (!(data & (1<<10))) 
 return;

 
 mmc_resp_t rt; 
 mmc_cxd_resp_t resp; 
 uint32_t exp_rt = (data >> 6) & 3;
 mmc_cmd_t cmd = (mmc_cmd_t)(data & 63);

 if (!0) ; else printf("%s:%d %s() cmd=%d\n", __FILE__, __LINE__, __FUNCTION__, cmd);

 
 if (cmd == MMC_STOP_TRANSMISSION) 
 {
 if (!0) ; else printf("got stop transmission ...\n");
 transmitting = false;
 receiving = false;
 transfer_idx = 0;
 transfer_len = 0;
 }
 
 rt = mmc_m.cmd(cmd, MCIArgument, &resp);
 stat_CmdTimeOut = 0;
 stat_CmdRespEnd = 0;
 stat_CmdSent = 0;
 switch (exp_rt)
 {
 case 1: 
 if ((rt == MMC_RNONE) || (rt == MMC_RERROR))
 { 
 if(MMC_RERROR != rt)
 {
 
 
 if (!0) ; else printf("%s: Cmd %d expected a short response, but got %d - CmdTimeOut.\n"
 , getInstanceName().c_str(), (int)cmd, (int)rt);
 }
 stat_CmdTimeOut = 1;
 break;
 } else if (rt == MMC_R128) {
 
 
 if (!0) ; else printf("%s: Cmd %d expected a short response, but got %d - ignoring.\n",
 getInstanceName().c_str(), (int)cmd, (int)rt);
 }
 stat_CmdRespEnd = 1;
 MCIResponse0 = resp.cxd[0];
 MCIRespCmd = data & 0x3f;
 break;
 case 3: 
 if (rt != MMC_R128)
 { 
 if (!0) ; else printf("%s: Cmd %d expected a long response, but got %d - CmdTimeOut.\n",
 getInstanceName().c_str(), (int)cmd, (int)rt);
 stat_CmdTimeOut = 1;
 break;
 }
 stat_CmdRespEnd = 1;
 MCIResponse0 = resp.cxd[0];
 MCIResponse1 = resp.cxd[1];
 MCIResponse2 = resp.cxd[2];
 MCIResponse3 = resp.cxd[3];
 MCIRespCmd = data & 0x3f;
 break;
 case 0: 
 case 2: 
 stat_CmdSent = 1;
 default:
 if (rt != MMC_RNONE)
 {
 if (!0) ; else printf("%s: Cmd %d expected no response, but got %d.\n",
 getInstanceName().c_str(), (int)cmd, (int)rt);

 }
 break;
 } 
 if (!0) ; else printf("%s: Cmd with exp_rt=%d done stat_CmdRespEnd=%d\n", getInstanceName().c_str(), exp_rt, stat_CmdRespEnd);
 update_status(true); 


}
}

#line 695 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PL180_MCI::registerRead(uint32_t addr)
{
 uint32_t data = 0;

 switch(addr)
 {
 case 0x000:
 data = MCIPower;
 break;
 case 0x004:
 data = MCIClock;
 break;
 case 0x008:
 data = MCIArgument;
 break;
 case 0x00C:
 data = MCICommand;
 break;
 case 0x010:
 data = MCIRespCmd;
 break;
 case 0x014:
 data = MCIResponse0;
 break;
 case 0x018:
 data = MCIResponse1;
 break;
 case 0x01C:
 data = MCIResponse2;
 break;
 case 0x020:
 data = MCIResponse3;
 break;
 case 0x024:
 data = MCIDataTimer;
 break;
 case 0x028:
 data = MCIDataLength;
 break;
 case 0x02C:
 data = MCIDataCtrl;
 break;
 case 0x030:
 data = MCIDataCnt;
 break;
 case 0x034:
 data = MCIStatus;
 break;
 case 0x038:
 
 data = 0;
 break;
 case 0x03C:
 data = MCIMask0;
 break;
 case 0x040:
 data = MCIMask1;
 break;
 case 0x044:
 break;
 case 0x048:
 
 if (MCIFifoCnt == (MCIDataLength+3)/4)
 {
 MCIFifoCnt--;
 }
 data = MCIFifoCnt;
 break;
 case 0x080: 
 data = read_word_from_mmc();
 
 
 
 
 
 
 
 
 break;

 
 case 0xFE0:
 data = MCIPCellID0;
 break;
 case 0xFE4:
 data = MCIPCellID1;
 break;
 case 0xFE8:
 data = MCIPCellID2;
 break;
 case 0xFEC:
 data = MCIPCellID3;
 break;
 case 0xFF0:
 data = MCIPeriphID0;
 break;
 case 0xFF4:
 data = MCIPeriphID1;
 break;
 case 0xFF8:
 data = MCIPeriphID2;
 break;
 case 0xFFC:
 data = MCIPeriphID3;
 break;
 default:
 if (!0) ; else printf("%s Read register: Invalid address 0x%x\n",
 getInstanceName().c_str(), addr);
 return 0;
 } 

 if (!0) ; else printf("%s: r 0x%08x <- %s[%03x]\n",
 getInstanceName().c_str(), data, register_name(addr), addr);

 return data;


}
}

#line 813 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::registerWrite(uint32_t addr, uint32_t data)
{
 bool readonly = false;

 if (!0) ; else printf("%s: w 0x%08x -> %s[%03x]\n",
 getInstanceName().c_str(), data, register_name(addr), addr);

 switch(addr)
 {
 case 0x000:
 
 
 
 
 MCIPower = data & 0xff;
 if ( (data & 3) == 2 ) 
 {
 MCIPower |= 3;
 }
 break;
 case 0x004:
 
 
 
 
 
 
 MCIClock = data & ((1<<12)-1);
 break;
 case 0x008:
 MCIArgument = data;
 break;
 case 0x00C:
 sendCmd(data & ((1<<11)-1));
 break;
 case 0x010:
 break;
 case 0x014: 
 case 0x018:
 case 0x01C:
 case 0x020:
 
 break;
 case 0x024:
 MCIDataTimer = data;
 break;
 case 0x028:
 MCIDataLength = data & 0xffff;
 break;
 case 0x02C: 
 MCIDataCtrl = data & MCIDataCtrl_MASK;
 if (MCIDataCtrl & MCIDataCtrl_EN_MASK)
 {
 MCIDataCnt = MCIDataLength; 
 
 
 
 MCIFifoCnt = (MCIDataLength+3)/4;
 
 if ((MCIDataCtrl & MCIDataCtrl_DIR_MASK))
 {
 receiving = true;
 transfer_idx = transfer_len = 0;
 }
 }
 else
 {
 if ((MCIDataCtrl & MCIDataCtrl_DIR_MASK))
 {
 receiving = false;
 transfer_len = 0;
 }
 }
 update_status(true);
 break;
 case 0x030:
 
 break;
 case 0x034:
 
 break;
 case 0x038:
 
 clear_status(data); 
 break;
 case 0x03C:
 MCIMask0 = data & ((1<<22)-1);
 
 update_status(true);
 break;;
 case 0x040:
 MCIMask1 = data & ((1<<22)-1);
 
 update_status(true);
 break;
 case 0x044:
 break;
 case 0x048:
 
 break;
 case 0x080: 
 write_word_to_mmc(data);
 break;

 
 case 0xFE0:
 case 0xFE4:
 case 0xFE8:
 case 0xFEC:
 case 0xFF0:
 case 0xFF4:
 case 0xFF8:
 case 0xFFC:
 readonly = true;
 break;
 default:
 if (!0) ; else printf("%s Write register: Invalid address 0x%x\n",
 getInstanceName().c_str(), addr);
 break;
 } 

 if (readonly)
 {
 if (!0) ; else printf("%s Write to read only register at 0x%x.\n",
 getInstanceName().c_str(), addr);
 }


}
}

#line 943 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL180_MCI::debug_read(uint32_t reg_id, uint64_t* datap, bool side_effects)
{
 *datap = registerRead(reg_id);
 return ACCESS_FUNC_OK;

}
}

#line 949 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { AccessFuncResult 
Component__PL180_MCI::debug_write(uint32_t reg_id, const uint64_t* datap, bool side_effects)
{
 registerWrite(reg_id, (uint32_t)*datap);
 return ACCESS_FUNC_OK;

}
}

#line 955 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { const char* 
Component__PL180_MCI::register_name(uint32_t off)
{
 switch(off)
 {
 case 0x000: return("MCIPower");
 case 0x004: return("MCIClock");
 case 0x008: return("MCIArgument");
 case 0x00C: return("MCICommand");
 case 0x010: return("MCIRespCmd");
 case 0x014: return("MCIResponse0");
 case 0x018: return("MCIResponse1");
 case 0x01C: return("MCIResponse2");
 case 0x020: return("MCIResponse3");
 case 0x024: return("MCIDataTimer");
 case 0x028: return("MCIDataLength");
 case 0x02C: return("MCIDataCtrl");
 case 0x030: return("MCIDataCnt");
 case 0x034: return("MCIStatus");
 case 0x038: return("MCIClear");
 case 0x03C: return("MCIMask0");
 case 0x040: return("MCIMask1");
 case 0x044: return("MCISelect");
 case 0x048: return("MCIFifoCnt");
 case 0x080: return("MCIFIFO");
 case 0xFE0: return("MCIPeriphID0");
 case 0xFE4: return("MCIPeriphID1");
 case 0xFE8: return("MCIPeriphID2");
 case 0xFEC: return("MCIPeriphID3");
 case 0xFF0: return("MCIPCellID0");
 case 0xFF4: return("MCIPCellID1");
 case 0xFF8: return("MCIPCellID2");
 case 0xFFC: return("MCIPCellID3");
 default: return("Unknown");
 } 


}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::interconnect()
{{if(!controlPort_busslave__.interconnect.empty()) controlPort_busslave__.interconnect();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::disconnect()
{{if(!controlPort_busslave__.disconnect.empty()) controlPort_busslave__.disconnect();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::update()
{{if(!controlPort_busslave__.update.empty()) controlPort_busslave__.update();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::communicate()
{{if(!controlPort_busslave__.communicate.empty()) controlPort_busslave__.communicate();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::traceEndOfCycle()
{{if(!controlPort_busslave__.traceEndOfCycle.empty()) controlPort_busslave__.traceEndOfCycle();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::loadApplicationFile(const std::string& filename)
{{if(!controlPort_busslave__.loadApplicationFile.empty()) controlPort_busslave__.loadApplicationFile(filename);};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::terminate()
{{if(!controlPort_busslave__.terminate.empty()) controlPort_busslave__.terminate();};
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL180_MCI::save(MxODataStream& os)
{{if(!controlPort_busslave__.save.empty()) controlPort_busslave__.save(os);};return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL180_MCI::restore(MxIDataStream& is)
{{if(!controlPort_busslave__.restore.empty()) controlPort_busslave__.restore(is);};return true;
}
}

#line 6 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PL180_MCI::step()
{{if(!controlPort_busslave__.step.empty()) controlPort_busslave__.step();};
}
}

#line 291 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL180_MCI::abstract_port__mmc_m__Rx(const uint8_t* block, uint32_t len)
{
 if (transfer_len != 0)
 {
 
 if (!0) ; else printf("%s: MMC requested Rx  while another transfer is in process "
 "(Rx %p, Tx %p, len %u, idx=%u).\n",
 getInstanceName().c_str(), rx_addr, tx_addr, transfer_len, transfer_idx);
 }
 receiving = true;
 rx_addr = block;
 transfer_len = (len+3)/4;
 transfer_idx = 0;
 if (!0) ; else printf("%s:%d %s() new transfer_len=0x%08X\n", __FILE__, __LINE__, __FUNCTION__, transfer_len);
 update_status(true); 
 return true;
 
}
}

#line 309 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PL180_MCI::abstract_port__mmc_m__Tx(uint8_t* block, uint32_t len)
{
 if (!0) ; else printf("%s: Card called Tx with %p[%u].(MCIDataCtrl & MCIDataCtrl_EN_MASK)=0x%08x (MCIDataCtrl & MCIDataCtrl_DIR_MASK)=0x%08X MCIDataCtrl=0x%08X\n",
 getInstanceName().c_str(), block, len
 , (MCIDataCtrl & MCIDataCtrl_EN_MASK)
 , (MCIDataCtrl & MCIDataCtrl_DIR_MASK)
 , MCIDataCtrl);
 if (transfer_len != 0)
 {
 
 if (!0) ; else printf("%s: MMC requested Tx while another transfer is in process "
 "(Rx %p, Tx %p, len %u) new: Tx=%p.\n",
 getInstanceName().c_str(), rx_addr, tx_addr, transfer_len, block);
 }
 transmitting = true;
 tx_addr = block;
 transfer_len = (len+3)/4;
 transfer_idx = 0;
 update_status(true); 
 return true;
 
}
}

#line 422 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL180_MCI::abstract_port__device__read(pv::ReadTransaction tx)
{
 if (tx.getAccessWidth() > pv::ACCESS_32_BITS || !tx.isAligned()) return tx.generateAbort();

 
 return tx.setReturnData32(registerRead(tx.getAddress() & ~3));
 
}
}

#line 430 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL180_MCI::abstract_port__device__write(pv::WriteTransaction tx)
{
 if (tx.getAccessWidth() != pv::ACCESS_32_BITS || !tx.isAligned())
 return tx.generateAbort();

 registerWrite(tx.getAddress(),tx.getData32());
 return tx.writeComplete();
 
}
}

#line 439 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL180_MCI::abstract_port__device__debugRead(pv::ReadTransaction tx)
{
 return device.read(tx);
 
}
}

#line 444 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PL180_MCI.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { pv::Tx_Result 
Component__PL180_MCI::abstract_port__device__debugWrite(pv::WriteTransaction tx)
{
 return device.write(tx);
 
}
}

#line 25611 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PL180_MCI
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PL180_MCI::Component__PL180_MCI(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)



	,cadiParameterProxy_busslave_of_PVBusSlave_to_PL180_MCI__(0)

{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "ARM PrimeCell Multimedia Card Interface (PL180)";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PL180_MCI_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *PVBusSlave_factory = PVBusSlave_GetFactory();
		{
			sg::Params params_busslave__ = params.getParamsFor("busslave");
			params_busslave__["size"] = MxU64CONST(0x0000000000001000);
			add(busslave = PVBusSlave_factory->instantiate("busslave", simulationContext, params_busslave__));
		}
		PVBusSlave_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PL180_MCI::control_port__configure, this);
    bind_method(control_port, init, &Component__PL180_MCI::init, this);
    bind_method(control_port, interconnect, &Component__PL180_MCI::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PL180_MCI::postConnect, this);
    bind_method(control_port, reset, &Component__PL180_MCI::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PL180_MCI::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PL180_MCI::disconnect, this);
    bind_method(control_port, terminate, &Component__PL180_MCI::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PL180_MCI::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PL180_MCI::refresh, this);
    bind_method(control_port, step, &Component__PL180_MCI::step, this);
    bind_method(control_port, update, &Component__PL180_MCI::update, this);
    bind_method(control_port, communicate, &Component__PL180_MCI::communicate, this);
    bind_method(control_port, getProperty, &Component__PL180_MCI::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PL180_MCI::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PL180_MCI::control_port__bypass, this);
    bind_method(control_port, run, &Component__PL180_MCI::control_port__run, this);
    bind_method(control_port, stop, &Component__PL180_MCI::control_port__stop, this);
    bind_method(control_port, idle, &Component__PL180_MCI::control_port__idle, this);
    bind_method(control_port, quit, &Component__PL180_MCI::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PL180_MCI::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PL180_MCI::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PL180_MCI::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PL180_MCI::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PL180_MCI::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PL180_MCI::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PL180_MCI::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PL180_MCI::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_busslave__.connectTo(busslave->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(mmc_m, Rx, &Component__PL180_MCI::abstract_port__mmc_m__Rx, this);
	bind_method(mmc_m, Tx, &Component__PL180_MCI::abstract_port__mmc_m__Tx, this);
	bind_method(device, read, &Component__PL180_MCI::abstract_port__device__read, this);
	bind_method(device, write, &Component__PL180_MCI::abstract_port__device__write, this);
	bind_method(device, debugRead, &Component__PL180_MCI::abstract_port__device__debugRead, this);
	bind_method(device, debugWrite, &Component__PL180_MCI::abstract_port__device__debugWrite, this);


    // add abstract ports
	publishMasterPortArray("MCIINTR", MCIINTR, 2);
	{for(int i = 0; i < 2; ++i) MCIINTR[i].SetName__("MCIINTR");}
	publishMasterPort("mmc_m", mmc_m);
	mmc_m.SetName__("mmc_m");
	publishSlavePort("pvbus", pvbus);
	pvbus.SetName__("pvbus");
	device.SetName__("device");


    // wire up static connection map
	pvbus.connectTo(busslave->findPort("pvbus_s"));
	busslave->findPort("device").connectTo(device);


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PL180_MCI::~Component__PL180_MCI()
{
}

void Component__PL180_MCI::control_port__configure(const sg::Params& params)
{
	if(controlPort_busslave__.configure.implemented()) controlPort_busslave__.configure(params.getParamsFor("busslave"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PL180_MCI_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PL180_MCI::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_busslave__.populateCADIMap.implemented())
			{
				controlPort_busslave__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
			eslapi::CADI *cadi = obtainCADI__("busslave", compMap);
			if (cadi != NULL)
			{
				cadiParameterProxy_busslave_of_PVBusSlave_to_PL180_MCI__ = new CADIParameterProxy(cadi, &parameterFilter_busslave_of_PVBusSlave_to_PL180_MCI__);
			}
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PL180_MCI::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PL180_MCI::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PL180_MCI::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PL180_MCI::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PL180_MCI::control_port__run()
{
}


void Component__PL180_MCI::control_port__stop()
{
}


void Component__PL180_MCI::control_port__idle()
{
}


void Component__PL180_MCI::control_port__quit()
{
}


void Component__PL180_MCI::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PL180_MCI::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PL180_MCI::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PL180_MCI::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PL180_MCI::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PL180_MCI::freeCADIResources__()
{
    // free CADI parameter proxies
	delete cadiParameterProxy_busslave_of_PVBusSlave_to_PL180_MCI__;
	cadiParameterProxy_busslave_of_PVBusSlave_to_PL180_MCI__ = 0;


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PL180_MCI::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PL180_MCI::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PL180_MCI::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PL180_MCI::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PL180_MCI::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL180_MCI::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL180_MCI::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL180_MCI::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PL180_MCI::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PL180_MCI::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PL180_MCI::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PL180_MCI::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PL180_MCI::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PL180_MCI::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PL180_MCI::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PL180_MCI::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PL180_MCI::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PL180_MCI::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PL180_MCI::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PL180_MCI::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__PL180_MCI::reset_resources__()
{
    // resource initialization code
	MCIPower = 0; // reset register
	MCIClock = 0; // reset register
	MCIArgument = 0; // reset register
	MCICommand = 0; // reset register
	MCIRespCmd = 0; // reset register
	MCIResponse0 = 0; // reset register
	MCIResponse1 = 0; // reset register
	MCIResponse2 = 0; // reset register
	MCIResponse3 = 0; // reset register
	MCIDataTimer = 0; // reset register
	MCIDataLength = 0; // reset register
	MCIDataCtrl = 0; // reset register
	MCIDataCnt = 0; // reset register
	MCIStatus = 0; // reset register
	MCIClear = 0; // reset register
	MCIMask0 = 0; // reset register
	MCIMask1 = 0; // reset register
	MCISelect = 0; // reset register
	MCIFifoCnt = 0; // reset register
	MCIFIFO = 0; // reset register
	MCIPeriphID0 = 0; // reset register
	MCIPeriphID1 = 0; // reset register
	MCIPeriphID2 = 0; // reset register
	MCIPeriphID3 = 0; // reset register
	MCIPCellID0 = 0; // reset register
	MCIPCellID1 = 0; // reset register
	MCIPCellID2 = 0; // reset register
	MCIPCellID3 = 0; // reset register

}


} // FVP_VE_Cortex_A15x1_NMS
#line 78 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::init()
{
 {if(!controlPort_ps2_clocktimer__.init.empty()) controlPort_ps2_clocktimer__.init();};

 ps2_init();
 device_init();

 ps2_reset();
 device_reset();
 
}
}

#line 89 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::reset(int level)
{
 {if(!controlPort_ps2_clocktimer__.reset.empty()) controlPort_ps2_clocktimer__.reset(level);};
 ps2_reset();
 device_reset();
 
}
}

#line 96 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::ps2_init()
{
 
}
}

#line 100 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::ps2_reset()
{
 command_pending = false;
 ok_to_send = false;

 poll_period = 0;
 poll_active = false; 
 
 clearQueue();
 
}
}

#line 113 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::clearQueue()
{
 tx_fifo_in = 0;
 tx_fifo_out = 0;
 tx_fifo_level = 0; 
 
}
}

#line 120 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::queueData(uint8_t* buf, uint8_t count)
{
 if (ok_to_send && !__PS2Keyboard_internal_1.isSet()) {
 __PS2Keyboard_internal_1.set(8); 
 }

 if (tx_fifo_level+count >= tx_fifo_max)
 {
 if (!0) ; else printf("ps2 queue overflow\n");
 return;
 }

 while (tx_fifo_level < tx_fifo_max && count > 0)
 {
 tx_fifo[tx_fifo_in++] = *buf++;
 if (tx_fifo_in == tx_fifo_max)
 tx_fifo_in = 0;
 tx_fifo_level++;

 --count;
 } 
 
}
}

#line 204 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::device_init()
{
 init_keymaps();
 
}
}

#line 209 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::device_reset()
{
 scancode_set = 2;
 lastbyte = 0;
 command_pos = 0;
 
}
}

#line 216 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::reply1(uint8_t data)
{
 queueData(&data, 1);
 
}
}

#line 221 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::reply2(uint8_t data1, uint8_t data2)
{
 uint8_t buf[2];
 buf[0] = data1;
 buf[1] = data2;

 queueData(buf, 2);
 
}
}

#line 230 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::Command(uint8_t data)
{
 
 clearQueue();

 if (command_pos == 0)
 command = data;

 switch (command)
 {
 case 0xf0:
 if (command_pos == 0)
 {
 reply1(PS2_ACK);
 command_pos++;
 }
 else if (command_pos == 1)
 {
 reply1(PS2_ACK);
 if (data == 0)
 {
 reply1(scancode_set);
 }
 else
 {
 scancode_set = data;
 if (scancode_set > 3)
 scancode_set = 1;
 }
 command_pos = 0;
 }
 break;
 case 0xf2: 
 reply2(0xab, 0x83);
 break;
 case 0xf3: 
 if (command_pos == 0)
 command_pos = 1;
 else
 command_pos = 0;
 reply1(PS2_ACK);
 break;
 case 0xf4: 
 reply1(PS2_ACK);
 break;
 case 0xee: 
 reply1(0xee);
 break;
 case 0xed: 
 if (command_pos == 0)
 command_pos = 1;
 else
 command_pos = 0;

 reply1(PS2_ACK);
 break;
 case 0xf8: 
 reply1(PS2_ACK);
 break;
 case 0xff: 
 reply2(PS2_ACK, 0xaa);
 break;
 case 0xfe: 
 reply1(lastbyte);
 break;
 default:
 if (!0) ; else printf("unknown PS/2 keyboard command %d\n", data);
 reply1(PS2_ACK);
 break;
 }
 
}
}

#line 358 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::init_keymaps()
{
 static struct KeyMap scancode1_map[] =
 {
 { KC_ESCAPE, 0x01 },
 { KC_F1, 0x3b },
 { KC_F2, 0x3c },
 { KC_F3, 0x3d },
 { KC_F4, 0x3e },
 { KC_F5, 0x3f },
 { KC_F6, 0x40 },
 { KC_F7, 0x41 },
 { KC_F8, 0x42 },
 { KC_F9, 0x43 },
 { KC_F10, 0x44 },
 { KC_F11, 0x57 },
 { KC_F12, 0x58 },
 { KC_PRINT, 0xe0 },
 { KC_SCROLL, 0x46 },
 { KC_BREAK, 0xe0 },

 { KC_GRAVE, 0x29 },
 { KC_1, 0x02 },
 { KC_2, 0x03 },
 { KC_3, 0x04 },
 { KC_4, 0x05 },
 { KC_5, 0x06 },
 { KC_6, 0x07 },
 { KC_7, 0x08 },
 { KC_8, 0x09 },
 { KC_9, 0x0a },
 { KC_0, 0x0b },
 { KC_MINUS, 0x0c },
 { KC_EQUALS, 0x0d },
 { KC_BACK, 0x0e },
 
 { KC_TAB, 0x0f },
 { KC_Q, 0x10 },
 { KC_W, 0x11 },
 { KC_E, 0x12 },
 { KC_R, 0x13 },
 { KC_T, 0x14 },
 { KC_Y, 0x15 },
 { KC_U, 0x16 },
 { KC_I, 0x17 },
 { KC_O, 0x18 },
 { KC_P, 0x19 },
 { KC_LBRACKET,0x1a },
 { KC_RBRACKET,0x1b },
 { KC_BACKSLASH,0x2b },

 { KC_LCONTROL,0x1d },
 { KC_A, 0x1e },
 { KC_S, 0x1f },
 { KC_D, 0x20 },
 { KC_F, 0x21 },
 { KC_G, 0x22 },
 { KC_H, 0x23 },
 { KC_J, 0x24 },
 { KC_K, 0x25 },
 { KC_L, 0x26 },
 { KC_SEMICOLON, 0x27 },
 { KC_APOSTROPHE, 0x28 },
 { KC_RETURN, 0x1c },

 { KC_LSHIFT, 0x2a },
 { KC_Z, 0x2c },
 { KC_X, 0x2d },
 { KC_C, 0x2e },
 { KC_V, 0x2f },
 { KC_B, 0x30 },
 { KC_N, 0x31 },
 { KC_M, 0x32 },
 { KC_COMMA, 0x33 },
 { KC_PERIOD, 0x34 },
 { KC_SLASH, 0x35 },
 { KC_RSHIFT, 0x36 },

 { KC_CAPS, 0x3a },
 { KC_LALT, 0x38 },
 { KC_SPACE, 0x39 },
 { KC_RALT, 0xe0 },
 { KC_RCONTROL,0xe0 },

 { KC_INSERT, 0xe0 },
 { KC_HOME, 0xe0 },
 { KC_PGUP, 0xe0 },

 { KC_DELETE, 0xe0 },
 { KC_END, 0xe0 },
 { KC_PGDN, 0xe0 },

 { KC_UP, 0xe0 },
 { KC_LEFT, 0xe0 },
 { KC_DOWN, 0xe0 },
 { KC_RIGHT, 0xe0 },
 
 { KC_NUMLOCK, 0x45 },
 { KC_DIVIDE, 0xe0 },
 { KC_MULTIPLY,0x37 },

 { KC_NUMPAD7, 0x47 },
 { KC_NUMPAD8, 0x48 },
 { KC_NUMPAD9, 0x49 },
 { KC_SUBTRACT,0x4a },

 { KC_NUMPAD4, 0x4b }, 
 { KC_NUMPAD5, 0x4c },
 { KC_NUMPAD6, 0x4d },
 { KC_ADD, 0x4e },

 { KC_NUMPAD1, 0x4f },
 { KC_NUMPAD2, 0x50 },
 { KC_NUMPAD3, 0x51 },
 { KC_NUMPADENTER, 0xe0 },

 { KC_NUMPAD0, 0x52 },
 { KC_DECIMAL, 0x53 },

 
 { KC_LWIN, 0xe0 },
 { KC_RWIN, 0xe0 },
 { KC_POWER, 0xe0 },
 { KC_SLEEP, 0xe0 },
 { KC_WAKE, 0xe0 },

 { KC_MAX, 0 }
 };

 
 static struct KeyMap scancode1_ext_map[] =
 {
 { KC_PRINT, 0x37 },
 { KC_BREAK, 0x46 },
 { KC_RALT, 0x38 },
 { KC_RCONTROL, 0x1d },

 { KC_INSERT, 0x52 },
 { KC_HOME, 0x47 },
 { KC_PGUP, 0x49 },

 { KC_DELETE, 0x53 },
 { KC_END, 0x4f },
 { KC_PGDN, 0x51 },

 { KC_UP, 0x48 },
 { KC_LEFT, 0x4b },
 { KC_DOWN, 0x50 },
 { KC_RIGHT, 0x4d },
 { KC_DIVIDE, 0x35 },
 { KC_NUMPADENTER, 0x1c },
 { KC_LWIN, 0x5b },
 { KC_RWIN, 0x5c },
 { KC_POWER, 0x5e },
 { KC_SLEEP, 0x5f },
 { KC_WAKE, 0x63 },

 { KC_MAX, 0 }
 };

 static struct KeyMap scancode2_map[] =
 {
 { KC_ESCAPE, 0x76 },
 { KC_F1, 0x05 },
 { KC_F2, 0x06 },
 { KC_F3, 0x04 },
 { KC_F4, 0x0c },
 { KC_F5, 0x03 },
 { KC_F6, 0x0b },
 { KC_F7, 0x83 },
 { KC_F8, 0x0a },
 { KC_F9, 0x01 },
 { KC_F10, 0x09 },
 { KC_F11, 0x78 },
 { KC_F12, 0x07 },
 { KC_PRINT, 0xe0 },
 { KC_SCROLL, 0x7e },
 { KC_BREAK, 0xe0 },

 { KC_GRAVE, 0xe },
 { KC_1, 0x16 },
 { KC_2, 0x1e },
 { KC_3, 0x26 },
 { KC_4, 0x25 },
 { KC_5, 0x2e },
 { KC_6, 0x36 },
 { KC_7, 0x3d },
 { KC_8, 0x3e },
 { KC_9, 0x46 },
 { KC_0, 0x45 },
 { KC_MINUS, 0x4e },
 { KC_EQUALS, 0x55 },
 { KC_BACK, 0x66 },
 
 { KC_TAB, 0x0d },
 { KC_Q, 0x15 },
 { KC_W, 0x1d },
 { KC_E, 0x24 },
 { KC_R, 0x2d },
 { KC_T, 0x2c },
 { KC_Y, 0x35 },
 { KC_U, 0x3c },
 { KC_I, 0x43 },
 { KC_O, 0x44 },
 { KC_P, 0x4d },
 { KC_LBRACKET,0x54 },
 { KC_RBRACKET,0x5b },
 { KC_BACKSLASH, 0x61},

 { KC_LCONTROL,0x14 },
 { KC_A, 0x1c },
 { KC_S, 0x1b },
 { KC_D, 0x23 },
 { KC_F, 0x2b },
 { KC_G, 0x34 },
 { KC_H, 0x33 },
 { KC_J, 0x3b },
 { KC_K, 0x42 },
 { KC_L, 0x4b },
 { KC_SEMICOLON, 0x4c },
 { KC_APOSTROPHE, 0x52 },
 { KC_RETURN, 0x5a },

 { KC_LSHIFT, 0x12 },
 { KC_Z, 0x1a },
 { KC_X, 0x22 },
 { KC_C, 0x21 },
 { KC_V, 0x2a },
 { KC_B, 0x32 },
 { KC_N, 0x31 },
 { KC_M, 0x3a },
 { KC_COMMA, 0x41 },
 { KC_PERIOD, 0x49 },
 { KC_SLASH, 0x4a },
 { KC_RSHIFT, 0x59 },

 { KC_CAPS, 0x58 },
 { KC_LALT, 0x11 },
 { KC_SPACE, 0x29 },
 { KC_RALT, 0xe0 },
 { KC_RCONTROL,0xe0 },

 { KC_INSERT, 0xe0 },
 { KC_HOME, 0xe0 },
 { KC_PGUP, 0xe0 },

 { KC_DELETE, 0xe0 },
 { KC_END, 0xe0 },
 { KC_PGDN, 0xe0 },

 { KC_UP, 0xe0 },
 { KC_LEFT, 0xe0 },
 { KC_DOWN, 0xe0 },
 { KC_RIGHT, 0xe0 },
 
 { KC_NUMLOCK, 0x77 },
 { KC_DIVIDE, 0xe0 },
 { KC_MULTIPLY,0x7c },
 { KC_HASH, 0x5d }, 

 { KC_NUMPAD7, 0x6c },
 { KC_NUMPAD8, 0x75 },
 { KC_NUMPAD9, 0x7d },
 { KC_SUBTRACT,0x7b },

 { KC_NUMPAD4, 0x6b }, 
 { KC_NUMPAD5, 0x73 },
 { KC_NUMPAD6, 0x74 },
 { KC_ADD, 0x79 },

 { KC_NUMPAD1, 0x69 },
 { KC_NUMPAD2, 0x72 },
 { KC_NUMPAD3, 0x7a },
 { KC_NUMPADENTER, 0xe0 },

 { KC_NUMPAD0, 0x70 },
 { KC_DECIMAL, 0x71 },

 
 { KC_LWIN, 0xe0 },
 { KC_RWIN, 0xe0 },
 { KC_POWER, 0xe0 },
 { KC_SLEEP, 0xe0 },
 { KC_WAKE, 0xe0 },

 { KC_MAX, 0 }
 };

 
 static struct KeyMap scancode2_ext_map[] =
 {
 { KC_PRINT, 0x7c },
 { KC_BREAK, 0x7e },
 { KC_RALT, 0x11},
 { KC_RCONTROL, 0x14 },

 { KC_INSERT, 0x70 },
 { KC_HOME, 0x6c },
 { KC_PGUP, 0x7d },

 { KC_DELETE, 0x71 },
 { KC_END, 0x69 },
 { KC_PGDN, 0x7a },

 { KC_UP, 0x75 },
 { KC_LEFT, 0x6b },
 { KC_DOWN, 0x72 },
 { KC_RIGHT, 0x74 },
 { KC_DIVIDE, 0x4a },
 { KC_NUMPADENTER, 0x5a },
 { KC_LWIN, 0x1f },
 { KC_RWIN, 0x27 },
 { KC_POWER, 0x37 },
 { KC_SLEEP, 0x3f },
 { KC_WAKE, 0x5e },

 { KC_MAX, 0 }
 };

 static struct KeyMap scancode3_map[] =
 {
 { KC_ESCAPE, 0x08 },
 { KC_F1, 0x07 },
 { KC_F2, 0x0f },
 { KC_F3, 0x17 },
 { KC_F4, 0x1f },
 { KC_F5, 0x27 },
 { KC_F6, 0x2f },
 { KC_F7, 0x37 },
 { KC_F8, 0x3f },
 { KC_F9, 0x47 },
 { KC_F10, 0x4f },
 { KC_F11, 0x56 },
 { KC_F12, 0x5e },
 { KC_PRINT, 0x57 },
 { KC_SCROLL, 0x5f },
 { KC_BREAK, 0x62 },

 { KC_GRAVE, 0xe },
 { KC_1, 0x16 },
 { KC_2, 0x1e },
 { KC_3, 0x26 },
 { KC_4, 0x25 },
 { KC_5, 0x2e },
 { KC_6, 0x36 },
 { KC_7, 0x3d },
 { KC_8, 0x3e },
 { KC_9, 0x46 },
 { KC_0, 0x45 },
 { KC_MINUS, 0x4e },
 { KC_EQUALS, 0x55 },
 { KC_BACK, 0x66 },
 
 { KC_TAB, 0x0d },
 { KC_Q, 0x15 },
 { KC_W, 0x1d },
 { KC_E, 0x24 },
 { KC_R, 0x2d },
 { KC_T, 0x2c },
 { KC_Y, 0x35 },
 { KC_U, 0x3c },
 { KC_I, 0x43 },
 { KC_O, 0x44 },
 { KC_P, 0x4d },
 { KC_LBRACKET,0x54 },
 { KC_RBRACKET,0x5b },
 { KC_BACKSLASH,0x5c },

 { KC_LCONTROL,0x11 },
 { KC_A, 0x1c },
 { KC_S, 0x1b },
 { KC_D, 0x23 },
 { KC_F, 0x2b },
 { KC_G, 0x34 },
 { KC_H, 0x33 },
 { KC_J, 0x3b },
 { KC_K, 0x42 },
 { KC_L, 0x4b },
 { KC_SEMICOLON, 0x4c },
 { KC_APOSTROPHE, 0x52 },
 { KC_RETURN, 0x5a },

 { KC_LSHIFT, 0x12 },
 { KC_Z, 0x1a },
 { KC_X, 0x22 },
 { KC_C, 0x21 },
 { KC_V, 0x2a },
 { KC_B, 0x32 },
 { KC_N, 0x31 },
 { KC_M, 0x3a },
 { KC_COMMA, 0x41 },
 { KC_PERIOD, 0x49 },
 { KC_SLASH, 0x4a },
 { KC_RSHIFT, 0x59 },

 { KC_CAPS, 0x14 },
 { KC_LALT, 0x19 },
 { KC_SPACE, 0x29 },
 { KC_RALT, 0x39 },
 { KC_RCONTROL,0x58 },

 { KC_INSERT, 0x67 },
 { KC_HOME, 0x6e },
 { KC_PGUP, 0x6f },

 { KC_DELETE, 0x64 },
 { KC_END, 0x65 },
 { KC_PGDN, 0x6d },

 { KC_UP, 0x6e },
 { KC_LEFT, 0x61 },
 { KC_DOWN, 0x60 },
 { KC_RIGHT, 0x6a },
 
 { KC_NUMLOCK, 0x76 },
 { KC_DIVIDE, 0x77 },
 { KC_MULTIPLY,0x7e },

 { KC_NUMPAD7, 0x6c },
 { KC_NUMPAD8, 0x75 },
 { KC_NUMPAD9, 0x7d },
 { KC_SUBTRACT,0x84 },

 { KC_NUMPAD4, 0x6b }, 
 { KC_NUMPAD5, 0x73 },
 { KC_NUMPAD6, 0x74 },
 { KC_ADD, 0x7c },

 { KC_NUMPAD1, 0x69 },
 { KC_NUMPAD2, 0x72 },
 { KC_NUMPAD3, 0x7a },
 { KC_NUMPADENTER, 0x79 },

 { KC_NUMPAD0, 0x70 },
 { KC_DECIMAL, 0x71 },

 
 { KC_LWIN, 0x8b },
 { KC_RWIN, 0x8c },
 { KC_SLEEP, 0x54 },

 { KC_MAX, 0 }
 };

 
 static struct KeyMap scancode3_ext_map[] =
 {
 { KC_MAX, 0 }
 };

 
 int i;

 for (i=0; i<KC_MAX; ++i)
 {
 scancode[0][i] = 0;
 scancode[1][i] = 0;
 scancode[2][i] = 0;
 scancode_ext[0][i] = 0;
 scancode_ext[1][i] = 0;
 scancode_ext[2][i] = 0;
 }
 for (i=0; scancode1_map[i].kc != KC_MAX; ++i)
 scancode[0][scancode1_map[i].kc] = scancode1_map[i].ps2;
 for (i=0; scancode2_map[i].kc != KC_MAX; ++i)
 scancode[1][scancode2_map[i].kc] = scancode2_map[i].ps2;
 for (i=0; scancode3_map[i].kc != KC_MAX; ++i)
 scancode[2][scancode3_map[i].kc] = scancode3_map[i].ps2;

 for (i=0; scancode1_ext_map[i].kc != KC_MAX; ++i)
 scancode_ext[0][scancode1_ext_map[i].kc] = scancode1_ext_map[i].ps2;
 for (i=0; scancode2_ext_map[i].kc != KC_MAX; ++i)
 scancode_ext[1][scancode2_ext_map[i].kc] = scancode2_ext_map[i].ps2;
 for (i=0; scancode3_ext_map[i].kc != KC_MAX; ++i)
 scancode_ext[2][scancode3_ext_map[i].kc] = scancode3_ext_map[i].ps2;
 
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::interconnect()
{{if(!controlPort_ps2_clocktimer__.interconnect.empty()) controlPort_ps2_clocktimer__.interconnect();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::disconnect()
{{if(!controlPort_ps2_clocktimer__.disconnect.empty()) controlPort_ps2_clocktimer__.disconnect();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::update()
{{if(!controlPort_ps2_clocktimer__.update.empty()) controlPort_ps2_clocktimer__.update();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::communicate()
{{if(!controlPort_ps2_clocktimer__.communicate.empty()) controlPort_ps2_clocktimer__.communicate();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::traceEndOfCycle()
{{if(!controlPort_ps2_clocktimer__.traceEndOfCycle.empty()) controlPort_ps2_clocktimer__.traceEndOfCycle();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::loadApplicationFile(const std::string& filename)
{{if(!controlPort_ps2_clocktimer__.loadApplicationFile.empty()) controlPort_ps2_clocktimer__.loadApplicationFile(filename);};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::terminate()
{{if(!controlPort_ps2_clocktimer__.terminate.empty()) controlPort_ps2_clocktimer__.terminate();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PS2Keyboard::save(MxODataStream& os)
{{if(!controlPort_ps2_clocktimer__.save.empty()) controlPort_ps2_clocktimer__.save(os);};return true;
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PS2Keyboard::restore(MxIDataStream& is)
{{if(!controlPort_ps2_clocktimer__.restore.empty()) controlPort_ps2_clocktimer__.restore(is);};return true;
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::step()
{{if(!controlPort_ps2_clocktimer__.step.empty()) controlPort_ps2_clocktimer__.step();};
}
}

#line 146 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::abstract_port__ps2__setClockData(enum ps2clockdata_state state)
{
 command_pending = (state == PS2_Request_To_Send);
 ok_to_send = (state == PS2_Ready);
 
 if (ok_to_send && tx_fifo_level > 0)
 poll_period = 8;
 else if (command_pending)
 poll_period = 64;
 else
 poll_period = 0;

 
 
 
 if (!poll_active)
 {
 if (poll_period > 0) {
 __PS2Keyboard_internal_1.set(poll_period);
 } else {
 __PS2Keyboard_internal_1.cancel();
 }
 } 
 
}
}

#line 174 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PS2Keyboard::abstract_port__ps2_timer_callback__signal()
{
 poll_active = true;

 if (command_pending) {
 uint8_t data = ps2.getData();
 Command(data);
 }
 
 if (ok_to_send && tx_fifo_level > 0) {
 uint8_t data = tx_fifo[tx_fifo_out];
 
 if (++tx_fifo_out == tx_fifo_max) {
 tx_fifo_out = 0;
 }

 --tx_fifo_level;

 ps2.putData(data);
 }

 poll_active = false;

 
 return poll_period;
 
}
}

#line 305 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::abstract_port__keyboard__keyDown(ATKeyCode code)
{
 uint8_t buf[3];
 uint8_t count = 0;

 uint8_t set = scancode_set-1;

 uint8_t ps2 = scancode[set][code];
 if (ps2 == 0xe0)
 {
 buf[count++] = 0xe0;
 ps2 = scancode_ext[set][code];
 }

 if (ps2 != 0)
 buf[count++] = ps2;
 else
 return;

 queueData(buf, count);
 
}
}

#line 327 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Keyboard.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Keyboard::abstract_port__keyboard__keyUp(ATKeyCode code)
{
 uint8_t buf[3];
 uint8_t count = 0;

 uint8_t set = scancode_set-1;

 uint8_t ps2 = scancode[set][code];
 if (ps2 == 0xe0)
 {
 buf[count++] = 0xe0;
 ps2 = scancode_ext[set][code];
 }

 if (ps2 != 0)
 {
 if (set == 0)
 buf[count++] = ps2+0x80;
 else
 {
 buf[count++] = 0xf0;
 buf[count++] = ps2;
 }
 }
 else
 return;

 queueData(buf, count);
 
}
}

#line 27070 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PS2Keyboard
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PS2Keyboard::Component__PS2Keyboard(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)




{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Interface component, which takes the keypress/release signals from the Visualisation component and translates them into clocked PS2Data signals which can be routed to a PL050_KMI component.";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PS2Keyboard_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		{
			sg::Params params_ps2_clocktimer__ = params.getParamsFor("ps2_clocktimer");
			add(ps2_clocktimer = ClockTimer_factory->instantiate("ps2_clocktimer", simulationContext, params_ps2_clocktimer__));
		}
		ClockTimer_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PS2Keyboard::control_port__configure, this);
    bind_method(control_port, init, &Component__PS2Keyboard::init, this);
    bind_method(control_port, interconnect, &Component__PS2Keyboard::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PS2Keyboard::postConnect, this);
    bind_method(control_port, reset, &Component__PS2Keyboard::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PS2Keyboard::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PS2Keyboard::disconnect, this);
    bind_method(control_port, terminate, &Component__PS2Keyboard::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PS2Keyboard::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PS2Keyboard::refresh, this);
    bind_method(control_port, step, &Component__PS2Keyboard::step, this);
    bind_method(control_port, update, &Component__PS2Keyboard::update, this);
    bind_method(control_port, communicate, &Component__PS2Keyboard::communicate, this);
    bind_method(control_port, getProperty, &Component__PS2Keyboard::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PS2Keyboard::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PS2Keyboard::control_port__bypass, this);
    bind_method(control_port, run, &Component__PS2Keyboard::control_port__run, this);
    bind_method(control_port, stop, &Component__PS2Keyboard::control_port__stop, this);
    bind_method(control_port, idle, &Component__PS2Keyboard::control_port__idle, this);
    bind_method(control_port, quit, &Component__PS2Keyboard::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PS2Keyboard::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PS2Keyboard::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PS2Keyboard::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PS2Keyboard::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PS2Keyboard::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PS2Keyboard::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PS2Keyboard::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PS2Keyboard::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_ps2_clocktimer__.connectTo(ps2_clocktimer->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(ps2, setClockData, &Component__PS2Keyboard::abstract_port__ps2__setClockData, this);
	bind_method(ps2_timer_callback, signal, &Component__PS2Keyboard::abstract_port__ps2_timer_callback__signal, this);
	bind_method(keyboard, keyDown, &Component__PS2Keyboard::abstract_port__keyboard__keyDown, this);
	bind_method(keyboard, keyUp, &Component__PS2Keyboard::abstract_port__keyboard__keyUp, this);


    // add abstract ports
	publishSlavePort("clk_in", clk_in);
	clk_in.SetName__("clk_in");
	publishMasterPort("ps2", ps2);
	ps2.SetName__("ps2");
	ps2_timer_callback.SetName__("ps2_timer_callback");
	publishSlavePort("keyboard", keyboard);
	keyboard.SetName__("keyboard");
	__PS2Keyboard_internal_1.SetName__("__PS2Keyboard_internal_1");


    // wire up static connection map
	clk_in.connectTo(ps2_clocktimer->findPort("clk_in"));
	ps2_clocktimer->findPort("timer_callback").connectTo(ps2_timer_callback);
	__PS2Keyboard_internal_1.connectTo(ps2_clocktimer->findPort("timer_control"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PS2Keyboard::~Component__PS2Keyboard()
{
}

void Component__PS2Keyboard::control_port__configure(const sg::Params& params)
{
	if(controlPort_ps2_clocktimer__.configure.implemented()) controlPort_ps2_clocktimer__.configure(params.getParamsFor("ps2_clocktimer"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PS2Keyboard_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PS2Keyboard::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_ps2_clocktimer__.populateCADIMap.implemented())
			{
				controlPort_ps2_clocktimer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PS2Keyboard::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PS2Keyboard::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PS2Keyboard::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PS2Keyboard::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PS2Keyboard::control_port__run()
{
}


void Component__PS2Keyboard::control_port__stop()
{
}


void Component__PS2Keyboard::control_port__idle()
{
}


void Component__PS2Keyboard::control_port__quit()
{
}


void Component__PS2Keyboard::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PS2Keyboard::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PS2Keyboard::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PS2Keyboard::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PS2Keyboard::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PS2Keyboard::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PS2Keyboard::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PS2Keyboard::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PS2Keyboard::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PS2Keyboard::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PS2Keyboard::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PS2Keyboard::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PS2Keyboard::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PS2Keyboard::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PS2Keyboard::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PS2Keyboard::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PS2Keyboard::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PS2Keyboard::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PS2Keyboard::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PS2Keyboard::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PS2Keyboard::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PS2Keyboard::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PS2Keyboard::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PS2Keyboard::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PS2Keyboard::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PS2Keyboard::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__PS2Keyboard::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS
#line 76 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::init()
{
 {if(!controlPort_ps2_clocktimer__.init.empty()) controlPort_ps2_clocktimer__.init();};
 ps2_init();
 device_init();
 
}
}

#line 83 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::reset(int level)
{
 {if(!controlPort_ps2_clocktimer__.reset.empty()) controlPort_ps2_clocktimer__.reset(level);};
 ps2_reset();
 device_reset();
 
}
}

#line 90 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::ps2_init()
{
 ps2_reset();
 
}
}

#line 95 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::ps2_reset()
{
 command_pending = false;
 ok_to_send = false;

 poll_period = 0;
 poll_active = false; 
 
 clearQueue();
 
}
}

#line 108 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::clearQueue()
{
 tx_fifo_in = 0;
 tx_fifo_out = 0;
 tx_fifo_level = 0; 
 
}
}

#line 115 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::queueData(uint8_t* buf, uint8_t count)
{
 if (ok_to_send && !__PS2Mouse_internal_1.isSet()) {
 __PS2Mouse_internal_1.set(8); 
 }

 if (tx_fifo_level+count >= tx_fifo_max)
 {
 if (!0) ; else printf("ps2 queue overflow\n");
 return;
 }

 while (tx_fifo_level < tx_fifo_max && count > 0)
 {
 tx_fifo[tx_fifo_in++] = *buf++;
 if (tx_fifo_in == tx_fifo_max)
 tx_fifo_in = 0;
 tx_fifo_level++;

 --count;
 } 
 
}
}

#line 199 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::device_init()
{
 
 
}
}

#line 204 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::device_reset()
{
 enabled = false;
 stream = false;
 scaling = false;
 wrapmode = false;
 resolution = 0;
 samplerate = 0;

 buttons = 0;
 command_pos = 0;
 command = 0;
 
}
}

#line 218 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::Reply1(uint8_t data)
{
 queueData(&data, 1);
 
}
}

#line 223 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::Reply2(uint8_t data1, uint8_t data2)
{
 uint8_t buf[2];
 buf[0] = data1;
 buf[1] = data2;

 queueData(buf, 2);
 
}
}

#line 232 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::Command(uint8_t data)
{
 
 clearQueue();

 if (command_pos == 0)
 command = data;

 switch (command)
 {
 case 0xf0: 
 stream = false;
 Reply1(PS2_ACK);
 break;
 case 0xea: 
 stream = true;
 Reply1(PS2_ACK);
 break;
 case 0xf2: 
 Reply2(PS2_ACK, 0);
 break;
 case 0xe6: 
 scaling = false;
 Reply1(PS2_ACK);
 break;
 case 0xe7: 
 scaling = true;
 Reply1(PS2_ACK);
 break;
 case 0xe8: 
 if (command_pos == 0)
 {
 command_pos = 1;
 }
 else
 {
 resolution = data;
 command_pos = 0;
 }
 Reply1(PS2_ACK);
 break;
 case 0xe9: 
 Reply1((stream ? (1<<6) : 0) |
 (enabled ? (1<<5) : 0) |
 (scaling ? (1<<4) : 0) |
 (buttons & 7));
 Reply1(resolution);
 Reply1(samplerate);
 break;
 case 0xec: 
 wrapmode = false;
 Reply1(PS2_ACK);
 break;
 case 0xee: 
 wrapmode = true;
 Reply1(PS2_ACK);
 break;
 case 0xf3: 
 if (command_pos == 0)
 {
 command_pos = 1;
 }
 else
 {
 samplerate = data;
 command_pos = 0;
 }
 Reply1(PS2_ACK);
 break;
 case 0xf4: 
 enabled = true;
 Reply1(PS2_ACK);
 break;
 case 0xf5: 
 enabled = false;
 Reply1(PS2_ACK);
 break;
 case 0xf6: 
 samplerate = 100;
 resolution = 2;
 scaling = 0;
 enabled = false;
 stream = true;
 Reply1(PS2_ACK);
 break;
 case 0xff: 
 wrapmode = false;
 enabled = false;
 Reply1(PS2_ACK);
 Reply2(0xaa, 0);
 break;
 default:
 if (!0) ; else printf("unknown PS/2 Mouse command %d\n", data);
 break;
 }
 
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::interconnect()
{{if(!controlPort_ps2_clocktimer__.interconnect.empty()) controlPort_ps2_clocktimer__.interconnect();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::disconnect()
{{if(!controlPort_ps2_clocktimer__.disconnect.empty()) controlPort_ps2_clocktimer__.disconnect();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::update()
{{if(!controlPort_ps2_clocktimer__.update.empty()) controlPort_ps2_clocktimer__.update();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::communicate()
{{if(!controlPort_ps2_clocktimer__.communicate.empty()) controlPort_ps2_clocktimer__.communicate();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::traceEndOfCycle()
{{if(!controlPort_ps2_clocktimer__.traceEndOfCycle.empty()) controlPort_ps2_clocktimer__.traceEndOfCycle();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::loadApplicationFile(const std::string& filename)
{{if(!controlPort_ps2_clocktimer__.loadApplicationFile.empty()) controlPort_ps2_clocktimer__.loadApplicationFile(filename);};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::terminate()
{{if(!controlPort_ps2_clocktimer__.terminate.empty()) controlPort_ps2_clocktimer__.terminate();};
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PS2Mouse::save(MxODataStream& os)
{{if(!controlPort_ps2_clocktimer__.save.empty()) controlPort_ps2_clocktimer__.save(os);};return true;
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { bool 
Component__PS2Mouse::restore(MxIDataStream& is)
{{if(!controlPort_ps2_clocktimer__.restore.empty()) controlPort_ps2_clocktimer__.restore(is);};return true;
}
}

#line 9 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::step()
{{if(!controlPort_ps2_clocktimer__.step.empty()) controlPort_ps2_clocktimer__.step();};
}
}

#line 141 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::abstract_port__ps2__setClockData(enum ps2clockdata_state state)
{
 command_pending = (state == PS2_Request_To_Send);
 ok_to_send = (state == PS2_Ready);
 
 if (ok_to_send && tx_fifo_level > 0)
 poll_period = 8;
 else if (command_pending)
 poll_period = 64;
 else
 poll_period = 0;

 
 
 
 if (!poll_active)
 {
 if (poll_period > 0) {
 __PS2Mouse_internal_1.set(poll_period);
 } else {
 __PS2Mouse_internal_1.cancel();
 }
 } 
 
}
}

#line 169 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { uint32_t 
Component__PS2Mouse::abstract_port__ps2_timer_callback__signal()
{
 poll_active = true;

 if (command_pending) {
 uint8_t data = ps2.getData();
 Command(data);
 }
 
 if (ok_to_send && tx_fifo_level > 0) {
 uint8_t data = tx_fifo[tx_fifo_out];
 
 if (++tx_fifo_out == tx_fifo_max) {
 tx_fifo_out = 0;
 }

 --tx_fifo_level;

 ps2.putData(data);
 }

 poll_active = false;

 
 return poll_period;
 
}
}

#line 332 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::abstract_port__mouse__mouseMove(int dx, int dy)
{
 if (!0) ; else printf("Mouse move %d, %d\n", dx, dy);
 dy = -dy;

 bool xo = false;
 bool yo = false;

 if (dx> 255) { dx = 255; xo = true; }
 if (dx<-255) { dx = -255; xo = true; }
 if (dy> 255) { dy = 255; yo = true; }
 if (dy<-255) { dy = -255; yo = true; }

 if (enabled)
 {
 uint8_t buf[3];
 buf[0] = buttons |
 (1<<3) |
 ((dx<0) ? (1<<4) : 0) |
 ((dy<0) ? (1<<5) : 0) |
 (xo ? (1<<6) : 0) |
 (yo ? (1<<7) : 0);

 buf[1] = dx & 0xff;
 buf[2] = dy & 0xff;

 queueData(buf, 3);
 }
 
}
}

#line 362 "/home/sxcheng/Workspace/kvm/ARM/FastModelsPortfolio_8.1/LISA/PS2Mouse.lisa"
namespace FVP_VE_Cortex_A15x1_NMS { void 
Component__PS2Mouse::abstract_port__mouse__mouseButton(uint8_t button, bool down)
{
 if (!0) ; else printf("Mouse button %d %s\n", button, down ? "down" : "up"); 
 if (button == 1)
 {
 if (down)
 buttons |= 1;
 else
 buttons &=~ 1;
 }
 else if (button == 3)
 {
 if (down)
 buttons |= 2;
 else
 buttons &=~ 2;
 }
 else if (button == 2)
 {
 if (down)
 buttons |= 4;
 else
 buttons &=~4;
 }
 
 if (enabled)
 {
 
 uint8_t buf[3];
 buf[0] = buttons | (1<<3);
 buf[1] = 0;
 buf[2] = 0;

 queueData(buf, 3);
 }
 
}
}

#line 28055 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// ------------------------------------------------------------------------------
// implementation of class Component__PS2Mouse
// ------------------------------------------------------------------------------

namespace FVP_VE_Cortex_A15x1_NMS {

Component__PS2Mouse::Component__PS2Mouse(const char * instName, sg::SimulationContext* simulationContext, const sg::Params & params):
    SystemGenComponent(instName, simulationContext, params)




{
    // initialize properties__
	properties__["component_name"] = "";
	properties__["component_type"] = "Peripheral";
	properties__["debugger_name"] = "";
	properties__["debugger_start_command"] = "";
	properties__["default_view"] = "auto";
	properties__["description"] = "Interface component, which takes the keypress/release signals from the Visualisation component and translates them into clocked PS2Data signals which can be routed to a PL050_KMI component.";
	properties__["documentation_file"] = "../Docs/DUI0423O_fast_model_rm.pdf";
	properties__["dso_safe"] = "1";
	properties__["executes_software"] = "0";
	properties__["expose_extern_sub_component_cadi"] = "1";
	properties__["factory_namespace"] = "";
	properties__["has_cadi"] = "1";
	properties__["has_implicit_clk_in"] = "1";
	properties__["hidden"] = "0";
	properties__["icon_file"] = "";
	properties__["ip_provider"] = "";
	properties__["is_single_stepped"] = "0";
	properties__["license_feature"] = "";
	properties__["loadfile_extension"] = "";
	properties__["save_restore"] = "0";
	properties__["small_icon_file"] = "";
	properties__["variant"] = "";
	properties__["version"] = "8.1.37";

    // initialize parameter info
    {
        sg::ComponentFactory *factory = PS2Mouse_GetFactory();

        sg::TargetInfo *targetInfo = factory->getTargetInfo(""); // empty string means 'this' component

        if(targetInfo) // if we have no target info we also have no parameters towards CADI interfaces
        {
            // get parameter infos
            for(unsigned int i = 0; i < targetInfo->parameter_count; i++)
            {
                parameterId2parameterName__[targetInfo->parameter_info[i].id] = targetInfo->parameter_info[i].name;
                parameterInfos__.push_back((targetInfo->parameter_info)[i]);
            }
        }

        factory->dereference();
    }

    // create subcomponents
	{
		sg::ComponentFactory *ClockTimer_factory = ClockTimer_GetFactory();
		{
			sg::Params params_ps2_clocktimer__ = params.getParamsFor("ps2_clocktimer");
			add(ps2_clocktimer = ClockTimer_factory->instantiate("ps2_clocktimer", simulationContext, params_ps2_clocktimer__));
		}
		ClockTimer_factory->dereference();
	}


    // bind local behaviors to this->control_port
    bind_method(control_port, configure, &Component__PS2Mouse::control_port__configure, this);
    bind_method(control_port, init, &Component__PS2Mouse::init, this);
    bind_method(control_port, interconnect, &Component__PS2Mouse::interconnect, this);
//  bind_method(control_port, postConnect, &Component__PS2Mouse::postConnect, this);
    bind_method(control_port, reset, &Component__PS2Mouse::control_port__reset, this);
    bind_method(control_port, loadApplicationFile, &Component__PS2Mouse::loadApplicationFile, this);
    bind_method(control_port, disconnect, &Component__PS2Mouse::disconnect, this);
    bind_method(control_port, terminate, &Component__PS2Mouse::control_port__terminate, this);
    bind_method(control_port, populateCADIMap, &Component__PS2Mouse::control_port__populateCADIMap, this);
//  bind_method(control_port, refresh, &Component__PS2Mouse::refresh, this);
    bind_method(control_port, step, &Component__PS2Mouse::step, this);
    bind_method(control_port, update, &Component__PS2Mouse::update, this);
    bind_method(control_port, communicate, &Component__PS2Mouse::communicate, this);
    bind_method(control_port, getProperty, &Component__PS2Mouse::control_port__getProperty, this);
    bind_method(control_port, traceEndOfCycle, &Component__PS2Mouse::traceEndOfCycle, this);
    bind_method(control_port, bypass, &Component__PS2Mouse::control_port__bypass, this);
    bind_method(control_port, run, &Component__PS2Mouse::control_port__run, this);
    bind_method(control_port, stop, &Component__PS2Mouse::control_port__stop, this);
    bind_method(control_port, idle, &Component__PS2Mouse::control_port__idle, this);
    bind_method(control_port, quit, &Component__PS2Mouse::control_port__quit, this);
    bind_method(control_port, setSimulationEngine, &Component__PS2Mouse::control_port__setSimulationEngine, this);
    bind_method(control_port, message, &Component__PS2Mouse::control_port__message, this);
    bind_method(control_port, callSimEngine, &Component__PS2Mouse::control_port__callSimEngine, this);

    // avoid the automatic calling of the methods through the framework
    control_port.configure.setLocalOnly(true);
    control_port.init.setLocalOnly(true);
    control_port.interconnect.setLocalOnly(true);
//  control_port.postConnect.setLocalOnly(true);
    control_port.reset.setLocalOnly(true);
    control_port.loadApplicationFile.setLocalOnly(true);
    control_port.disconnect.setLocalOnly(true);
    control_port.terminate.setLocalOnly(true);
    control_port.save.setLocalOnly(true);
    control_port.restore.setLocalOnly(true);
    control_port.populateCADIMap.setLocalOnly(true);
//  control_port.refresh.setLocalOnly(true);
    control_port.step.setLocalOnly(true);
    control_port.update.setLocalOnly(true);
    control_port.communicate.setLocalOnly(true);
    control_port.getProperty.setLocalOnly(true);
    control_port.traceEndOfCycle.setLocalOnly(true);
//  control_port.bypass.setLocalOnly(true);
//  control_port.run.setLocalOnly(true);
//  control_port.stop.setLocalOnly(true);
//  control_port.idle.setLocalOnly(true); // broadcast ports don't have setLocalOnly
//  control_port.quit.setLocalOnly(true);
//  control_port.setSimulationEngine.setLocalOnly(true);

    // bind cadiPort behaviors
    bind_method(cadiPort__, GetParameters, &Component__PS2Mouse::cadiPort__GetParameters, this);
    bind_method(cadiPort__, GetParameterInfo, &Component__PS2Mouse::cadiPort__GetParameterInfo, this);
    bind_method(cadiPort__, GetProperty, &Component__PS2Mouse::cadiPort__GetProperty, this);
    bind_method(cadiPort__, LoadApplicationFile, &Component__PS2Mouse::cadiPort__LoadApplicationFile, this);
    bind_method(cadiPort__, GetApplicationsAndCommandLineParams, &Component__PS2Mouse::cadiPort__GetApplicationsAndCommandLineParams, this);

    // connect control ports for subcomponents to subcomponents
	controlPort_ps2_clocktimer__.connectTo(ps2_clocktimer->findPort("$control"));



    // resource initialization code
    reset_resources__();

    // bind behaviors to abstract ports
	bind_method(ps2, setClockData, &Component__PS2Mouse::abstract_port__ps2__setClockData, this);
	bind_method(ps2_timer_callback, signal, &Component__PS2Mouse::abstract_port__ps2_timer_callback__signal, this);
	bind_method(mouse, mouseMove, &Component__PS2Mouse::abstract_port__mouse__mouseMove, this);
	bind_method(mouse, mouseButton, &Component__PS2Mouse::abstract_port__mouse__mouseButton, this);


    // add abstract ports
	publishSlavePort("clk_in", clk_in);
	clk_in.SetName__("clk_in");
	publishMasterPort("ps2", ps2);
	ps2.SetName__("ps2");
	ps2_timer_callback.SetName__("ps2_timer_callback");
	publishSlavePort("mouse", mouse);
	mouse.SetName__("mouse");
	__PS2Mouse_internal_1.SetName__("__PS2Mouse_internal_1");


    // wire up static connection map
	clk_in.connectTo(ps2_clocktimer->findPort("clk_in"));
	ps2_clocktimer->findPort("timer_callback").connectTo(ps2_timer_callback);
	__PS2Mouse_internal_1.connectTo(ps2_clocktimer->findPort("timer_control"));


    // init profiling

    // init resources


    // run the parameter write access functions for all of the component's parameters
    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        std::string paramName = parameterInfos__[i].name;

        switch (parameterInfos__[i].dataType)
        {
        case eslapi::CADI_PARAM_STRING:
            {
                std::string data = GetParameterValue(params, paramName, parameterInfos__[i].defaultString);
                parameter_write_string_func(paramNameToParamAccessFuncID(paramName), data);
            }
            break;
        case eslapi::CADI_PARAM_BOOL:
        case eslapi::CADI_PARAM_INT:
            {
                int64_t data = GetParameterValue(params, paramName, parameterInfos__[i].defaultValue, parameterInfos__[i].minValue, parameterInfos__[i].maxValue);
                parameter_write_func(paramNameToParamAccessFuncID(paramName), &data);
            }
            break;
        default:
            break;
        }
    }
}


Component__PS2Mouse::~Component__PS2Mouse()
{
}

void Component__PS2Mouse::control_port__configure(const sg::Params& params)
{
	if(controlPort_ps2_clocktimer__.configure.implemented()) controlPort_ps2_clocktimer__.configure(params.getParamsFor("ps2_clocktimer"));


    assert(simulationContext__->getSimulationEngine());
    cadi__ = new Component__PS2Mouse_CADI(this, simulationContext__->getSimulationEngine());

    // forward certain calls from CADI interface to this component
    cadi__->GetCADIPort().connectTo(cadiPort__);

    

    std::map< std::string, eslapi::CAInterface* > tempMap;
    control_port__populateCADIMap(tempMap, ""); // precompute mxdi map

	cadi__->EnableSubComponentCADIImport();


}

void Component__PS2Mouse::control_port__populateCADIMap(std::map< std::string, eslapi::CAInterface* >&output_map, std::string const & base_prefix)
{
    if (componentName2CADI__.empty())
    {
        componentName2CADI__[getName()] = static_cast<eslapi::CADI*>(cadi__);
        std::string prefix = getName() + ".";

		{
			std::map< std::string, eslapi::CAInterface* > compMap;
			if (controlPort_ps2_clocktimer__.populateCADIMap.implemented())
			{
				controlPort_ps2_clocktimer__.populateCADIMap(compMap, "");
			}
			insertCADIMap__(prefix, compMap);
		}

    }
    // Copy the local map into the given map with the requested prefix.
    for (std::map<std::string,eslapi::CAInterface*>::iterator it = componentName2CADI__.begin(); it != componentName2CADI__.end(); ++it)
    {
        output_map.insert(std::make_pair(base_prefix + it->first, it->second));
    }
}

eslapi::CADI* Component__PS2Mouse::obtainCADI__(const std::string &subcomp, const std::map< std::string, eslapi::CAInterface* > &componentName2CADI) const
{
    std::map< std::string, eslapi::CAInterface* >::const_iterator it = componentName2CADI.find(subcomp);
    if (it != componentName2CADI.end())
    {
        eslapi::CAInterface *cai = it->second;
        if (cai != NULL)
        {
            cai = cai->ObtainInterface(eslapi::CADI::IFNAME(), 0, 0);
            if (cai != NULL)
            {
                return static_cast<eslapi::CADI*>(cai);
            }
        }
    }
    return NULL;
}

void Component__PS2Mouse::insertCADIMap__(std::string prefix, std::map< std::string, eslapi::CAInterface* > &componentName2CADI)
{
    for (std::map<std::string, eslapi::CAInterface*>::iterator it = componentName2CADI.begin(); it != componentName2CADI.end(); it++)
    {
        // put prefix in front of all entries
        componentName2CADI__[prefix + it->first] = it->second;
    }
}


std::string Component__PS2Mouse::control_port__getProperty(const std::string& propname)
{
    if(properties__.find(propname) != properties__.end())
    {
        return properties__[propname];
    }
    else
        return ""; // unknown property
}


std::string Component__PS2Mouse::control_port__bypass(const std::string&)
{
    return "";
}


void Component__PS2Mouse::control_port__run()
{
}


void Component__PS2Mouse::control_port__stop()
{
}


void Component__PS2Mouse::control_port__idle()
{
}


void Component__PS2Mouse::control_port__quit()
{
}


void Component__PS2Mouse::control_port__setSimulationEngine(SimulationEngine*)
{
}


void Component__PS2Mouse::control_port__message(const std::string &msg, sg::message::MessageType msgType)
{
}


std::string Component__PS2Mouse::control_port__callSimEngine(const std::string &)
{
    return "";
}


void Component__PS2Mouse::control_port__reset(int level)
{
    // restore the resources' reset values before executing 'reset'
    reset_resources__();
    reset(level);
}


void Component__PS2Mouse::control_port__terminate()
{
    // the CADI was created before 'init', therefore we free it after 'terminate'
    terminate();
    freeCADIResources__();
}


void Component__PS2Mouse::freeCADIResources__()
{
    // free CADI parameter proxies


    // free CADI interface
    delete cadi__;
    cadi__ = 0;
}


// CADI Port implementations
eslapi::CADIReturn_t Component__PS2Mouse::cadiPort__GetParameters(MxU32 startIndex, MxU32 desiredNumOfParams, MxU32 *actualNumOfParams, eslapi::CADIParameterInfo_t *params)
{
    // check arguments
    if(actualNumOfParams == 0)
        return eslapi::CADI_STATUS_IllegalArgument;
    *actualNumOfParams = 0;
    if(params == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    // collect parameters
    size_t i = 0;
    for (; (i < desiredNumOfParams) && ((startIndex + i) < parameterInfos__.size()); ++i)
    {
        params[i] = parameterInfos__[startIndex + i];
    }
    *actualNumOfParams = (MxU32)i;

    return eslapi::CADI_STATUS_OK;
}

eslapi::CADIReturn_t Component__PS2Mouse::cadiPort__GetParameterInfo(const std::string &parameterName, eslapi::CADIParameterInfo_t* param)
{
    if(param == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    for (size_t i = 0; i < parameterInfos__.size(); ++i)
    {
        if (!strcmp(parameterInfos__[i].name, parameterName.c_str()))
        {
            *param = parameterInfos__[i];

            return eslapi::CADI_STATUS_OK;
        }
    }

    return eslapi::CADI_STATUS_GeneralError;
}


bool Component__PS2Mouse::ForwardParameterValueToSubcomponent(CADIParameterProxy *proxy, const char *param_name, int64_t intVal, const char *strVal)
{
    if (!proxy)
        return false;

    // we need the parameter's CADI id in order to create an eslapi::CADIParameterValue_t structure
    // therefore, we first retrieve its eslapi::CADIParameterInfo_t meta-data
    eslapi::CADIParameterInfo_t paramInfo;
    if (proxy->CADIGetParameterInfo(param_name, &paramInfo) != eslapi::CADI_STATUS_OK)
        return false;

    eslapi::CADIParameterValue_t paramVal(paramInfo.id, paramInfo.dataType, intVal, strVal);
    eslapi::CADIFactoryErrorMessage_t error;
    if (proxy->CADISetParameters(1, &paramVal, &error) != eslapi::CADI_STATUS_OK)
        return false;

    return true;
}


sg::accessfunc::AccessFuncResult Component__PS2Mouse::parameter_read_func(uint32_t id, int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PS2Mouse::parameter_read_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PS2Mouse::parameter_read_string_func(uint32_t id, std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PS2Mouse::parameter_read_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PS2Mouse::parameter_write_func(uint32_t id, const int64_t *data)
{
    if (data == 0)
        return eslapi::CADI_STATUS_IllegalArgument;

    switch (id)
    {

        default:
            printf("error: Component__PS2Mouse::parameter_write_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

sg::accessfunc::AccessFuncResult Component__PS2Mouse::parameter_write_string_func(uint32_t id, const std::string &data)
{
    switch (id)
    {

        default:
            printf("error: Component__PS2Mouse::parameter_write_string_func: undefined parameter id '0x%08x'\n", id);
            return sg::accessfunc::ACCESS_FUNC_GeneralError;
    }

    return sg::accessfunc::ACCESS_FUNC_OK;
}

void Component__PS2Mouse::cadiPort__LoadApplicationFile(const std::string& filename)
{
    loadApplicationFile(filename);
    applications2params[filename] = "";
}

void Component__PS2Mouse::cadiPort__GetApplicationsAndCommandLineParams(std::map<std::string, std::string>&applications2params_)
{
    applications2params_ = applications2params;
}

eslapi::CADIReturn_t Component__PS2Mouse::cadiPort__GetProperty(const std::string& propertyName, std::string &value)
{
    if(properties__.find(propertyName) != properties__.end())
    {
        value = properties__[propertyName];
        return eslapi::CADI_STATUS_OK;
    }
    else
    {
        value = "";
        return eslapi::CADI_STATUS_GeneralError;
    }
}

// functions to stop and lock the simulator
// we only expose the simHalt() function in the documentation for the moment

void Component__PS2Mouse::simHalt()
{
    cadi__->StopSimulation();
}


// start simulation from the inside
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
void Component__PS2Mouse::simRun()
{
    cadi__->CADIExecContinue();
}


// return true if simulation is running
// (useful from visualisation components which can execute code while the
// simulation is stopped, like key events)
bool Component__PS2Mouse::simIsRunning()
{
    uint32_t mode = eslapi::CADI_EXECMODE_Stop;
    cadi__->CADIExecGetMode(&mode);
    return mode != eslapi::CADI_EXECMODE_Stop;
}


void Component__PS2Mouse::simShutdown()
{
    cadiPort__.simShutdown();
}

void Component__PS2Mouse::simReset(uint32_t level)
{
    cadi__->CADIExecReset(level);
}

uint32_t Component__PS2Mouse::paramNameToParamAccessFuncID(const std::string &name)
{
    uint32_t id = 0;
    if (name == "") id = 0xffffffff;

    return id;
}

void Component__PS2Mouse::reset_resources__()
{
    // resource initialization code

}


} // FVP_VE_Cortex_A15x1_NMS

#line 28602 "./Linux-Release-GCC-4.1/gen/Comp_1.cpp"

// This is an anonymous namespace, it effectively declares everything inside it as 'static', e.g. only visible within the .o file it is compiled into
//     without this we get link errors when linking together LISA generated components
namespace
{

class ComponentFactoryBase :
    public sg::BasicComponentFactory
{
protected:
    void publishSubComponent(sg::ComponentFactory *factory,
                             const std::string &prefix,
                             bool publish_all,
                             const ParameterFilter &param_filter);
};

void
ComponentFactoryBase::publishSubComponent(sg::ComponentFactory *factory,
                                          const std::string &prefix,
                                          bool publish_all,
                                          const ParameterFilter &param_filter)
{
    using namespace sg;

    if (param_filter.isEmpty())
    {
        BasicComponentFactory::publishComponent(factory, prefix, publish_all);
    }
    else
    {
        for (unsigned int t = 0; t < factory->getTargetCount(); ++t)
        {
            TargetInfo *info = factory->getTargetInfo(t);

            std::vector<eslapi::CADIParameterInfo_t> my_param_infos;

            param_filter.filter(info->parameter_info, info->parameter_count, info->instance_path, my_param_infos);

            TargetInfo *my_target_info = new TargetInfo;

                        eslapi::CADITargetInfo_t *my_cadi_target_info = new eslapi::CADITargetInfo_t;
                        *my_cadi_target_info = *(info->cadi_target_info); // copy CADI target info
            my_cadi_target_info->numberOfParameters = (uint32_t)my_param_infos.size();
            my_target_info->cadi_target_info = my_cadi_target_info;

            my_target_info->parameter_count = (unsigned)my_param_infos.size();

            // only copy parameters, if there are ones
                        if (my_target_info->parameter_count)
                        {
                                my_target_info->parameter_info = new eslapi::CADIParameterInfo_t[my_target_info->parameter_count];
                                memcpy(const_cast<eslapi::CADIParameterInfo_t *>(my_target_info->parameter_info),
                                           &my_param_infos.front(),
                                           sizeof(eslapi::CADIParameterInfo_t) * my_target_info->parameter_count);
                        }

            my_target_info->instance_path = info->instance_path;

            // Skip any targets that have an instance_path of "".
            if (my_target_info->instance_path.length() > 0)
            {
                // Add the prefix at the start of the instance path.
                std::string new_path = prefix + "." + my_target_info->instance_path;
                publishTarget(*my_target_info, new_path);
            }
            else if (publish_all)
            {
                std::string new_path = prefix;
                publishTarget(*my_target_info, new_path);
            }
            delete my_target_info;
        }
    }
}

}

using namespace FVP_VE_Cortex_A15x1_NMS;

// component factory implementation
// ------------------------------------------------------------------------------
// component factory of class FVP_VE_Cortex_A15x1
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class FVP_VE_Cortex_A15x1_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "FVP_VE_Cortex_A15x1", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Top level component of the Cortex_A15x1 Versatile Express inspired model.", /* char    description[CADI_DESCRIPTION]; */       // target description
            "System", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = ARMCortexA15x1CT_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "cluster", true, ParameterFilter_cluster_of_ARMCortexA15x1CT_to_FVP_VE_Cortex_A15x1());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VEMotherBoard_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "motherboard", true, ParameterFilter_motherboard_of_VEMotherBoard_to_FVP_VE_Cortex_A15x1());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VEDaughterBoard_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "daughterboard", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~FVP_VE_Cortex_A15x1_ComponentFactoryClass()
    {
    }

public:
    FVP_VE_Cortex_A15x1_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__FVP_VE_Cortex_A15x1(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *FVP_VE_Cortex_A15x1_GetFactory()
{
        return new FVP_VE_Cortex_A15x1_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class VEDaughterBoard
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class VEDaughterBoard_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "VEDaughterBoard", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Daughtercard, inspired by the ARM Versatile Express development platform.", /* char    description[CADI_DESCRIPTION]; */       // target description
            "System", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x10000006, "dram_size",eslapi::CADI_PARAM_INT, "Size of main memory in gigabytes (2, 4 or 8)",0,MxS64CONST(0x2),MxS64CONST(0x8),MxS64CONST(0x4), "4" ),
        eslapi::CADIParameterInfo_t(0x10000007, "dram_alias",eslapi::CADI_PARAM_BOOL, "Alias the bottom 2GB region in upper memory",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x1), "true" ),
        eslapi::CADIParameterInfo_t(0x10000008, "secure_memory",eslapi::CADI_PARAM_BOOL, "Support a region of secure memory",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "false" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusDecoder_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pvbusdecoder", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PVBusMapper_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "coresight_mapper", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "sram", true, ParameterFilter_sram_of_RAMDevice_to_VEDaughterBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VEDCC_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "vedcc", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "clockdivider", true, ParameterFilter_clockdivider_of_ClockDivider_to_VEDaughterBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "clockCLCD", true, ParameterFilter_clockCLCD_of_ClockDivider_to_VEDaughterBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "dram", true, ParameterFilter_dram_of_RAMDevice_to_VEDaughterBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = TZSwitch_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "dram_aliased", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = TZSwitch_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "dram_limit_4", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = TZSwitch_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "dram_limit_8", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VEInterruptMapper_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "introuter", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = TZSwitch_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "secure_region", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = TZSwitch_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "nonsecure_region", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PVBusDecoder_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "securitydecoder", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PVBusDecoder_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "securepvbusdecoder", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = IntelStrataFlashJ3_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "secureRO", true, ParameterFilter_secureRO_of_IntelStrataFlashJ3_to_VEDaughterBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = FlashLoader_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "secureROloader", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "secureSRAM", true, ParameterFilter_secureSRAM_of_RAMDevice_to_VEDaughterBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "secureDRAM", true, ParameterFilter_secureDRAM_of_RAMDevice_to_VEDaughterBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL370_HDLCD_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "hdlcd", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "dmc", true, ParameterFilter_dmc_of_RAMDevice_to_VEDaughterBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "dmc_phy", true, ParameterFilter_dmc_phy_of_RAMDevice_to_VEDaughterBoard());
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~VEDaughterBoard_ComponentFactoryClass()
    {
    }

public:
    VEDaughterBoard_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__VEDaughterBoard(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *VEDaughterBoard_GetFactory()
{
        return new VEDaughterBoard_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class RAMDevice
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class RAMDevice_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "RAMDevice", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "RAM device, can be dynamic or static ram.", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x10000009, "size",eslapi::CADI_PARAM_INT, "Memory Size",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x100000000), "0x100000000" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "bus_slave", true, ParameterFilter_bus_slave_of_PVBusSlave_to_RAMDevice());
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~RAMDevice_ComponentFactoryClass()
    {
    }

public:
    RAMDevice_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__RAMDevice(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *RAMDevice_GetFactory()
{
        return new RAMDevice_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class TZSwitch
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class TZSwitch_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "TZSwitch", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Allow TrustZone secure/normal bus signals to be routed separately", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Bus", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x1000000B, "secure",eslapi::CADI_PARAM_INT, "Secure Port",1,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x1), "1" ),
        eslapi::CADIParameterInfo_t(0x1000000C, "normal",eslapi::CADI_PARAM_INT, "Normal Port",1,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x2), "2" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusMapper_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pvbus_mapper", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~TZSwitch_ComponentFactoryClass()
    {
    }

public:
    TZSwitch_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__TZSwitch(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *TZSwitch_GetFactory()
{
        return new TZSwitch_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PL370_HDLCD
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PL370_HDLCD_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PL370_HDLCD", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "ARM PrimeCell HD Color LCD Controller(Nominal Designation PL370)", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x1000000D, "diagnostic",eslapi::CADI_PARAM_INT, "Diagnostic level",0,MxS64CONST(0x0),MxS64CONST(0x4),MxS64CONST(0x0), "0" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "busslave", true, ParameterFilter_busslave_of_PVBusSlave_to_PL370_HDLCD());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PVBusMaster_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "busmaster", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "timer", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PL370_HDLCD_ComponentFactoryClass()
    {
    }

public:
    PL370_HDLCD_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PL370_HDLCD(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PL370_HDLCD_GetFactory()
{
        return new PL370_HDLCD_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class VEInterruptMapper
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class VEInterruptMapper_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "VEInterruptMapper", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Interrupt Mapping peripheral (non-cascaded)", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos

        componentsPublished = true;
    }
    ~VEInterruptMapper_ComponentFactoryClass()
    {
    }

public:
    VEInterruptMapper_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__VEInterruptMapper(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *VEInterruptMapper_GetFactory()
{
        return new VEInterruptMapper_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class IntelStrataFlashJ3
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class IntelStrataFlashJ3_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "IntelStrataFlashJ3", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Intel Strata Flash J3 LISA+ model.", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x10000009, "size",eslapi::CADI_PARAM_INT, "Memory Size",0,MxS64CONST(0x4),MxS64CONST(0xffffffff),MxS64CONST(0x1000), "0x1000" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "mbs", true, ParameterFilter_mbs_of_PVBusSlave_to_IntelStrataFlashJ3());
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~IntelStrataFlashJ3_ComponentFactoryClass()
    {
    }

public:
    IntelStrataFlashJ3_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__IntelStrataFlashJ3(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *IntelStrataFlashJ3_GetFactory()
{
        return new IntelStrataFlashJ3_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class FlashLoader
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class FlashLoader_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "FlashLoader", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "A device that can preload a gzipped image into flash at startup", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Other", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x1000000E, "fname",eslapi::CADI_PARAM_STRING, "Filename (Default '(none)' means: Do not load any file. An empty string will cause a warning.)",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "(none)" ),
        eslapi::CADIParameterInfo_t(0x1000000F, "fnameWrite",eslapi::CADI_PARAM_STRING, "FilenameWrite (Default '(none)' means: Do not save any file. An empty string will cause a warning.)",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "(none)" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos

        componentsPublished = true;
    }
    ~FlashLoader_ComponentFactoryClass()
    {
    }

public:
    FlashLoader_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__FlashLoader(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *FlashLoader_GetFactory()
{
        return new FlashLoader_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class VEDCC
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class VEDCC_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "VEDCC", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Daughterboard Configuration Control (DCC).", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Other", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos

        componentsPublished = true;
    }
    ~VEDCC_ComponentFactoryClass()
    {
    }

public:
    VEDCC_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__VEDCC(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *VEDCC_GetFactory()
{
        return new VEDCC_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class VEMotherBoard
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class VEMotherBoard_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "VEMotherBoard", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Model inspired by the ARM Versatile Express Motherboard", /* char    description[CADI_DESCRIPTION]; */       // target description
            "System", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x10000005, "proc_id0",eslapi::CADI_PARAM_INT, "Processor ID at CoreTile Express Site 1",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0xc000000), "0x0c000000" ),
        eslapi::CADIParameterInfo_t(0x10000010, "proc_id1",eslapi::CADI_PARAM_INT, "Processor ID at CoreTile Express Site 2",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0xff000000), "0xff000000" ),
        eslapi::CADIParameterInfo_t(0x10000011, "daughter_led_count",eslapi::CADI_PARAM_INT, "Number of LEDs that the daughter board has",0,MxS64CONST(0x0),MxS64CONST(0x20),MxS64CONST(0x0), "0" ),
        eslapi::CADIParameterInfo_t(0x10000012, "daughter_user_switch_count",eslapi::CADI_PARAM_INT, "Number of switches that the daughter board has",0,MxS64CONST(0x0),MxS64CONST(0x20),MxS64CONST(0x0), "0" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = SP805_Watchdog_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "sp805_wdog", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL050_KMI_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl050_kmi1", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL050_KMI_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl050_kmi0", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = SP804_Timer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "Timer_2_3", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = SP804_Timer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "Timer_0_1", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = SP810_SysCtrl_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "sp810_sysctrl", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL111_CLCD_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl111_clcd", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL031_RTC_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl031_rtc", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL011_Uart_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl011_uart3", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL011_Uart_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl011_uart2", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL011_Uart_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl011_uart1", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL011_Uart_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl011_uart0", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL180_MCI_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl180_mci", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PL041_AACI_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "pl041_aaci", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VE_SysRegs_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "ve_sysregs", true, ParameterFilter_ve_sysregs_of_VE_SysRegs_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = SMSC_91C111_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "smsc_91c111", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PS2Mouse_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "ps2mouse", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PS2Keyboard_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "ps2keyboard", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = MMC_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "mmc", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VE_CompactFlash_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "dummy_CF", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "dummy_usb", true, ParameterFilter_dummy_usb_of_RAMDevice_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "dummy_ram", true, ParameterFilter_dummy_ram_of_RAMDevice_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "dummy_local_dap_rom", true, ParameterFilter_dummy_local_dap_rom_of_RAMDevice_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "psram", true, ParameterFilter_psram_of_RAMDevice_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = RAMDevice_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "vram", true, ParameterFilter_vram_of_RAMDevice_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = IntelStrataFlashJ3_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "flash1", true, ParameterFilter_flash1_of_IntelStrataFlashJ3_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = IntelStrataFlashJ3_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "flash0", true, ParameterFilter_flash0_of_IntelStrataFlashJ3_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = FlashLoader_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "flashloader1", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = FlashLoader_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "flashloader0", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = MasterClock_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "clk", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "clock24MHz", true, ParameterFilter_clock24MHz_of_ClockDivider_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "clock100Hz", true, ParameterFilter_clock100Hz_of_ClockDivider_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "clockCLCD", true, ParameterFilter_clockCLCD_of_ClockDivider_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "clock35MHz", true, ParameterFilter_clock35MHz_of_ClockDivider_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "clock50Hz", true, ParameterFilter_clock50Hz_of_ClockDivider_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PVBusDecoder_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "cs3_decoder", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PVBusDecoder_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "cs2_decoder", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = TelnetTerminal_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "terminal_0", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = TelnetTerminal_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "terminal_1", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = TelnetTerminal_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "terminal_2", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = TelnetTerminal_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "terminal_3", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = AudioOut_SDL_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "audioout", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VEVisualisation_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "vis", true, ParameterFilter_vis_of_VEVisualisation_to_VEMotherBoard());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VirtualEthernetCrossover_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "virtualethernetcrossover", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = HostBridge_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "hostbridge", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VFS2_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "vfs2", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = VirtioBlockDevice_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "virtioblockdevice", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~VEMotherBoard_ComponentFactoryClass()
    {
    }

public:
    VEMotherBoard_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__VEMotherBoard(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *VEMotherBoard_GetFactory()
{
        return new VEMotherBoard_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class SP804_Timer
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class SP804_Timer_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "SP804_Timer", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "ARM Dual-Timer Module(SP804)", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "clk_div1", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "clk_div0", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "busslave", true, ParameterFilter_busslave_of_PVBusSlave_to_SP804_Timer());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = CounterModule_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "counter0", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = CounterModule_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "counter1", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~SP804_Timer_ComponentFactoryClass()
    {
    }

public:
    SP804_Timer_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__SP804_Timer(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *SP804_Timer_GetFactory()
{
        return new SP804_Timer_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class CounterModule
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class CounterModule_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "CounterModule", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Internal component used by SP804 Timer module", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Other", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "timer", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~CounterModule_ComponentFactoryClass()
    {
    }

public:
    CounterModule_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__CounterModule(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *CounterModule_GetFactory()
{
        return new CounterModule_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class AudioOut_SDL
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class AudioOut_SDL_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "AudioOut_SDL", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "SDL based Audio Output for PL041_AACI.", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Other", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos

        componentsPublished = true;
    }
    ~AudioOut_SDL_ComponentFactoryClass()
    {
    }

public:
    AudioOut_SDL_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__AudioOut_SDL(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *AudioOut_SDL_GetFactory()
{
        return new AudioOut_SDL_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class VE_CompactFlash
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class VE_CompactFlash_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "VE_CompactFlash", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "", /* char    description[CADI_DESCRIPTION]; */       // target description
            "", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "bus_slave", true, ParameterFilter_bus_slave_of_PVBusSlave_to_VE_CompactFlash());
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~VE_CompactFlash_ComponentFactoryClass()
    {
    }

public:
    VE_CompactFlash_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__VE_CompactFlash(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *VE_CompactFlash_GetFactory()
{
        return new VE_CompactFlash_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class HostBridge
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class HostBridge_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "HostBridge", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Host Socket Interface Component", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x10000016, "interfaceName",eslapi::CADI_PARAM_STRING, "Host Interface",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "ARM0" ),
        eslapi::CADIParameterInfo_t(0x10000017, "userNetworking",eslapi::CADI_PARAM_BOOL, "Enable user-mode networking",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "false" ),
        eslapi::CADIParameterInfo_t(0x10000018, "userNetSubnet",eslapi::CADI_PARAM_STRING, "Virtual subnet for user-mode networking",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "172.20.51.0/24" ),
        eslapi::CADIParameterInfo_t(0x10000019, "userNetPorts",eslapi::CADI_PARAM_STRING, "Listening ports to expose in user-mode networking",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos

        componentsPublished = true;
    }
    ~HostBridge_ComponentFactoryClass()
    {
    }

public:
    HostBridge_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__HostBridge(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *HostBridge_GetFactory()
{
        return new HostBridge_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class MMC
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class MMC_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "MMC", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Generic Multimedia Card", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x1000001A, "p_mmc_file",eslapi::CADI_PARAM_STRING, "MMCard filename",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "mmc.dat" ),
        eslapi::CADIParameterInfo_t(0x1000001B, "p_prodName",eslapi::CADI_PARAM_STRING, "Card ID Product Name (6 chars)",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "ARMmmc" ),
        eslapi::CADIParameterInfo_t(0x1000001C, "p_prodRev",eslapi::CADI_PARAM_INT, "Card ID Product Revision",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x1), "0x01" ),
        eslapi::CADIParameterInfo_t(0x1000001D, "p_manid",eslapi::CADI_PARAM_INT, "Card ID Manufacturer ID",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x2), "0x02" ),
        eslapi::CADIParameterInfo_t(0x1000001E, "p_OEMid",eslapi::CADI_PARAM_INT, "Card ID OEM ID",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "0x0000" ),
        eslapi::CADIParameterInfo_t(0x1000001F, "p_sernum",eslapi::CADI_PARAM_INT, "Card Serial Number",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0xca4d0001), "0xca4d0001" ),
        eslapi::CADIParameterInfo_t(0x10000020, "p_fast_access",eslapi::CADI_PARAM_BOOL, "Don't simulate MMC block access delays",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x1), "true" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "timer", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~MMC_ComponentFactoryClass()
    {
    }

public:
    MMC_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__MMC(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *MMC_GetFactory()
{
        return new MMC_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PL011_Uart
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PL011_Uart_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PL011_Uart", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "ARM PrimeCell UART(PL011)", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x10000021, "clock_rate",eslapi::CADI_PARAM_INT, "Clock rate for PL011.",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0xe10000), "14745600" ),
        eslapi::CADIParameterInfo_t(0x10000022, "baud_rate",eslapi::CADI_PARAM_INT, "Baud rate.",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x9600), "38400" ),
        eslapi::CADIParameterInfo_t(0x10000023, "uart_enable",eslapi::CADI_PARAM_BOOL, "Enable uart when the system starts up. (clock_rate and baud_rate are only valid when this option is enabled.)",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "false" ),
        eslapi::CADIParameterInfo_t(0x10000024, "untimed_fifos",eslapi::CADI_PARAM_BOOL, "Ignore the clock rate and transmit/receive serial data immediately",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x1), "true" ),
        eslapi::CADIParameterInfo_t(0x10000025, "out_file",eslapi::CADI_PARAM_STRING, "Output file to hold data written by the UART (use '-' to send all output to stdout)",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "" ),
        eslapi::CADIParameterInfo_t(0x10000026, "in_file",eslapi::CADI_PARAM_STRING, "Input file for data to be read by the UART",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "" ),
        eslapi::CADIParameterInfo_t(0x10000027, "unbuffered_output",eslapi::CADI_PARAM_BOOL, "Unbuffered output",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "false" ),
        eslapi::CADIParameterInfo_t(0x10000028, "in_file_escape_sequence",eslapi::CADI_PARAM_STRING, "Input file escape sequence",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "##" ),
        eslapi::CADIParameterInfo_t(0x10000029, "shutdown_on_eot",eslapi::CADI_PARAM_BOOL, "Shutdown simulation when a EOT (ASCII 4) char is transmitted (useful for regression tests when semihosting is not available)",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "false" ),
        eslapi::CADIParameterInfo_t(0x1000002A, "shutdown_tag",eslapi::CADI_PARAM_STRING, "Shutdown simulation when a string is transmitted",1,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "busslave", true, ParameterFilter_busslave_of_PVBusSlave_to_PL011_Uart());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "clk_divider", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "timer", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PL011_Uart_ComponentFactoryClass()
    {
    }

public:
    PL011_Uart_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PL011_Uart(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PL011_Uart_GetFactory()
{
        return new PL011_Uart_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PL031_RTC
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PL031_RTC_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PL031_RTC", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "ARM PrimeCell Real Time Clock(PL031)", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "busslave", true, ParameterFilter_busslave_of_PVBusSlave_to_PL031_RTC());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "timer", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PL031_RTC_ComponentFactoryClass()
    {
    }

public:
    PL031_RTC_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PL031_RTC(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PL031_RTC_GetFactory()
{
        return new PL031_RTC_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PL041_AACI
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PL041_AACI_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PL041_AACI", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "ARM PrimeCell Advanced Audio CODEC Interface(PL041)", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "busslave", true, ParameterFilter_busslave_of_PVBusSlave_to_PL041_AACI());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "timer", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PL041_AACI_ComponentFactoryClass()
    {
    }

public:
    PL041_AACI_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PL041_AACI(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PL041_AACI_GetFactory()
{
        return new PL041_AACI_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PL050_KMI
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PL050_KMI_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PL050_KMI", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "ARM PrimeCell PS2 Keyboard/Mouse Interface(PL050)", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = ClockDivider_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "clk_divider", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "clk_timer", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "busslave", true, ParameterFilter_busslave_of_PVBusSlave_to_PL050_KMI());
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PL050_KMI_ComponentFactoryClass()
    {
    }

public:
    PL050_KMI_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PL050_KMI(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PL050_KMI_GetFactory()
{
        return new PL050_KMI_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PL111_CLCD
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PL111_CLCD_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PL111_CLCD", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "ARM PrimeCell Color LCD Controller(PL111)", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x1000002B, "pixel_double_limit",eslapi::CADI_PARAM_INT, "Minimum LCD pixel width before display will be zoomed",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x12c), "300" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PL11x_CLCD_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "pl11x_clcd", true, ParameterFilter_pl11x_clcd_of_PL11x_CLCD_to_PL111_CLCD());
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PL111_CLCD_ComponentFactoryClass()
    {
    }

public:
    PL111_CLCD_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PL111_CLCD(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PL111_CLCD_GetFactory()
{
        return new PL111_CLCD_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PL11x_CLCD
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PL11x_CLCD_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PL11x_CLCD", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Internal component used by PL110 and PL111 CLCD controllers", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {
        eslapi::CADIParameterInfo_t(0x1000002B, "pixel_double_limit",eslapi::CADI_PARAM_INT, "Minimum LCD pixel width before display will be zoomed",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x12c), "300" ),
        eslapi::CADIParameterInfo_t(0x1000002C, "pl11x_behavior",eslapi::CADI_PARAM_INT, "Define PL11x behaviour. 0 for PL110, 1 for PL111",0,MxS64CONST(0x8000000000000000),MxS64CONST(0x7fffffffffffffff),MxS64CONST(0x0), "0" ),

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "busslave", true, ParameterFilter_busslave_of_PVBusSlave_to_PL11x_CLCD());
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = PVBusMaster_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "busmaster", true);
            componentFactory->dereference();
        }
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "timer", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PL11x_CLCD_ComponentFactoryClass()
    {
    }

public:
    PL11x_CLCD_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PL11x_CLCD(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PL11x_CLCD_GetFactory()
{
        return new PL11x_CLCD_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PL180_MCI
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PL180_MCI_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PL180_MCI", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "ARM PrimeCell Multimedia Card Interface (PL180)", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = PVBusSlave_GetFactory();
            ComponentFactoryBase::publishSubComponent(componentFactory, "busslave", true, ParameterFilter_busslave_of_PVBusSlave_to_PL180_MCI());
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PL180_MCI_ComponentFactoryClass()
    {
    }

public:
    PL180_MCI_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PL180_MCI(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PL180_MCI_GetFactory()
{
        return new PL180_MCI_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PS2Keyboard
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PS2Keyboard_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PS2Keyboard", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Interface component, which takes the keypress/release signals from the Visualisation component and translates them into clocked PS2Data signals which can be routed to a PL050_KMI component.", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "ps2_clocktimer", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PS2Keyboard_ComponentFactoryClass()
    {
    }

public:
    PS2Keyboard_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PS2Keyboard(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PS2Keyboard_GetFactory()
{
        return new PS2Keyboard_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS
// ------------------------------------------------------------------------------
// component factory of class PS2Mouse
// ------------------------------------------------------------------------------
//


namespace
{

// component factory class
// (this concrete class is never exposed to the outside world)
class PS2Mouse_ComponentFactoryClass: public ComponentFactoryBase
{
    bool componentsPublished;
    void lazyPublish(void)
    {
        static eslapi::CADITargetInfo_t info
        (
            0, /* MxU32 id; (overridden in CADIFactory) */                                                              // used for identification
            "PS2Mouse", /* char  targetName[CADI_NAME_SIZE];     */      // name of the target, i.e. the "type", not the instance name
            "", /* char instanceName[CADI_NAME_SIZE]; (overridden in CADIFactory) */    // name of the CADI target instance
            "8.1.37", /* char        version[CADI_DESCRIPTION]; */           // version string
            "Interface component, which takes the keypress/release signals from the Visualisation component and translates them into clocked PS2Data signals which can be routed to a PL050_KMI component.", /* char    description[CADI_DESCRIPTION]; */       // target description
            "Peripheral", /* char componentType[CADI_NAME_SIZE]; */       // classification of the target into a user-defined group
            0, /* MxU32 numberOfParameters; (overridden below) */                               // number of parameters supported
            0, /* bool        executesSoftware; */                            // false = does not execute programs, true = executes software
            false, /* MxU32     isHardwareModel; */                             // 0 = is software model, 1 = is hardware model
            "", /* char systemName[CADI_NAME_SIZE];  (overridden in CADIFactory) */             // name of the system the target belongs to.
            // Is empty for single-core standalone models.
            0, /* MxU32 systemID; (overridden in CADIFactory) */                                                // system id
            "" /* char  systemDescription[CADI_DESCRIPTION]; (overridden in CADIFactory) */ // description of the system
        );

        static eslapi::CADIParameterInfo_t parameters[] =
        {

            eslapi::CADIParameterInfo_t( 0, "", eslapi::CADI_PARAM_BOOL, "", 1, INT64_C(0), INT64_C(-1), 0, "0" )
        };
        info.numberOfParameters = (sizeof(parameters) / sizeof(parameters[0])) - 1;

        // build TargetInfo
        sg::TargetInfo targetInfo;
        targetInfo.cadi_target_info = &info;
        targetInfo.parameter_count = targetInfo.cadi_target_info->numberOfParameters;
        targetInfo.parameter_info = parameters;

        // publish this component's TargetInfo
        publishTarget(targetInfo, "");

        // publish subcomponent TargetInfos
        {
            sg::ComponentFactory *componentFactory = ClockTimer_GetFactory();
            ComponentFactoryBase::publishComponent(componentFactory, "ps2_clocktimer", true);
            componentFactory->dereference();
        }

        componentsPublished = true;
    }
    ~PS2Mouse_ComponentFactoryClass()
    {
    }

public:
    PS2Mouse_ComponentFactoryClass() {
        componentsPublished = false;
    }

    virtual void dereference() { delete this; }

    virtual sg::ComponentBase *instantiate(std::string const & instance_name,
                                                sg::SimulationContext *simulationContext,
                                                sg::Params const & params)
    {
        return new FVP_VE_Cortex_A15x1_NMS::Component__PS2Mouse(instance_name.c_str(), simulationContext, params);
    }

    virtual unsigned int getTargetCount()
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetCount();
    }

    virtual sg::TargetInfo * getTargetInfo(unsigned int index)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(index);
    }

    virtual sg::TargetInfo * getTargetInfo(std::string const & instance_path)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::getTargetInfo(instance_path);
    }

    virtual void publishSubComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all, const ParameterFilter &param_filter)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishSubComponent(factory, prefix, publish_all, param_filter);
    }

    virtual void publishComponent(sg::ComponentFactory *factory, const std::string &prefix,
                          bool publish_all)
    {
        if (!componentsPublished) lazyPublish();
        return ComponentFactoryBase::publishComponent(factory, prefix, publish_all);
    }

};

}

namespace FVP_VE_Cortex_A15x1_NMS {

// factory function
// (this is the function which is exposed to the outside world)
sg::ComponentFactory *PS2Mouse_GetFactory()
{
        return new PS2Mouse_ComponentFactoryClass();
}

} // FVP_VE_Cortex_A15x1_NMS

