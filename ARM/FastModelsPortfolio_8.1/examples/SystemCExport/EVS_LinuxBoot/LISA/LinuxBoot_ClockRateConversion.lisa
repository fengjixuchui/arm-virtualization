// This file was generated by System Generator Canvas
// --------------------------------------------------
component LinuxBoot_ClockRateConversion
{
    composition
    {
        clk_div0: ClockDivider();
        clk_div1: ClockDivider();
        clk_div2: ClockDivider();
        clk_div3: ClockDivider();
    }

    includes
    {
        #include    "sg/SGScheduler.h"
    }

    connection
    {
        self.clock => clk_div0.clk_in;
        self.clock => clk_div1.clk_in;
        self.clock => clk_div2.clk_in;
        self.clock => clk_div3.clk_in;
    }

    slave port<ClockRateControl> rate_ctrl[4]
    {
        behavior set(MxU32 idx, uint32_t mul, uint32_t div)
        {
            switch(idx)
            {
                case 0:
                    clk_div0.rate.set(mul,div);
                    rate_hz[0].setValue((uint64_t)dynamic_cast<sg::ClockDivider*>(clk_div0)->rateInHz());
                break;
                case 1:
                    clk_div1.rate.set(mul,div);
                    rate_hz[1].setValue((uint64_t)dynamic_cast<sg::ClockDivider*>(clk_div1)->rateInHz());
                break;
                case 2:
                    clk_div2.rate.set(mul,div);
                    rate_hz[2].setValue((uint64_t)dynamic_cast<sg::ClockDivider*>(clk_div2)->rateInHz());
                break;
                case 3:
                    clk_div3.rate.set(mul,div);
                    rate_hz[3].setValue((uint64_t)dynamic_cast<sg::ClockDivider*>(clk_div3)->rateInHz());
                break;
                default:
                    std::cout << "Error: port index=" << idx << " is out of range." << std::endl;
                break;
            }
        }
    }

    slave port<ClockSignal> clock;
    master port<Value_64> rate_hz[4];
}
