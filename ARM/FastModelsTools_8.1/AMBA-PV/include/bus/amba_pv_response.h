/*
 * AMBA-PV: ambap_pv_response.h - AMBA-PV response class.
 *
 * Copyright 2007-2009 ARM Limited.
 * All rights reserved.
 */

#ifndef AMBA_PV_RESPONSE__H
#define AMBA_PV_RESPONSE__H

/**
 * @file        amba_pv_response.h
 *
 * @brief       AMBA-PV response class.
 */

/* Includes */
#include "core/amba_pv_types.h"

/* Namespaces */

/**
 * @brief       AMBA-PV namespace.
 */
namespace amba_pv {

/* Datatypes */

/**
 * @brief       AMBA-PV response type.
 *
 * The bit representation of this type matches the xRESP AMBA signals.
 * The @c AMBA_PV_ACE macro must be defined at compile time to use
 * the extended ACE responses that indicate cache-line dirty state and
 * cache line might be duplicated hints.
 *
 * @see         amba_pv_response
 */

enum amba_pv_resp_t {
    AMBA_PV_OKAY   = 0x0, /**< Indicates that a normal access has been successful.
                           * Can also indicate an exclusive access has failed. */
    AMBA_PV_EXOKAY = 0x1, /**< Indicates that either the read or write potion of
                           *   an exclusive access has been successful. */
    AMBA_PV_SLVERR = 0x2, /**< Indicates that the access has reached the slave
                           * successfully, but the slave returned an error
                           * condition to the originating master. */
    AMBA_PV_DECERR = 0x3  /**< Indicates that there is no slave at the transaction
                           * address. This is typically generated by an interconnect
                           * component. */
};

/**
 * @brief       AMBA-PV response class.
 */
class amba_pv_response {

    /* Construction */
    public:
        amba_pv_response();
        amba_pv_response(amba_pv_resp_t);

    /* Accessors */

        /* Response */
        void set_resp(amba_pv_resp_t);
        amba_pv_resp_t get_resp() const;

        /* Normal access response */
        bool is_okay() const;
        void set_okay();

        /* Exclusive access response */
        bool is_exokay() const;
        void set_exokay();

        /* Slave error response */
        bool is_slverr() const;
        void set_slverr();

        /* Decoder error response */
        bool is_decerr() const;
        void set_decerr();

        /* PassDirty read and snoop response bit */
        bool is_pass_dirty() const;
        void set_pass_dirty(bool /* dirty */ =true);

        /* IsShared read and snoop response bit */
        bool is_shared() const;
        void set_shared(bool /* shared */=true);

        /* DataTransfer snoop response bit */
        bool is_snoop_data_transfer() const;
        void set_snoop_data_transfer(bool /* data_transfer */=true);

        /* Error snoop response bit */
        bool is_snoop_error() const;
        void set_snoop_error(bool /* error */=true);

        /* WasUnique snoop response bit */
        bool is_snoop_was_unique() const;
        void set_snoop_was_unique(bool /* was_unique */=true);

        /* Reseting */
        void reset();

    /* Implementation */
    private:

        /* Variable members */
        amba_pv_resp_t m_resp;
        bool m_pass_dirty;
        bool m_is_shared;
        bool m_snoop_data_transfer;
        bool m_snoop_error;
        bool m_snoop_was_unique;
};

/* Functions */

/**
 * @brief       Returns the text string representation of the specified AMBA-PV
 *              response.
 *
 * @param       resp AMBA-PV response value.
 *
 * @return      text string representation of @a resp.
 */
inline std::string
amba_pv_resp_string(amba_pv_resp_t resp) {
    switch (resp) {
        case AMBA_PV_OKAY:
            return "AMBA_PV_OKAY";
        case AMBA_PV_EXOKAY:
            return "AMBA_PV_EXOKAY";
        case AMBA_PV_SLVERR:
            return "AMBA_PV_SLVERR";
        case AMBA_PV_DECERR:
            return "AMBA_PV_DECERR";
    };
    return "AMBA_PV_UNKNOWN";
}

/**
 * @brief       Translates the specified TLM 2.0 response status value into an
 *              AMBA-PV response.
 *
 * @param       response_status TLM 2.0 response status value to translate.
 * @param       is_exclusive @c true if the corrresponding transaction is an
 *              exclusive access, @c false otherwise (default).
 *
 * @return      AMBA-PV response.
 */
inline amba_pv_resp_t
amba_pv_resp_from_tlm(tlm::tlm_response_status response_status,
                      bool is_exclusive = false) {
    switch (response_status) {
        case tlm::TLM_OK_RESPONSE:
            return (is_exclusive? AMBA_PV_EXOKAY: AMBA_PV_OKAY);
        case tlm::TLM_INCOMPLETE_RESPONSE:
            return AMBA_PV_DECERR;
        case tlm::TLM_GENERIC_ERROR_RESPONSE:
            return (is_exclusive? AMBA_PV_OKAY: AMBA_PV_SLVERR);
        case tlm::TLM_ADDRESS_ERROR_RESPONSE:
            return AMBA_PV_DECERR;
        case tlm::TLM_COMMAND_ERROR_RESPONSE:
            return AMBA_PV_SLVERR;
        case tlm::TLM_BURST_ERROR_RESPONSE:
            return AMBA_PV_SLVERR;
        case tlm::TLM_BYTE_ENABLE_ERROR_RESPONSE:
            return AMBA_PV_SLVERR;
    };
    return AMBA_PV_OKAY;
}

/**
 * @brief       Translates the specified AMBA-PV response value into a TLM 2.0
 *              response status.
 *
 * @note        AMBA-PV does not use the @c tlm::TLM_INCOMPLETE_RESPONSE
 *              response status.
 *
 * @param       resp AMBA-PV response value to translate.
 *
 * @return      TLM 2.0 response status.
 */
inline tlm::tlm_response_status
amba_pv_resp_to_tlm(amba_pv_resp_t resp) {
    switch (resp & 0x3) {
        case AMBA_PV_OKAY:
        case AMBA_PV_EXOKAY:
            return tlm::TLM_OK_RESPONSE;

        case AMBA_PV_SLVERR:
            return tlm::TLM_GENERIC_ERROR_RESPONSE;

        case AMBA_PV_DECERR:
            return tlm::TLM_ADDRESS_ERROR_RESPONSE;
    };
    return tlm::TLM_INCOMPLETE_RESPONSE;
}

/**
 * @brief       Default constructor.
 *
 * By default:
 * - the response is initialized to @c AMBA_PV_OKAY.
 */
inline
amba_pv_response::amba_pv_response():
    m_resp(AMBA_PV_OKAY),
    m_pass_dirty(false),
    m_is_shared(false),
    m_snoop_data_transfer(false),
    m_snoop_error(false),
    m_snoop_was_unique(false) {
}

/**
 * @brief       Constructor.
 *
 * @param       resp AMBA-PV transaction response
 */
inline
amba_pv_response::amba_pv_response(amba_pv_resp_t resp):
    m_resp(resp),
    m_pass_dirty(false),
    m_is_shared(false),
    m_snoop_data_transfer(false),
    m_snoop_error(false),
    m_snoop_was_unique(false) {
}

/**
 * @brief       Sets transaction response.
 *
 * @param       resp transaction response.
 *
 * @see         get_resp(), set_okay(), set_exokay(), set_slverr(), set_decerr(), set_pass_dirty(), set_shared()
 */
inline void
amba_pv_response::set_resp(amba_pv_resp_t resp) {
    m_resp = resp;
}

/**
 * @brief       Returns transaction response.
 *
 * @see         set_resp(), is_okay(), is_exokay(), is_slverr(), is_decerr(), is_pass_dirty(), is_shared()
 */
inline amba_pv_resp_t
amba_pv_response::get_resp() const {
    return (m_resp);
}

/**
 * @brief       Returns wether or not the @c OKAY response is set.
 *
 * The @c OKAY reponse indicates if a normal access has been successful. It
 * indicates also an exclusive access failure. 
 *
 * @return      @c true if the @c OKAY response is set, @c false otherwise.
 *
 * @see         set_okay()
 */
inline bool
amba_pv_response::is_okay() const {
    return m_resp == AMBA_PV_OKAY;
}

/**
 * @brief       Sets the @c OKAY response.
 * 
 * @see         is_okay(), set_pass_dirty(), set_shared()
 */
inline void
amba_pv_response::set_okay() {
    m_resp = AMBA_PV_OKAY;
}

/**
 * @brief       Returns wether or not the response is @c EXOKAY.
 *
 * If @c true, the @c EXOKAY response indicates that either the read or write
 * portion of an exclusive access has been successful. 
 *
 * @return      @c true if the response is @c EXOKAY, @c false otherwise.
 *
 * @see         set_exokay(), is_pass_dirty(), is_shared()
 */
inline bool
amba_pv_response::is_exokay() const {
    return m_resp == AMBA_PV_EXOKAY;
}

/**
 * @brief       Sets the @c EXOKAY response.
 *
 * The PassDirty and IsShared response flags will be cleared.
 *
 * @see         is_exokay(), set_pass_dirty(), set_shared()
 */
inline void
amba_pv_response::set_exokay() {
    m_resp = AMBA_PV_EXOKAY;
}

/**
 * @brief       Returns wether or not the response is @c SLVERR.
 *
 * The @c SLVERR response is used if the access has reached the slave successfully,
 * but the slave returned an error condition to the originating master.
 *
 * @return      @c true if the response is @c SLVERR, @c false otherwise.
 *
 * @see         set_slverr()
 */
inline bool
amba_pv_response::is_slverr() const {
    return m_resp == AMBA_PV_SLVERR;
}

/**
 * @brief       Sets the @c SLVERR response.
 *
 * @see         is_slverr()
 */
inline void
amba_pv_response::set_slverr() {
    m_resp = AMBA_PV_SLVERR;
}

/**
 * @brief       Returns wether or not the response is @c DECERR.
 *
 * The @c DECERR response is generated typically by an interconnect component to
 * indicate that there is no slave at the transaction address.
 *
 * @return      @c true if the response is @c DECERR, @c false otherwise.
 *
 * @see         set_decerr()
 */
inline bool
amba_pv_response::is_decerr() const {
    return m_resp == AMBA_PV_DECERR;
}

/**
 * @brief       Sets the @c DECERR response.
 *
 * @see         is_decerr()
 */
inline void
amba_pv_response::set_decerr() {
    m_resp = AMBA_PV_DECERR;
}

/**
 * @brief       Returns wether or not the @c PassDirty response bit is set.
 *
 * The @c PassDirty response bit indicates the cache line is dirty with respect
 * to main memory. For ACE this bit is a part of both read and snoop
 * responses.
 *
 * @return      @c true if the @c PassDirty bit is set, @c false otherwise.
 *
 * @see         set_pass_dirty(), set_okay(), set_exokay()
 */
inline bool
amba_pv_response::is_pass_dirty() const {
    return m_pass_dirty;
}

/**
 * @brief       Sets the @c PassDirty response bit.
 *
 * The @c PassDirty response bit indicates the cache line is dirty with respect
 * to main memory. For ACE this bit is a part of both read and snoop
 * responses.
 *
 * @param       pass_dirty status of @c PassDirty bit
 *
 * @see         is_pass_dirty(), is_okay(), is_exokay()
 */
inline void
amba_pv_response::set_pass_dirty(bool pass_dirty /* = true */ ) {
    m_pass_dirty = pass_dirty;
}

/**
 * @brief       Returns wether or not the @c IsShared response bit is set.
 *
 * The @c IsShared response bit hints that another copy of the data might be held
 * in another cache. For ACE this bit is a part of both read and snoop
 * responses.
 *
 * @return      @c true if the @c IsShared bit is set, @c false otherwise.
 *
 * @see         set_shared(), set_okay(), set_exokay()
 */
inline bool
amba_pv_response::is_shared() const {
    return m_is_shared;
}

/**
 * @brief       Sets the @c IsShared response bit.
 *
 * The @c IsShared response bit hints that another copy of the data might be held
 * in another cache. For ACE this bit is a part of both read and snoop
 * responses.
 *
 * @param       is_shared status of @c IsShared bit
 *
 * @see         is_shared(), is_okay(), is_exokay()
 */
inline void
amba_pv_response::set_shared(bool is_shared /* = true */) {
    m_is_shared = is_shared;
}

/**
 * @brief       Returns wether or not the @c DataTransfer snoop response bit is set.
 *
 * The @c DataTransfer response bit indicates that a full cache line of data will be
 * provided on the snoop data channel for this transaction.
 *
 * @return      @c true if the @c DataTransfer bit is set, @c false otherwise.
 *
 * @see         set_snoop_data_transfer()
 */
inline bool
amba_pv_response::is_snoop_data_transfer() const {
    return m_snoop_data_transfer;
}

/**
 * @brief       Sets the @c DataTransfer snoop response bit.
 *
 * The @c DataTransfer response bit indicates that a full cache line of data will be
 * provided on the snoop data channel for this transaction.
 *
 * @param       data_transfer status of @c DataTransfer bit
 *
 * @see         is_snoop_data_transfer()
 */
inline void
amba_pv_response::set_snoop_data_transfer(bool data_transfer/* = true */ ) {
    m_snoop_data_transfer = data_transfer;
}

/**
 * @brief       Returns wether or not the @c Error snoop response bit is set.
 *
 * The @c Error response bit indicates that the snooped cache line is in error.
 *
 * @return      @c true if the @c Error bit is set, @c false otherwise.
 *
 * @see         set_snoop_error()
 */
inline bool
amba_pv_response::is_snoop_error() const {
    return m_snoop_error;
}

/**
 * @brief       Sets the @c Error snoop response bit.
 *
 * The @c Error response bit indicates that the snooped cache line is in error.
 *
 * @param       error status of @c Error bit
 *
 * @see         is_snoop_error()
 */
inline void
amba_pv_response::set_snoop_error(bool error/* = true */ ) {
    m_snoop_error = error;
}

/**
 * @brief       Returns wether or not the @c WasUnique snoop response bit is set.
 *
 * The @c WasUnique bit indicates that the cache line was held in a Unique state
 * before the snoop.
 *
 * @return      @c true if the @c WasUnique bit is set, @c false otherwise.
 *
 * @see         set_snoop_was_unique()
 */
inline bool
amba_pv_response::is_snoop_was_unique() const {
    return m_snoop_was_unique;
}

/**
 * @brief       Sets the @c WasUnique snoop response bit.
 *
 * The @c WasUnique bit indicates that the cache line was held in a Unique state
 * before the snoop.
 *
 * @param       was_unique status of @c WasUnique bit
 *
 * @see         is_snoop_was_unique()
 */
inline void
amba_pv_response::set_snoop_was_unique(bool was_unique/* = true */) {
    m_snoop_was_unique = was_unique;
}

/**
 * @brief       Resets all members of this AMBA-PV extension to their default
 *              value.
 */
inline void
amba_pv_response::reset() {
    m_resp = AMBA_PV_OKAY;
    m_pass_dirty = false;
    m_is_shared = false;
    m_snoop_data_transfer = false;
    m_snoop_error = false;
    m_snoop_was_unique = false;
}

}   /* namespace amba_pv */

#endif  /* defined(AMBA_PV_RESPONSE__H) */
